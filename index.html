<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clio → Airtable Merger</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback } = React;

// State-machine CSV Parser - handles multiline quoted fields correctly
const parseCSV = (text) => {
  if (!text || !text.trim()) return { headers: [], rows: [] };

  const rows = [];
  let currentRow = [];
  let currentField = '';
  let inQuotes = false;

  // Character-by-character state machine
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const nextChar = text[i + 1];

    if (inQuotes) {
      // IN_QUOTES state
      if (char === '"' && nextChar === '"') {
        // Escaped quote "" -> single "
        currentField += '"';
        i++; // Skip next quote
      } else if (char === '"') {
        // Exit quotes
        inQuotes = false;
      } else {
        // Append character (including newlines inside quotes)
        currentField += char;
      }
    } else {
      // NOT_IN_QUOTES state
      if (char === '"') {
        // Enter quotes
        inQuotes = true;
      } else if (char === ',') {
        // End field, start new field
        currentRow.push(currentField.trim());
        currentField = '';
      } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
        // End field, end row
        currentRow.push(currentField.trim());
        currentField = '';

        // Only add non-empty rows (at least one non-empty field)
        if (currentRow.some(f => f !== '')) {
          rows.push([...currentRow]);
        }
        currentRow = [];

        // Skip \n in \r\n
        if (char === '\r' && nextChar === '\n') {
          i++;
        }
      } else if (char === '\r') {
        // Standalone \r (old Mac format)
        currentRow.push(currentField.trim());
        currentField = '';
        if (currentRow.some(f => f !== '')) {
          rows.push([...currentRow]);
        }
        currentRow = [];
      } else {
        // Append regular character
        currentField += char;
      }
    }
  }

  // Handle final field/row (file may not end with newline)
  if (currentField !== '' || currentRow.length > 0) {
    currentRow.push(currentField.trim());
    if (currentRow.some(f => f !== '')) {
      rows.push(currentRow);
    }
  }

  if (rows.length === 0) return { headers: [], rows: [] };

  const headers = rows[0];
  const dataRows = rows.slice(1).map(row => {
    const obj = {};
    headers.forEach((h, i) => obj[h] = row[i] || '');
    return obj;
  });

  return { headers, rows: dataRows };
};

// Normalize A# to ###-###-### format
const normalizeANumber = (aNum) => {
  if (!aNum) return '';
  const digits = aNum.replace(/[^0-9]/g, '');
  if (digits.length === 9) {
    return `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`;
  }
  if (digits.length === 10 && digits[0] === '1') {
    return `${digits.slice(1, 4)}-${digits.slice(4, 7)}-${digits.slice(7, 10)}`;
  }
  return digits;
};

// Extract A# using multiple patterns (ordered by specificity)
const extractANumber = (text) => {
  if (!text) return null;

  const patterns = [
    // |A-203-599-282 or |A203599282 (pipe delimiter format)
    /\|A-?(\d{3})-?(\d{3})-?(\d{3})/i,
    // A-Number: 213-645-057 or A-Number:213645057
    /A-Number:?\s*(\d{3})-?(\d{3})-?(\d{3})/i,
    // A# 123-456-789 or A#: 123456789
    /A#\s*:?\s*(\d{3})-?(\d{3})-?(\d{3})/i,
    // A-213-645-057 or A-213645057 (standalone A- prefix)
    /\bA-(\d{3})-?(\d{3})-?(\d{3})\b/i,
    // Raw 9 digits at word boundary (last resort)
    /\b(\d{3})-?(\d{3})-?(\d{3})\b/,
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      // Collect capture groups and normalize
      const digits = match.slice(1).join('').replace(/\D/g, '');
      if (digits.length === 9) {
        return `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`;
      }
    }
  }
  return null; // No A# found
};

// Normalize name for matching
const normalizeName = (lastName, firstName) => {
  const clean = (s) => (s || '').toUpperCase().trim().replace(/[^A-Z\s]/g, '');
  return `${clean(lastName)}|${clean(firstName)}`;
};

// Known hearing type keywords (in order of specificity)
const HEARING_TYPE_KEYWORDS = ['MASTER', 'MCH', 'INDIVIDUAL', 'ICH', 'BOND', 'STATUS', 'CUSTODY', 'CALENDAR'];

// Parse event summary using strip-and-extract approach
const parseEventSummary = (summary) => {
  if (!summary) return { hearingType: '', clientName: '', aNumber: null, status: '', court: '', matterId: '' };

  const result = { hearingType: '', clientName: '', aNumber: null, status: '', court: '', matterId: '' };
  let working = summary;

  // Step 1: Extract A# first (required for matching)
  result.aNumber = extractANumber(working);

  // Remove A# and everything after it from working string for cleaner parsing
  working = working
    .replace(/\|A-?Number:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/\|A-?\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/A-Number:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/A#\s*:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/\bA-\d{3}-?\d{3}-?\d{3}\b/gi, '');

  // Step 2: Remove and extract ***...*** wrapper blocks
  const starBlockMatches = working.match(/\*{2,}([^*]+)\*{2,}/g) || [];
  for (const block of starBlockMatches) {
    const content = block.replace(/\*+/g, '').trim().toUpperCase();
    // Check if it's a status keyword
    if (['COV APPROVED', 'RESCHEDULED', 'CANCELLED', 'CONFIRMED', 'POSTPONED'].some(s => content.includes(s))) {
      if (content.includes('RESCHEDULED')) result.status = 'RESCHEDULED';
      else if (content.includes('CANCELLED')) result.status = 'CANCELLED';
      else if (content.includes('CONFIRMED')) result.status = 'CONFIRMED';
      else if (content.includes('POSTPONED')) result.status = 'POSTPONED';
    }
  }
  working = working.replace(/\*{2,}[^*]+\*{2,}/g, ' ').trim();

  // Step 3: Extract status from start of string (if not already found in *** blocks)
  if (!result.status) {
    const statusMatch = working.match(/^(RESCHEDULED|CANCELLED|CONFIRMED|POSTPONED)\s+/i);
    if (statusMatch) {
      result.status = statusMatch[1].toUpperCase();
      working = working.slice(statusMatch[0].length);
    }
  }

  // Step 4: Extract matter ID (in parentheses like "00026-Mendez Alvarado")
  const matterMatch = working.match(/\((\d{4,}-[^)]+)\)/);
  if (matterMatch) {
    result.matterId = matterMatch[1];
    working = working.replace(matterMatch[0], '').trim();
  }

  // Step 5: Try XXX-TYPE-NAME pattern (e.g., ARL-MASTER-NAME or NEW ORLEANS, LA MASTER NAME)
  // Pattern A: CODE-TYPE-NAME (hyphen separated)
  const codeTypeNameMatch = working.match(/^([A-Z]{2,4})-([A-Z]+)-(.+)/i);
  if (codeTypeNameMatch) {
    result.court = codeTypeNameMatch[1].toUpperCase();
    result.hearingType = codeTypeNameMatch[2].toUpperCase();
    result.clientName = codeTypeNameMatch[3].trim().replace(/\s+/g, ' ');
  } else {
    // Pattern B: CITY, STATE TYPE NAME (space separated after city)
    // e.g., "NEW ORLEANS, LA MASTER UTO-LOPEZ, REYNA ELIZABETH"
    const cityTypeMatch = working.match(/^(.+?,\s*[A-Z]{2})\s+(MASTER|MCH|INDIVIDUAL|ICH|BOND|STATUS)\s+(.+)/i);
    if (cityTypeMatch) {
      result.court = cityTypeMatch[1].toUpperCase();
      result.hearingType = cityTypeMatch[2].toUpperCase();
      result.clientName = cityTypeMatch[3].trim().replace(/\s+/g, ' ');
    } else {
      // Pattern C: Just TYPE-NAME (no court prefix)
      const typeNameMatch = working.match(/^(MASTER|MCH|INDIVIDUAL|ICH|BOND|STATUS)[-\s]+(.+)/i);
      if (typeNameMatch) {
        result.hearingType = typeNameMatch[1].toUpperCase();
        result.clientName = typeNameMatch[2].trim().replace(/\s+/g, ' ');
      } else {
        // Fallback: look for hearing type anywhere and extract name before/after
        for (const typeKw of HEARING_TYPE_KEYWORDS) {
          const typeIdx = working.toUpperCase().indexOf(typeKw);
          if (typeIdx >= 0) {
            result.hearingType = typeKw;
            const beforeType = working.slice(0, typeIdx).trim();
            const afterType = working.slice(typeIdx + typeKw.length).trim().replace(/^[-\s]+/, '');

            // Court is usually before the type
            if (beforeType.length > 0 && beforeType.length < 30) {
              result.court = beforeType.toUpperCase();
            }
            // Name is after the type
            if (afterType.length > 0) {
              result.clientName = afterType.replace(/\s+/g, ' ');
            }
            break;
          }
        }
      }
    }
  }

  // Clean up client name (remove trailing pipes, extra spaces, etc.)
  if (result.clientName) {
    result.clientName = result.clientName
      .replace(/\|.*$/, '') // Remove everything after pipe
      .replace(/\s+/g, ' ')
      .trim();
  }

  return result;
};

// Parse event description to extract judge, riders, court address
const parseEventDescription = (desc) => {
  if (!desc) return { judge: '', riders: [], courtAddress: '' };

  const result = { judge: '', riders: [], courtAddress: '' };

  // Extract riders (format: RIDER: NAME|A-Number: ###-###-###)
  const riderMatches = desc.matchAll(/RIDER:\s*([^|]+)\|A-?Number:?\s*([\d-]+)/gi);
  for (const match of riderMatches) {
    result.riders.push({ name: match[1].trim(), aNumber: normalizeANumber(match[2]) });
  }

  // Extract judge - multiple patterns in order of specificity
  // Pattern 1: JUDGE on its own line, name on next line (multiline format)
  const multilineJudgeMatch = desc.match(/JUDGE\s*\n\s*([A-Za-z][^\n]+)/i);
  if (multilineJudgeMatch) {
    result.judge = multilineJudgeMatch[1].trim();
  } else {
    // Pattern 2: JUDGE: Name or JUDGE Name (same line)
    const inlineJudgeMatch = desc.match(/JUDGE[:\s]+([A-Za-z][^\n|]+)/i);
    if (inlineJudgeMatch) {
      // Clean up the judge name (stop at common delimiters)
      let judgeName = inlineJudgeMatch[1].trim();
      // Remove anything after COURT or ADDRESS or other section headers
      judgeName = judgeName.replace(/\s*(COURT|ADDRESS|RIDER|WEBEX|TELEPHONIC).*$/i, '').trim();
      result.judge = judgeName;
    }
  }

  // Extract court address - can span multiple lines after "COURT ADDRESS"
  const addressMatch = desc.match(/COURT\s*ADDRESS[:\s]*\n?([^]*?)(?=\n\s*(?:RIDER|WEBEX|TELEPHONIC|\n\n|$))/i);
  if (addressMatch) {
    // Join multiline address into single line
    result.courtAddress = addressMatch[1]
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0)
      .join(', ')
      .replace(/,\s*,/g, ',')
      .trim();
  } else {
    // Fallback: simpler pattern
    const simpleAddressMatch = desc.match(/COURT\s*ADDRESS[:\s]+([^\n]+)/i);
    if (simpleAddressMatch) {
      result.courtAddress = simpleAddressMatch[1].trim();
    }
  }

  return result;
};

// Parse matter field to extract client reference
const parseMatterField = (matter) => {
  if (!matter) return { matterId: '', lastName: '' };

  // Pattern: "00006-Hernandez"
  const match = matter.match(/(\d+)-(.+)/);
  if (match) {
    return { matterId: match[1], lastName: match[2].trim().toUpperCase() };
  }
  return { matterId: '', lastName: matter.toUpperCase() };
};

// Generate CSV string from data
const generateCSV = (headers, rows) => {
  const escapeField = (field) => {
    const str = String(field || '');
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };

  const headerRow = headers.map(escapeField).join(',');
  const dataRows = rows.map(row => headers.map(h => escapeField(row[h])).join(','));
  return [headerRow, ...dataRows].join('\n');
};

// Airtable select field options for validation
const AIRTABLE_OPTIONS = {
  eventType: ['Hearing', 'Interview', 'ICE Appt', 'Status Conference', 'Bond', 'CFI/RFI', 'Brief Due', 'Calendar Control', 'Test Event'],
  eventSubType: ['Master', 'Individual', 'Pre-Hearing Conf', 'Call Up Date', 'Asylum Interview', 'USCIS Interview', 'Status Docket', 'Appeal Notice Due'],
  eventHearingType: ['Master', 'Individual', 'Bond', 'Status Docket', 'Custody', 'Calendar Control', 'Pending ICH Decision'],
  country: ['Afghanistan', 'Albania', 'Algeria', 'Argentina', 'Bahamas', 'Belize', 'Bolivia', 'Brazil', 'Burma', 'Burundi', 'Cameroon', 'Canada', 'Chile', 'China', 'Colombia', 'Costa Rica', 'Cuba', 'Dominican Republic', 'Ecuador', 'Egypt', 'El Salvador', 'Ethiopia', 'Ghana', 'Guatemala', 'Guinea', 'Haiti', 'Honduras', 'India', 'Iran', 'Iraq', 'Jamaica', 'Jordan', 'Kenya', 'Lebanon', 'Liberia', 'Malaysia', 'Mauritania', 'Mexico', 'Mongolia', 'Morocco', 'Nepal', 'Nicaragua', 'Nigeria', 'Pakistan', 'Panama', 'Peru', 'Philippines', 'Romania', 'Russia', 'Sierra Leone', 'Somalia', 'South Africa', 'South Korea', 'Sudan', 'Syria', 'Taiwan', 'Tanzania', 'Thailand', 'Tunisia', 'Turkiye', 'Turkey', 'Uganda', 'Ukraine', 'United Kingdom', 'United States', 'USA', 'Venezuela', 'Vietnam', 'Yemen'],
};

// Map hearing type from Clio to Airtable
const mapHearingType = (clioType) => {
  const mapping = {
    'MASTER': 'Master',
    'INDIVIDUAL': 'Individual',
    'ICH': 'Individual',
    'MCH': 'Master',
    'BOND': 'Bond',
    'STATUS': 'Status Docket',
  };
  return mapping[clioType?.toUpperCase()] || clioType;
};

// Main App Component
function ClioAirtableMerger() {
  const [files, setFiles] = useState({
    bahr: null,
    contacts: null,
    events: null,
    matterNotes: null,
  });

  const [parsedData, setParsedData] = useState({
    bahr: null,
    contacts: null,
    events: null,
    matterNotes: null,
  });

  const [mergeResult, setMergeResult] = useState(null);
  const [activeTab, setActiveTab] = useState('upload');
  const [validationReport, setValidationReport] = useState([]);

  const handleFileUpload = (type) => (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target.result;
      const parsed = parseCSV(text);

      setFiles(prev => ({ ...prev, [type]: file }));
      setParsedData(prev => ({ ...prev, [type]: parsed }));
    };
    reader.readAsText(file);
  };

  const performMerge = useCallback(() => {
    const reports = [];

    // Step 1: Build lookup from Bahr dataset (authority for A#)
    const bahrLookup = new Map(); // name -> record
    const aNumberLookup = new Map(); // A# -> record

    if (parsedData.bahr?.rows) {
      parsedData.bahr.rows.forEach((row, idx) => {
        const lastName = row['Last Name'] || '';
        const firstName = row['First Name'] || '';
        const middleName = row['Middle Name'] || '';
        const aNumber = normalizeANumber(row['A number'] || '');

        const nameKey = normalizeName(lastName, firstName);

        const record = {
          _source: 'bahr',
          _idx: idx,
          lastName,
          firstName,
          middleName,
          aNumber,
          phone: row['Telphone Number'] || '',
          email: row['Email'] || '',
          addressLine1: row['Street Number and Name'] || '',
          addressLine2: [row['Address line 2'], row['AptSte'], row['FlrNumber']].filter(Boolean).join(' '),
          state: row['State'] || '',
          city: row['City'] || '',
          zip: row['zipcode'] || '',
          country: row['18.a. Country of Citizenship or Nationality'] || '',
          entryDate: row['22. Date of Last Arrival into United States'] || '',
          placeOfEntry: row['23. Place of Last Arrival to US'] || '',
          dob: row['DOB'] || '',
        };

        bahrLookup.set(nameKey, record);
        if (aNumber) {
          aNumberLookup.set(aNumber, record);
        }
      });
    }

    reports.push({ type: 'info', message: `Loaded ${bahrLookup.size} clients from Bahr dataset` });

    // Step 2: Enrich with Clio Contacts (match by name)
    let contactMatches = 0;
    let contactMisses = 0;

    if (parsedData.contacts?.rows) {
      parsedData.contacts.rows.forEach((row) => {
        const lastName = row['Last Name'] || '';
        const firstName = row['First Name'] || '';
        const nameKey = normalizeName(lastName, firstName);

        if (bahrLookup.has(nameKey)) {
          const record = bahrLookup.get(nameKey);
          // Enrich with Clio contact data (prefer Clio if Bahr is empty)
          if (!record.phone && row['Mobile Phone']) record.phone = row['Mobile Phone'];
          if (!record.phone && row['Primary Phone']) record.phone = row['Primary Phone'];
          if (!record.email && row['E-mail Address']) record.email = row['E-mail Address'];
          record._clioContactId = row['UniqueId'] || '';
          contactMatches++;
        } else {
          contactMisses++;
          reports.push({ type: 'warning', message: `Clio contact not in Bahr: ${firstName} ${lastName}` });
        }
      });
    }

    reports.push({ type: 'info', message: `Matched ${contactMatches} Clio contacts, ${contactMisses} unmatched` });

    // Step 3: Parse Events
    const eventsOutput = [];
    let eventMatches = 0;
    let eventSkipped = 0;
    let eventsWithoutDateTime = 0;

    if (parsedData.events?.rows) {
      parsedData.events.rows.forEach((row) => {
        const summary = row['summary'] || '';
        const description = row['description'] || '';
        const startDateTime = row['start.dateTime'] || '';
        const location = row['location'] || '';

        const summaryParsed = parseEventSummary(summary);
        const descParsed = parseEventDescription(description);

        // CRITICAL: Skip events without A# (cannot be linked to clients)
        const eventANumber = summaryParsed.aNumber;
        if (!eventANumber) {
          eventSkipped++;
          reports.push({ type: 'warning', message: `Event SKIPPED (no A#): ${summary.slice(0, 60)}...` });
          return; // Skip this row entirely
        }

        // Validate datetime exists
        if (!startDateTime) {
          eventsWithoutDateTime++;
          reports.push({ type: 'warning', message: `Event missing datetime: ${summary.slice(0, 60)}...` });
        }

        // Try to match client by A# in Bahr dataset
        let matchedClient = null;
        if (aNumberLookup.has(eventANumber)) {
          matchedClient = aNumberLookup.get(eventANumber);
          eventMatches++;
        } else {
          // A# found in summary but not in Bahr dataset - still output for linking
          reports.push({ type: 'info', message: `Event A# ${eventANumber} not in Bahr dataset (will import as new client)` });
        }

        // Check for conference data (Webex/Telephonic)
        const hasWebex = (row['conferenceData.conferenceSolution.name'] || '').toLowerCase().includes('webex') ||
                        (row['conferenceData.entryPoints.0.uri'] || '').includes('webex');
        const hasTelephonic = (row['conferenceData.entryPoints.1.entryPointType'] || '') === 'phone';

        // Use location field for court, fallback to parsed court code
        const court = location || descParsed.courtAddress || summaryParsed.court;

        eventsOutput.push({
          'A#': matchedClient?.aNumber || summaryParsed.aNumber || '',
          'Hearing Date/Time': startDateTime,
          'Event Type': 'Hearing',
          'Event Hearing Type': mapHearingType(summaryParsed.hearingType),
          'Court': court,
          'Judge': descParsed.judge,
          'Webex': hasWebex ? 'TRUE' : 'FALSE',
          'Telephonic': hasTelephonic ? 'TRUE' : 'FALSE',
          'A#': eventANumber,
          '_client_name': matchedClient ? `${matchedClient.lastName}, ${matchedClient.firstName}` : summaryParsed.clientName,
          '_status': summaryParsed.status,
          '_matter_id': summaryParsed.matterId,
          '_riders': descParsed.riders.map(r => `${r.name}|${r.aNumber}`).join('; '),
        });
      });
    }

    reports.push({
      type: 'info',
      message: `Events: ${eventsOutput.length} output, ${eventMatches} matched to Bahr, ${eventSkipped} skipped (no A#), ${eventsWithoutDateTime} missing datetime`
    });

    // Step 4: Parse Matter Notes - Aggregate by client
    const notesByClient = new Map(); // A# -> array of notes
    let noteMatches = 0;
    let noteMisses = 0;

    if (parsedData.matterNotes?.rows) {
      parsedData.matterNotes.rows.forEach((row) => {
        const matter = row['Matter'] || '';
        const subject = row['Subject'] || '';
        const detail = row['Detail'] || '';
        const date = row['Date'] || row['CreatedAt'] || '';
        const creator = row['Creator'] || '';
        const matterId = row['MatterId'] || '';

        const matterParsed = parseMatterField(matter);

        // Try to match by last name (partial match)
        let matchedClient = null;
        for (const [nameKey, record] of bahrLookup) {
          if (nameKey.startsWith(matterParsed.lastName + '|') ||
              nameKey.includes(matterParsed.lastName)) {
            matchedClient = record;
            break;
          }
        }

        if (!matchedClient) {
          noteMisses++;
          reports.push({ type: 'warning', message: `Matter note not matched: ${matter}` });
          return; // Skip unmatched notes
        }

        noteMatches++;
        const clientKey = matchedClient.aNumber || `NAME:${matchedClient.lastName}|${matchedClient.firstName}`;

        if (!notesByClient.has(clientKey)) {
          notesByClient.set(clientKey, {
            client: matchedClient,
            matterId: matterId,
            matter: matter,
            notes: []
          });
        }

        notesByClient.get(clientKey).notes.push({
          date: date,
          subject: subject,
          creator: creator,
          detail: detail,
        });
      });
    }

    // Format aggregated notes for each client (newest first)
    const caseMasterOutput = [];

    notesByClient.forEach((clientData, clientKey) => {
      // Sort notes by date descending (newest first)
      const sortedNotes = clientData.notes.sort((a, b) => {
        const dateA = new Date(a.date || 0);
        const dateB = new Date(b.date || 0);
        return dateB - dateA; // Descending
      });

      // Format notes into a single text block
      const formattedNotes = sortedNotes.map((note, idx) => {
        const datePart = note.date ? `[${note.date}]` : '[No Date]';
        const subjectPart = note.subject ? ` - ${note.subject}` : '';
        const creatorPart = note.creator ? `\nBy: ${note.creator}` : '';
        const separator = '─'.repeat(50);

        return `${'═'.repeat(55)}
${datePart}${subjectPart}${creatorPart}
${separator}
${note.detail || '(No content)'}`;
      }).join('\n\n');

      caseMasterOutput.push({
        'A#': clientData.client.aNumber || '',
        'Case Notes': formattedNotes,
        'PP ID': clientData.matterId,
        '_client_name': `${clientData.client.lastName}, ${clientData.client.firstName}`,
        '_matter': clientData.matter,
        '_note_count': sortedNotes.length,
      });
    });

    reports.push({ type: 'info', message: `Aggregated ${noteMatches} notes into ${caseMasterOutput.length} case records, ${noteMisses} notes unmatched` });

    // Step 5: Build Client Info output
    const clientsOutput = [];
    bahrLookup.forEach((record) => {
      // Validate country against allowed options
      let country = record.country;
      if (country && !AIRTABLE_OPTIONS.country.some(c => c.toLowerCase() === country.toLowerCase())) {
        reports.push({ type: 'warning', message: `Unknown country: ${country} for ${record.firstName} ${record.lastName}` });
      }

      clientsOutput.push({
        'First Name': record.firstName,
        'Middle Name': record.middleName,
        'Family Name': record.lastName,
        'A#': record.aNumber,
        'Phone Number': record.phone,
        'Client Email': record.email,
        'Address Line 1': record.addressLine1,
        'Address Line 2': record.addressLine2,
        'City': record.city,
        'Zip (5)': record.zip,
        'Country': country,
        'Entry Date': record.entryDate,
        'Place of Entry': record.placeOfEntry,
        'DOB': record.dob,
        '_import_key': normalizeName(record.lastName, record.firstName),
      });
    });

    // Generate linking script
    const linkingScript = `
// Airtable Scripting Extension - Link Records by A#
// Run this AFTER importing all three CSVs

const clientsTable = base.getTable('Client Info');
const eventsTable = base.getTable('Events');
const caseMasterTable = base.getTable('Case Master View // Activities');

// Build A# -> Record ID lookup from Client Info
const clientRecords = await clientsTable.selectRecordsAsync({ fields: ['A#'] });
const aNumToRecordId = new Map();

for (const record of clientRecords.records) {
  const aNum = record.getCellValueAsString('A#');
  if (aNum) {
    aNumToRecordId.set(aNum, record.id);
  }
}

console.log(\`Loaded \${aNumToRecordId.size} clients with A#\`);

// Link Events to Clients
const eventRecords = await eventsTable.selectRecordsAsync({ fields: ['A#', 'Client'] });
let linkedEvents = 0;
let failedEvents = 0;

for (const record of eventRecords.records) {
  const aNum = record.getCellValueAsString('A#');
  const existingClient = record.getCellValue('Client');

  if (aNum && !existingClient && aNumToRecordId.has(aNum)) {
    await eventsTable.updateRecordAsync(record.id, {
      'Client': [{ id: aNumToRecordId.get(aNum) }]
    });
    linkedEvents++;
  } else if (aNum && !aNumToRecordId.has(aNum)) {
    failedEvents++;
    console.log(\`No client found for A#: \${aNum}\`);
  }
}

console.log(\`Linked \${linkedEvents} events, \${failedEvents} failed\`);

// Link Case Master View to Clients
const caseRecords = await caseMasterTable.selectRecordsAsync({ fields: ['A#', 'Contact'] });
let linkedCases = 0;
let failedCases = 0;

for (const record of caseRecords.records) {
  const aNum = record.getCellValueAsString('A#');
  const existingContact = record.getCellValue('Contact');

  if (aNum && !existingContact && aNumToRecordId.has(aNum)) {
    await caseMasterTable.updateRecordAsync(record.id, {
      'Contact': [{ id: aNumToRecordId.get(aNum) }]
    });
    linkedCases++;
  } else if (aNum && !aNumToRecordId.has(aNum)) {
    failedCases++;
    console.log(\`No client found for A#: \${aNum}\`);
  }
}

console.log(\`Linked \${linkedCases} case records, \${failedCases} failed\`);
console.log('Done! The A# column serves as the universal UID across all tables.');
`;

    setMergeResult({
      clients: clientsOutput,
      events: eventsOutput,
      caseMaster: caseMasterOutput,
      linkingScript,
    });

    setValidationReport(reports);
    setActiveTab('results');
  }, [parsedData]);

  const downloadCSV = (data, filename, headers) => {
    const csv = generateCSV(headers, data);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  const downloadScript = () => {
    const blob = new Blob([mergeResult.linkingScript], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'airtable_link_records.js';
    a.click();
    URL.revokeObjectURL(url);
  };

  const canMerge = parsedData.bahr?.rows?.length > 0;

  return (
    <div style={{
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      color: '#e4e4e7',
      padding: '2rem',
    }}>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');

        * { box-sizing: border-box; }

        .card {
          background: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 12px;
          padding: 1.5rem;
          backdrop-filter: blur(10px);
        }

        .upload-zone {
          border: 2px dashed rgba(99, 102, 241, 0.4);
          border-radius: 8px;
          padding: 2rem;
          text-align: center;
          cursor: pointer;
          transition: all 0.2s;
        }

        .upload-zone:hover {
          border-color: rgba(99, 102, 241, 0.8);
          background: rgba(99, 102, 241, 0.05);
        }

        .upload-zone.has-file {
          border-color: #22c55e;
          background: rgba(34, 197, 94, 0.1);
        }

        .btn {
          padding: 0.75rem 1.5rem;
          border-radius: 8px;
          font-weight: 600;
          font-size: 0.875rem;
          cursor: pointer;
          transition: all 0.2s;
          border: none;
          font-family: inherit;
        }

        .btn-primary {
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
          color: white;
        }

        .btn-primary:hover:not(:disabled) {
          transform: translateY(-2px);
          box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
        }

        .btn-primary:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        .btn-secondary {
          background: rgba(255, 255, 255, 0.1);
          color: #e4e4e7;
          border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
          background: rgba(255, 255, 255, 0.15);
        }

        .tab {
          padding: 0.5rem 1rem;
          cursor: pointer;
          border-bottom: 2px solid transparent;
          transition: all 0.2s;
          color: #a1a1aa;
        }

        .tab:hover { color: #e4e4e7; }

        .tab.active {
          color: #6366f1;
          border-bottom-color: #6366f1;
        }

        .badge {
          display: inline-block;
          padding: 0.25rem 0.5rem;
          border-radius: 4px;
          font-size: 0.75rem;
          font-weight: 600;
        }

        .badge-info { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .badge-warning { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .badge-error { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .badge-success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        .table-container {
          overflow-x: auto;
          margin-top: 1rem;
        }

        table {
          width: 100%;
          border-collapse: collapse;
          font-size: 0.8rem;
        }

        th, td {
          padding: 0.5rem;
          text-align: left;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        th {
          background: rgba(99, 102, 241, 0.1);
          font-weight: 600;
          color: #a5b4fc;
        }

        td { color: #d4d4d8; }

        pre {
          background: #0d1117;
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 8px;
          padding: 1rem;
          overflow-x: auto;
          font-size: 0.75rem;
          color: #7ee787;
        }
      `}</style>

      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <header style={{ marginBottom: '2rem', textAlign: 'center' }}>
          <h1 style={{
            fontSize: '2rem',
            fontWeight: '700',
            background: 'linear-gradient(135deg, #6366f1 0%, #a855f7 50%, #ec4899 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            marginBottom: '0.5rem',
          }}>
            Clio → Airtable Merger
          </h1>
          <p style={{ color: '#71717a', fontSize: '0.875rem' }}>
            Transform Clio exports into Airtable-ready CSVs with linked records
          </p>
        </header>

        {/* Tabs */}
        <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
          <div className={`tab ${activeTab === 'upload' ? 'active' : ''}`} onClick={() => setActiveTab('upload')}>
            Upload Files
          </div>
          <div className={`tab ${activeTab === 'preview' ? 'active' : ''}`} onClick={() => setActiveTab('preview')}>
            Preview Data
          </div>
          <div className={`tab ${activeTab === 'results' ? 'active' : ''}`} onClick={() => setActiveTab('results')}>
            Results & Export
          </div>
        </div>

        {/* Upload Tab */}
        {activeTab === 'upload' && (
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem' }}>
            {[
              { key: 'bahr', label: 'Bahr Dataset (Authority)', desc: 'Contains A#s and client info', required: true },
              { key: 'contacts', label: 'Clio Contacts Export', desc: 'Additional contact details', required: false },
              { key: 'events', label: 'Clio Events Export', desc: 'Hearings from Google Calendar', required: false },
              { key: 'matterNotes', label: 'Clio Matter Notes', desc: 'Case notes and details', required: false },
            ].map(({ key, label, desc, required }) => (
              <div key={key} className="card">
                <h3 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                  {label}
                  {required && <span className="badge badge-warning">Required</span>}
                </h3>
                <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '1rem' }}>{desc}</p>

                <label className={`upload-zone ${files[key] ? 'has-file' : ''}`}>
                  <input
                    type="file"
                    accept=".csv"
                    onChange={handleFileUpload(key)}
                    style={{ display: 'none' }}
                  />
                  {files[key] ? (
                    <div>
                      <span style={{ color: '#22c55e' }}>✓</span> {files[key].name}
                      <div style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.25rem' }}>
                        {parsedData[key]?.rows?.length || 0} rows
                      </div>
                    </div>
                  ) : (
                    <div style={{ color: '#71717a' }}>
                      Drop CSV or click to upload
                    </div>
                  )}
                </label>
              </div>
            ))}

            <div style={{ gridColumn: '1 / -1', textAlign: 'center', marginTop: '1rem' }}>
              <button
                className="btn btn-primary"
                onClick={performMerge}
                disabled={!canMerge}
              >
                {canMerge ? 'Merge & Transform →' : 'Upload Bahr Dataset to Continue'}
              </button>
            </div>
          </div>
        )}

        {/* Preview Tab */}
        {activeTab === 'preview' && (
          <div className="card">
            <h3 style={{ marginBottom: '1rem' }}>Parsed Data Preview</h3>

            {Object.entries(parsedData).map(([key, data]) => (
              data?.rows?.length > 0 && (
                <div key={key} style={{ marginBottom: '2rem' }}>
                  <h4 style={{ fontSize: '0.875rem', color: '#a5b4fc', marginBottom: '0.5rem' }}>
                    {key} ({data.rows.length} rows)
                  </h4>
                  <div className="table-container">
                    <table>
                      <thead>
                        <tr>
                          {data.headers.slice(0, 8).map((h, i) => (
                            <th key={i}>{h}</th>
                          ))}
                          {data.headers.length > 8 && <th>...</th>}
                        </tr>
                      </thead>
                      <tbody>
                        {data.rows.slice(0, 5).map((row, i) => (
                          <tr key={i}>
                            {data.headers.slice(0, 8).map((h, j) => (
                              <td key={j}>{String(row[h] || '').slice(0, 30)}</td>
                            ))}
                            {data.headers.length > 8 && <td>...</td>}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            ))}

            {!Object.values(parsedData).some(d => d?.rows?.length > 0) && (
              <p style={{ color: '#71717a', textAlign: 'center' }}>No data uploaded yet</p>
            )}
          </div>
        )}

        {/* Results Tab */}
        {activeTab === 'results' && mergeResult && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
            {/* Validation Report */}
            <div className="card">
              <h3 style={{ marginBottom: '1rem' }}>Validation Report</h3>
              <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
                {validationReport.map((item, i) => (
                  <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.5rem', fontSize: '0.8rem' }}>
                    <span className={`badge badge-${item.type}`}>{item.type}</span>
                    <span>{item.message}</span>
                  </div>
                ))}
              </div>
            </div>

            {/* Download Buttons */}
            <div className="card">
              <h3 style={{ marginBottom: '1rem' }}>Download Outputs</h3>
              <p style={{ fontSize: '0.8rem', color: '#71717a', marginBottom: '1rem' }}>
                Import in order: 1) Clients → 2) Events → 3) Case Master → 4) Run Linking Script
              </p>

              <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
                <button
                  className="btn btn-secondary"
                  onClick={() => downloadCSV(
                    mergeResult.clients,
                    'clients_for_airtable.csv',
                    ['A#', 'First Name', 'Middle Name', 'Family Name', 'Phone Number', 'Client Email', 'Address Line 1', 'Address Line 2', 'City', 'Zip (5)', 'Country', 'Entry Date', 'Place of Entry', 'DOB', '_import_key']
                  )}
                >
                  1. Clients CSV ({mergeResult.clients.length})
                </button>

                <button
                  className="btn btn-secondary"
                  onClick={() => downloadCSV(
                    mergeResult.events,
                    'events_for_airtable.csv',
                    ['A#', 'Hearing Date/Time', 'Event Type', 'Event Hearing Type', 'Court', 'Judge', 'Webex', 'Telephonic', '_client_name', '_status', '_matter_id', '_riders']
                  )}
                >
                  2. Events CSV ({mergeResult.events.length})
                </button>

                <button
                  className="btn btn-secondary"
                  onClick={() => downloadCSV(
                    mergeResult.caseMaster,
                    'case_master_for_airtable.csv',
                    ['A#', 'Case Notes', 'PP ID', '_client_name', '_matter', '_note_count']
                  )}
                >
                  3. Case Master CSV ({mergeResult.caseMaster.length} clients)
                </button>

                <button
                  className="btn btn-primary"
                  onClick={downloadScript}
                >
                  4. Linking Script (.js)
                </button>
              </div>
            </div>

            {/* Preview Tables */}
            <div className="card">
              <h3 style={{ marginBottom: '1rem' }}>Clients Preview</h3>
              <div className="table-container">
                <table>
                  <thead>
                    <tr>
                      <th>A#</th>
                      <th>Name</th>
                      <th>Phone</th>
                      <th>Email</th>
                      <th>City</th>
                    </tr>
                  </thead>
                  <tbody>
                    {mergeResult.clients.slice(0, 5).map((row, i) => (
                      <tr key={i}>
                        <td>{row['A#']}</td>
                        <td>{row['First Name']} {row['Family Name']}</td>
                        <td>{row['Phone Number']}</td>
                        <td>{row['Client Email']}</td>
                        <td>{row['City']}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>

            <div className="card">
              <h3 style={{ marginBottom: '1rem' }}>Events Preview</h3>
              <div className="table-container">
                <table>
                  <thead>
                    <tr>
                      <th>A#</th>
                      <th>Date/Time</th>
                      <th>Type</th>
                      <th>Court</th>
                      <th>Judge</th>
                    </tr>
                  </thead>
                  <tbody>
                    {mergeResult.events.slice(0, 5).map((row, i) => (
                      <tr key={i}>
                        <td>{row['A#']}</td>
                        <td>{row['Hearing Date/Time']}</td>
                        <td>{row['Event Hearing Type']}</td>
                        <td>{String(row['Court']).slice(0, 30)}</td>
                        <td>{row['Judge']}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Case Master Preview */}
            <div className="card">
              <h3 style={{ marginBottom: '1rem' }}>Case Master Preview (1 record per client)</h3>
              <div className="table-container">
                <table>
                  <thead>
                    <tr>
                      <th>A#</th>
                      <th>Client</th>
                      <th>Notes</th>
                      <th>Case Notes Preview</th>
                    </tr>
                  </thead>
                  <tbody>
                    {mergeResult.caseMaster.slice(0, 5).map((row, i) => (
                      <tr key={i}>
                        <td>{row['A#']}</td>
                        <td>{row['_client_name']}</td>
                        <td>{row['_note_count']}</td>
                        <td style={{ maxWidth: '400px', whiteSpace: 'pre-wrap', fontSize: '0.7rem', fontFamily: 'monospace' }}>
                          {String(row['Case Notes']).slice(0, 300)}...
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Linking Script Preview */}
            <div className="card">
              <h3 style={{ marginBottom: '1rem' }}>Linking Script Preview</h3>
              <p style={{ fontSize: '0.8rem', color: '#71717a', marginBottom: '1rem' }}>
                Run this in Airtable's Scripting Extension after importing all CSVs
              </p>
              <pre>{mergeResult.linkingScript}</pre>
            </div>
          </div>
        )}

        {activeTab === 'results' && !mergeResult && (
          <div className="card" style={{ textAlign: 'center', padding: '3rem' }}>
            <p style={{ color: '#71717a' }}>Run the merge to see results</p>
          </div>
        )}
      </div>
    </div>
  );
}

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<ClioAirtableMerger />);
  </script>
</body>
</html>
