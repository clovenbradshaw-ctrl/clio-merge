<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clio → Airtable Merger</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback } = React;

// Constants
const ANDREW_BAHR_RECORD_ID = 'recRaQ8cur6na6kIw';

// API Configuration
const XANO_CASE_NOTES_ENDPOINT = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:l_gEBOGc/case_notes';

// Relevant Airtable tables for schema inspection
const AIRTABLE_TABLES = {
  'Client Info': ['Client ID', 'A#', 'First Name', 'Middle Name', 'Family Name', 'Phone Number', 'Client Email', 'Address Line 1', 'Address Line 2', 'City', 'State', 'Zip (5)', 'Country', 'Entry Date', 'Place of Entry', 'DOB', 'clio_contact_id', 'ICH Atty', 'Bahr Client', 'uscis_flatpack_data'],
  'Case Master View': ['Client', 'clio_matter_id', 'PP ID', 'Description', 'File Case Status', 'Case Notes', 'Bahr Client'],
  'Events': ['Case Master', 'A#', 'Hearing Date/Time', 'Event Type', 'Event Hearing Type', 'Court', 'Judge', 'MCH Attny', 'Bahr Client'],
  'Relationships': ['Case Master View', 'Object Client', 'Relationship', 'Bahr Client'],
};

// Xano Case Notes schema
const XANO_CASE_NOTES_SCHEMA = {
  id: 'integer',
  Activity: 'text',
  Type: 'enum',
  Date: 'timestamp',
  Description: 'text',
  Contact: 'text',
  Client_PP_ID: 'text',
  Matter: 'text',
  RecordId: 'text',
  Created_By: 'text',
  Softr_Link_to_clients: 'text',
  Updated: 'text',
  Modified: 'text',
  Due_Date: 'timestamp',
  Last_Update_By: 'text',
  unix_timestamp: 'text',
  time_raw: 'text',
  tags: ['text'],
  pp_note_id: 'text',
  matter: 'text',
  matter_id: 'text',
  source: 'text',
  client_airtable_id: 'text',
  eventId: 'text',
};

// State-machine CSV Parser - handles multiline quoted fields correctly
const parseCSV = (text) => {
  if (!text || !text.trim()) return { headers: [], rows: [] };

  const rows = [];
  let currentRow = [];
  let currentField = '';
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const nextChar = text[i + 1];

    if (inQuotes) {
      if (char === '"' && nextChar === '"') {
        currentField += '"';
        i++;
      } else if (char === '"') {
        inQuotes = false;
      } else {
        currentField += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === ',') {
        currentRow.push(currentField.trim());
        currentField = '';
      } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
        currentRow.push(currentField.trim());
        currentField = '';
        if (currentRow.some(f => f !== '')) {
          rows.push([...currentRow]);
        }
        currentRow = [];
        if (char === '\r' && nextChar === '\n') {
          i++;
        }
      } else if (char === '\r') {
        currentRow.push(currentField.trim());
        currentField = '';
        if (currentRow.some(f => f !== '')) {
          rows.push([...currentRow]);
        }
        currentRow = [];
      } else {
        currentField += char;
      }
    }
  }

  if (currentField !== '' || currentRow.length > 0) {
    currentRow.push(currentField.trim());
    if (currentRow.some(f => f !== '')) {
      rows.push(currentRow);
    }
  }

  if (rows.length === 0) return { headers: [], rows: [] };

  const headers = rows[0];
  const dataRows = rows.slice(1).map(row => {
    const obj = {};
    headers.forEach((h, i) => obj[h] = row[i] || '');
    return obj;
  });

  return { headers, rows: dataRows };
};

// Normalize A# to ###-###-### format
const normalizeANumber = (aNum) => {
  if (!aNum || !aNum.trim()) {
    return { normalized: '', isValid: false, original: aNum, issue: 'empty' };
  }

  const digits = aNum.replace(/[^0-9]/g, '');

  if (digits.length === 9) {
    return {
      normalized: `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`,
      isValid: true,
      original: aNum,
      issue: null
    };
  }

  if (digits.length === 10 && digits[0] === '1') {
    return {
      normalized: `${digits.slice(1, 4)}-${digits.slice(4, 7)}-${digits.slice(7, 10)}`,
      isValid: true,
      original: aNum,
      issue: null
    };
  }

  return {
    normalized: digits,
    isValid: false,
    original: aNum,
    issue: `wrong-length-${digits.length}`
  };
};

// Generate fallback ID for clients without valid A#
const generateFallbackId = (lastName, firstName, dob) => {
  const cleanLast = (lastName || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 10);
  const cleanFirst = (firstName || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 10);
  const cleanDob = (dob || '').replace(/[^0-9]/g, '').slice(0, 8);

  if (!cleanLast && !cleanFirst) return null;

  return `PENDING-${cleanLast}-${cleanFirst}${cleanDob ? '-' + cleanDob : ''}`;
};

// Normalize name for matching
const normalizeName = (lastName, firstName) => {
  const clean = (s) => {
    if (!s) return '';
    // Normalize diacritics first (é→e, ñ→n, etc), then uppercase and remove non-alphabetic
    return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase().trim().replace(/[^A-Z\s]/g, '').replace(/\s+/g, ' ');
  };
  return `${clean(lastName)}|${clean(firstName)}`;
};

// Normalize date to YYYY-MM-DD format for Airtable
const normalizeDate = (value) => {
  if (!value) return '';
  const trimmed = value.trim();
  if (!trimmed) return '';

  // Already in ISO format (YYYY-MM-DD)
  if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
    return trimmed;
  }

  // Try MM/DD/YYYY format (common in Clio exports)
  const slashParts = trimmed.split('/');
  if (slashParts.length === 3) {
    const [m, d, y] = slashParts;
    const month = m.padStart(2, '0');
    const day = d.padStart(2, '0');
    // Handle 2-digit years
    let year = y;
    if (y.length === 2) {
      year = parseInt(y) > 50 ? '19' + y : '20' + y;
    }
    if (month >= '01' && month <= '12' && day >= '01' && day <= '31') {
      return `${year}-${month}-${day}`;
    }
  }

  // Try MM-DD-YYYY format
  const dashParts = trimmed.split('-');
  if (dashParts.length === 3 && dashParts[0].length <= 2) {
    const [m, d, y] = dashParts;
    const month = m.padStart(2, '0');
    const day = d.padStart(2, '0');
    let year = y;
    if (y.length === 2) {
      year = parseInt(y) > 50 ? '19' + y : '20' + y;
    }
    if (month >= '01' && month <= '12' && day >= '01' && day <= '31') {
      return `${year}-${month}-${day}`;
    }
  }

  // Try to parse with Date constructor as fallback
  const date = new Date(trimmed);
  if (!isNaN(date.getTime())) {
    return date.toISOString().split('T')[0];
  }

  // Return original if we can't parse
  return trimmed;
};

// Extract A# from text
const extractANumber = (text) => {
  if (!text) return null;

  const patterns = [
    /\|A-?(\d{3})-?(\d{3})-?(\d{3})/i,
    /A-Number:?\s*(\d{3})-?(\d{3})-?(\d{3})/i,
    /A#\s*:?\s*(\d{3})-?(\d{3})-?(\d{3})/i,
    /\bA-(\d{3})-?(\d{3})-?(\d{3})\b/i,
    /\b(\d{3})-?(\d{3})-?(\d{3})\b/,
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      const digits = match.slice(1).join('').replace(/\D/g, '');
      if (digits.length === 9) {
        return `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`;
      }
    }
  }
  return null;
};

// Parse event summary
const parseEventSummary = (summary) => {
  if (!summary) return { hearingType: '', clientName: '', aNumber: null, status: '', court: '', matterId: '' };

  const result = { hearingType: '', clientName: '', aNumber: null, status: '', court: '', matterId: '' };
  let working = summary;

  result.aNumber = extractANumber(working);

  working = working
    .replace(/\|A-?Number:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/\|A-?\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/A-Number:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/A#\s*:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/\bA-\d{3}-?\d{3}-?\d{3}\b/gi, '');

  // Extract matter ID (in parentheses like "00026-Mendez Alvarado")
  const matterMatch = working.match(/\((\d{4,}-[^)]+)\)/);
  if (matterMatch) {
    result.matterId = matterMatch[1];
    working = working.replace(matterMatch[0], '').trim();
  }

  // Extract hearing type
  const HEARING_TYPES = ['MASTER', 'MCH', 'INDIVIDUAL', 'ICH', 'BOND', 'STATUS', 'CUSTODY', 'CALENDAR'];
  for (const typeKw of HEARING_TYPES) {
    if (working.toUpperCase().includes(typeKw)) {
      result.hearingType = typeKw;
      break;
    }
  }

  return result;
};

// Parse event description
const parseEventDescription = (desc) => {
  if (!desc) return { judge: '', courtAddress: '' };

  const result = { judge: '', courtAddress: '' };

  const judgeMatch = desc.match(/JUDGE[:\s]+([A-Za-z][^\n|]+)/i);
  if (judgeMatch) {
    result.judge = judgeMatch[1].trim().replace(/\s*(COURT|ADDRESS|RIDER).*$/i, '').trim();
  }

  const addressMatch = desc.match(/COURT\s*ADDRESS[:\s]+([^\n]+)/i);
  if (addressMatch) {
    result.courtAddress = addressMatch[1].trim();
  }

  return result;
};

// Map hearing type from Clio to Airtable
const mapHearingType = (clioType) => {
  const mapping = {
    'MASTER': 'Master',
    'INDIVIDUAL': 'Individual',
    'ICH': 'Individual',
    'MCH': 'Master',
    'BOND': 'Bond',
    'STATUS': 'Status Docket',
  };
  return mapping[clioType?.toUpperCase()] || clioType;
};

// Generate CSV string from data
const generateCSV = (headers, rows) => {
  const escapeField = (field) => {
    const str = String(field ?? '');
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };

  const headerRow = headers.map(escapeField).join(',');
  const dataRows = rows.map(row => headers.map(h => escapeField(row[h])).join(','));
  return [headerRow, ...dataRows].join('\n');
};

// ============================================
// BAHR EXCEL PARSER - Extract clients from multi-tab Excel
// ============================================

// Column name variations for client identification (will be matched case-insensitively)
const CLIENT_NAME_PATTERNS = [
  'client', 'client name', 'name', 'full name', 'fullname', 'client full name',
  'full_name', // DocketWise format
  // Spanish variations (including common typos)
  'nombre del cliente', 'nombre del ciente', 'nombre', 'cliente',
  'nombre completo', 'nombre del client', 'nom del cliente',
  'beneficiario', 'solicitante', 'applicant',
];
const A_NUMBER_PATTERNS = [
  'a number', 'a- number', 'a#', 'a-number', 'alien number', 'a #',
  'anumber', 'a num', 'a-num', 'a no', 'a-no', 'alien #', 'alien no',
  'alien_registration_number', // DocketWise format
  // Spanish
  'numero a', 'número a', 'numero alien', 'número alien', 'num a',
  'numero de alien', 'número de alien', 'num. a', 'no. a',
];
const MATTER_PATTERNS = [
  'matter', 'case matter', 'matter number', 'matter no', 'case no', 'case number',
  'case', 'file', 'file number', 'file no',
  // Spanish
  'caso', 'número de caso', 'numero de caso', 'materia', 'asunto',
  'expediente', 'num caso', 'no. caso',
];

// Generic column names to skip when looking for real headers
const GENERIC_COLUMN_PATTERNS = /^(column\s*\d+|col\s*\d+|field\s*\d+|__empty|__rownum)$/i;

// Extract client name from a Matter field like "01453-Castillo Garcia"
const extractClientFromMatter = (matter) => {
  if (!matter) return null;
  const match = matter.match(/^\d+-(.+)$/);
  return match ? match[1].trim() : null;
};

// Normalize client name for matching (handles "Last First" and "First Last" and "Last, First")
const normalizeClientName = (name) => {
  if (!name) return null;
  // Remove extra spaces, convert to uppercase
  let cleaned = name.toUpperCase().trim().replace(/\s+/g, ' ');
  // Handle "Last, First" format
  if (cleaned.includes(',')) {
    const parts = cleaned.split(',').map(p => p.trim());
    cleaned = parts.join(' ');
  }
  // Remove accents/diacritics for matching
  cleaned = cleaned.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  return cleaned;
};

// Normalize column name for comparison
const normalizeColumnName = (col) => {
  if (!col) return '';
  return String(col).toLowerCase().trim().replace(/\s+/g, ' ').normalize('NFD').replace(/[\u0300-\u036f]/g, '');
};

// Check if a column name matches any of the patterns
const columnMatches = (colName, patterns) => {
  const normalized = normalizeColumnName(colName);
  return patterns.some(pattern => normalized === pattern || normalized.includes(pattern));
};

// Extract A# from various formats
const extractANumberFromCell = (value) => {
  if (!value) return null;
  const str = String(value).trim();
  // Remove any non-digit characters except dash
  const digits = str.replace(/[^0-9]/g, '');
  if (digits.length === 9) {
    return `${digits.slice(0,3)}-${digits.slice(3,6)}-${digits.slice(6,9)}`;
  }
  // Handle 10 digit with leading 1
  if (digits.length === 10 && digits[0] === '1') {
    return `${digits.slice(1,4)}-${digits.slice(4,7)}-${digits.slice(7,10)}`;
  }
  return null;
};

// Find a column value trying multiple possible column name patterns (case-insensitive)
const findColumnValue = (row, patterns) => {
  for (const [colName, value] of Object.entries(row)) {
    if (columnMatches(colName, patterns)) {
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        return String(value).trim();
      }
    }
  }
  return null;
};

// Check if row has generic column headers (Column 1, Column 2, etc.)
const hasGenericHeaders = (headers) => {
  if (!headers || headers.length === 0) return false;
  const genericCount = headers.filter(h => GENERIC_COLUMN_PATTERNS.test(String(h))).length;
  return genericCount >= headers.length * 0.5; // More than half are generic
};

// Check if headers contain any recognizable column patterns
const hasRecognizableHeaders = (headers) => {
  if (!headers || headers.length === 0) return false;
  return headers.some(h =>
    columnMatches(h, CLIENT_NAME_PATTERNS) ||
    columnMatches(h, A_NUMBER_PATTERNS) ||
    columnMatches(h, MATTER_PATTERNS)
  );
};

// Check if a row of values looks like a header row
const rowLooksLikeHeaders = (values) => {
  const hasClientCol = values.some(v => columnMatches(v, CLIENT_NAME_PATTERNS));
  const hasANumCol = values.some(v => columnMatches(v, A_NUMBER_PATTERNS));
  const hasMatterCol = values.some(v => columnMatches(v, MATTER_PATTERNS));
  return hasClientCol || hasANumCol || hasMatterCol;
};

// Rebuild data using a specific row as headers
const rebuildDataWithHeaders = (jsonData, headerRowIndex) => {
  const headerRow = jsonData[headerRowIndex];
  const newHeaders = Object.values(headerRow).map(v => String(v || '').trim());
  const newData = [];

  for (let j = headerRowIndex + 1; j < jsonData.length; j++) {
    const dataRow = jsonData[j];
    const newRow = {};
    const oldValues = Object.values(dataRow);

    newHeaders.forEach((header, idx) => {
      if (header && oldValues[idx] !== undefined) {
        newRow[header] = oldValues[idx];
      }
    });

    // Only include non-empty rows
    if (Object.values(newRow).some(v => v !== undefined && v !== null && String(v).trim() !== '')) {
      newData.push(newRow);
    }
  }

  return { newHeaders, newData };
};

// Find the real header row in sheet data (skips metadata rows)
const findHeaderRow = (jsonData) => {
  if (jsonData.length === 0) return { headerRow: 0, data: jsonData };

  const firstRowHeaders = Object.keys(jsonData[0]);

  // Case 1: First row headers are already recognizable - use as-is
  if (hasRecognizableHeaders(firstRowHeaders) && !hasGenericHeaders(firstRowHeaders)) {
    return { headerRow: 0, data: jsonData };
  }

  // Case 2: Need to find the real header row
  // Scan through first 10 rows looking for recognizable headers
  for (let i = 0; i < Math.min(jsonData.length, 10); i++) {
    const row = jsonData[i];
    const values = Object.values(row).map(v => String(v || '').trim());

    if (rowLooksLikeHeaders(values)) {
      // This row looks like headers - rebuild data with these as column names
      const { newHeaders, newData } = rebuildDataWithHeaders(jsonData, i);
      return { headerRow: i + 1, data: newData, detectedHeaders: newHeaders };
    }
  }

  // Case 3: No recognizable headers found - return as-is and hope for the best
  return { headerRow: 0, data: jsonData };
};

// Parse a single sheet and extract client records
const parseSheetForClients = (sheetData, sheetName, headerRowOffset = 0) => {
  const clients = [];

  sheetData.forEach((row, rowIdx) => {
    // Try to find client identifier using patterns (case-insensitive)
    let clientName = findColumnValue(row, CLIENT_NAME_PATTERNS);
    let aNumber = null;

    // Try to extract A# from dedicated columns
    const rawANumber = findColumnValue(row, A_NUMBER_PATTERNS);
    if (rawANumber) {
      aNumber = extractANumberFromCell(rawANumber);
    }

    // If no client name, try to extract from Matter column
    if (!clientName) {
      const matter = findColumnValue(row, MATTER_PATTERNS);
      if (matter) {
        clientName = extractClientFromMatter(matter);
      }
    }

    // Skip if no client identifier found
    if (!clientName && !aNumber) return;

    // Build data object with all non-empty fields from this row
    const data = {};
    Object.entries(row).forEach(([key, value]) => {
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        // Skip internal fields and generic column names
        if (!key.startsWith('__') && !GENERIC_COLUMN_PATTERNS.test(key)) {
          data[key] = String(value).trim();
        }
      }
    });

    clients.push({
      sheetName,
      rowIndex: rowIdx + 2 + headerRowOffset, // 1-indexed + header row + offset
      clientName: clientName || '(Unknown)',
      normalizedName: normalizeClientName(clientName),
      aNumber,
      data,
    });
  });

  return clients;
};

// Merge client records across sheets
const mergeClientRecords = (allRecords) => {
  // Group by A# first (most reliable), then by normalized name
  const byANumber = new Map();
  const byName = new Map();

  allRecords.forEach(record => {
    if (record.aNumber) {
      if (!byANumber.has(record.aNumber)) {
        byANumber.set(record.aNumber, []);
      }
      byANumber.get(record.aNumber).push(record);
    } else if (record.normalizedName) {
      if (!byName.has(record.normalizedName)) {
        byName.set(record.normalizedName, []);
      }
      byName.get(record.normalizedName).push(record);
    }
  });

  // Build merged client list
  const mergedClients = [];
  const processedNames = new Set();

  // First, process clients with A#
  byANumber.forEach((records, aNumber) => {
    const names = [...new Set(records.map(r => r.clientName).filter(Boolean))];
    const normalizedNames = [...new Set(records.map(r => r.normalizedName).filter(Boolean))];

    // Mark these names as processed
    normalizedNames.forEach(n => processedNames.add(n));

    // Group data by sheet
    const sheetData = {};
    records.forEach(r => {
      if (!sheetData[r.sheetName]) {
        sheetData[r.sheetName] = [];
      }
      sheetData[r.sheetName].push({
        rowIndex: r.rowIndex,
        data: r.data,
      });
    });

    mergedClients.push({
      aNumber,
      names,
      primaryName: names[0] || '(Unknown)',
      sheetData,
      recordCount: records.length,
    });
  });

  // Then, process clients without A# (by name only)
  byName.forEach((records, normalizedName) => {
    // Skip if already processed via A#
    if (processedNames.has(normalizedName)) return;

    const names = [...new Set(records.map(r => r.clientName).filter(Boolean))];

    // Group data by sheet
    const sheetData = {};
    records.forEach(r => {
      if (!sheetData[r.sheetName]) {
        sheetData[r.sheetName] = [];
      }
      sheetData[r.sheetName].push({
        rowIndex: r.rowIndex,
        data: r.data,
      });
    });

    mergedClients.push({
      aNumber: null,
      names,
      primaryName: names[0] || '(Unknown)',
      sheetData,
      recordCount: records.length,
    });
  });

  // Sort by name
  mergedClients.sort((a, b) => a.primaryName.localeCompare(b.primaryName));

  return mergedClients;
};

// Main App Component
function ClioAirtableMerger() {
  const [activePhase, setActivePhase] = useState(0);

  // Phase 0 state (Bahr Excel Parser)
  const [bahrExcelFile, setBahrExcelFile] = useState(null);
  const [bahrSheets, setBahrSheets] = useState([]);
  const [bahrMergedClients, setBahrMergedClients] = useState([]);
  const [bahrParseReport, setBahrParseReport] = useState([]);
  const [bahrSelectedClient, setBahrSelectedClient] = useState(null);
  const [bahrSearchTerm, setBahrSearchTerm] = useState('');

  // Second Excel file state (Office CASES)
  const [officeCasesFile, setOfficeCasesFile] = useState(null);
  const [officeCasesSheets, setOfficeCasesSheets] = useState([]);
  const [officeCasesRecords, setOfficeCasesRecords] = useState([]);
  const [officeCasesParseReport, setOfficeCasesParseReport] = useState([]);

  // DocketWise CSV state
  const [docketWiseFile, setDocketWiseFile] = useState(null);
  const [docketWiseSheets, setDocketWiseSheets] = useState([]);
  const [docketWiseRecords, setDocketWiseRecords] = useState([]);
  const [docketWiseParseReport, setDocketWiseParseReport] = useState([]);

  // Phase 1 state
  const [phase1Files, setPhase1Files] = useState({ bahr: null, clioContacts: null });
  const [phase1Data, setPhase1Data] = useState({ bahr: null, clioContacts: null });
  const [phase1Result, setPhase1Result] = useState(null);
  const [phase1Report, setPhase1Report] = useState([]);

  // Phase 2 state
  const [phase2Files, setPhase2Files] = useState({ airtableClients: null, clioMatters: null, clioNotes: null });
  const [phase2Data, setPhase2Data] = useState({ airtableClients: null, clioMatters: null, clioNotes: null });
  const [phase2Result, setPhase2Result] = useState(null);
  const [phase2Report, setPhase2Report] = useState([]);

  // Phase 3 state
  const [phase3Files, setPhase3Files] = useState({
    airtableClients: null,
    airtableCaseMaster: null,
    clioEvents: null,
    clioRelationships: null
  });
  const [phase3Data, setPhase3Data] = useState({
    airtableClients: null,
    airtableCaseMaster: null,
    clioEvents: null,
    clioRelationships: null
  });
  const [phase3Result, setPhase3Result] = useState(null);
  const [phase3Report, setPhase3Report] = useState([]);

  // Developer Tools state
  const [airtableApiKey, setAirtableApiKey] = useState('');
  const [devToolsBaseId, setDevToolsBaseId] = useState('');
  const [devToolsTableName, setDevToolsTableName] = useState('');
  const [devToolsRecordId, setDevToolsRecordId] = useState('');
  const [devToolsSchema, setDevToolsSchema] = useState(null);
  const [devToolsRecord, setDevToolsRecord] = useState(null);
  const [devToolsLoading, setDevToolsLoading] = useState(false);
  const [devToolsError, setDevToolsError] = useState(null);
  const [devToolsBases, setDevToolsBases] = useState([]);
  const [devToolsTables, setDevToolsTables] = useState([]);
  const [caseNoteData, setCaseNoteData] = useState({
    Activity: '',
    Type: '',
    Date: '',
    Description: '',
    Contact: '',
    Client_PP_ID: '',
    Matter: '',
    RecordId: '',
    Created_By: '',
    source: 'clio-merge',
  });
  const [caseNoteResult, setCaseNoteResult] = useState(null);

  // Fetch Airtable bases
  const fetchAirtableBases = async () => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    try {
      const response = await fetch('https://api.airtable.com/v0/meta/bases', {
        headers: {
          'Authorization': `Bearer ${airtableApiKey}`,
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsBases(data.bases || []);
    } catch (err) {
      setDevToolsError(`Failed to fetch bases: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // Fetch tables for a base (schema)
  const fetchAirtableSchema = async (baseId) => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    if (!baseId) {
      setDevToolsError('Please select a base first');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    try {
      const response = await fetch(`https://api.airtable.com/v0/meta/bases/${baseId}/tables`, {
        headers: {
          'Authorization': `Bearer ${airtableApiKey}`,
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsTables(data.tables || []);
      setDevToolsSchema(data);
    } catch (err) {
      setDevToolsError(`Failed to fetch schema: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // Fetch a specific record
  const fetchAirtableRecord = async () => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    if (!devToolsBaseId || !devToolsTableName || !devToolsRecordId) {
      setDevToolsError('Please provide Base ID, Table Name, and Record ID');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    setDevToolsRecord(null);
    try {
      const response = await fetch(
        `https://api.airtable.com/v0/${devToolsBaseId}/${encodeURIComponent(devToolsTableName)}/${devToolsRecordId}`,
        {
          headers: {
            'Authorization': `Bearer ${airtableApiKey}`,
          },
        }
      );
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsRecord(data);
    } catch (err) {
      setDevToolsError(`Failed to fetch record: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // Fetch records from a table (list view)
  const fetchAirtableRecords = async (maxRecords = 10) => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    if (!devToolsBaseId || !devToolsTableName) {
      setDevToolsError('Please select a base and table first');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    try {
      const response = await fetch(
        `https://api.airtable.com/v0/${devToolsBaseId}/${encodeURIComponent(devToolsTableName)}?maxRecords=${maxRecords}`,
        {
          headers: {
            'Authorization': `Bearer ${airtableApiKey}`,
          },
        }
      );
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsRecord(data);
    } catch (err) {
      setDevToolsError(`Failed to fetch records: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // POST case note to Xano
  const postCaseNote = async () => {
    setDevToolsLoading(true);
    setDevToolsError(null);
    setCaseNoteResult(null);
    try {
      const payload = {
        ...caseNoteData,
        Date: caseNoteData.Date ? new Date(caseNoteData.Date).getTime() / 1000 : null,
        Due_Date: null,
        tags: [],
        unix_timestamp: String(Math.floor(Date.now() / 1000)),
        time_raw: new Date().toISOString(),
      };

      const response = await fetch(XANO_CASE_NOTES_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const data = await response.json();
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${JSON.stringify(data)}`);
      }
      setCaseNoteResult({ success: true, data });
    } catch (err) {
      setCaseNoteResult({ success: false, error: err.message });
    } finally {
      setDevToolsLoading(false);
    }
  };

  const handleFileUpload = (phase, type) => (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target.result;
      const parsed = parseCSV(text);

      if (phase === 1) {
        setPhase1Files(prev => ({ ...prev, [type]: file }));
        setPhase1Data(prev => ({ ...prev, [type]: parsed }));
      } else if (phase === 2) {
        setPhase2Files(prev => ({ ...prev, [type]: file }));
        setPhase2Data(prev => ({ ...prev, [type]: parsed }));
      } else if (phase === 3) {
        setPhase3Files(prev => ({ ...prev, [type]: file }));
        setPhase3Data(prev => ({ ...prev, [type]: parsed }));
      }
    };
    reader.readAsText(file);
  };

  // Handle Bahr Excel file upload
  const handleBahrExcelUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setBahrExcelFile(file);
    setBahrSheets([]);
    setBahrMergedClients([]);
    setBahrParseReport([]);
    setBahrSelectedClient(null);

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });

        const reports = [];
        const allSheets = [];
        const allClientRecords = [];

        reports.push({ type: 'info', message: `Loaded workbook with ${workbook.SheetNames.length} sheets` });

        // Process each sheet
        workbook.SheetNames.forEach(sheetName => {
          const worksheet = workbook.Sheets[sheetName];

          // Read as raw 2D array first to have full control over header detection
          const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

          if (rawRows.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": empty, skipped` });
            return;
          }

          // Find the header row by scanning for recognizable column names
          let headerRowIdx = 0;
          for (let i = 0; i < Math.min(rawRows.length, 15); i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowValues = row.map(v => String(v || '').trim());
            if (rowLooksLikeHeaders(rowValues)) {
              headerRowIdx = i;
              break;
            }
          }

          // Build JSON data using detected header row
          const headerValues = rawRows[headerRowIdx].map(v => String(v || '').trim());
          const jsonData = [];

          for (let i = headerRowIdx + 1; i < rawRows.length; i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowObj = {};
            let hasData = false;

            headerValues.forEach((header, idx) => {
              if (header && row[idx] !== undefined && row[idx] !== null) {
                const val = String(row[idx]).trim();
                if (val !== '') {
                  rowObj[header] = val;
                  hasData = true;
                }
              }
            });

            if (hasData) {
              jsonData.push(rowObj);
            }
          }

          const headerRow = headerRowIdx;
          const detectedHeaders = headerValues.filter(h => h !== '');

          if (jsonData.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": no data after header detection, skipped` });
            return;
          }

          // Get column headers
          const headers = detectedHeaders || Object.keys(jsonData[0] || {});

          allSheets.push({
            name: sheetName,
            rowCount: jsonData.length,
            headers,
            data: jsonData,
            headerRowOffset: headerRow,
          });

          // Extract clients from this sheet
          const clientsFromSheet = parseSheetForClients(jsonData, sheetName, headerRow);
          allClientRecords.push(...clientsFromSheet);

          const headerNote = headerRow > 0 ? ` (headers in row ${headerRow + 1})` : '';

          if (clientsFromSheet.length === 0 && jsonData.length > 0) {
            // Debug: show what headers were found to help identify missing patterns
            const sampleHeaders = headers.slice(0, 8).join(', ');
            reports.push({
              type: 'warning',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, 0 clients found${headerNote}. Headers: [${sampleHeaders}...]`
            });
          } else {
            reports.push({
              type: 'success',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, ${clientsFromSheet.length} clients found${headerNote}`
            });
          }
        });

        // Merge clients across sheets
        const merged = mergeClientRecords(allClientRecords);

        const withANumber = merged.filter(c => c.aNumber).length;
        const withoutANumber = merged.filter(c => !c.aNumber).length;

        reports.push({
          type: 'info',
          message: `Merged into ${merged.length} unique clients (${withANumber} with A#, ${withoutANumber} by name only)`
        });

        setBahrSheets(allSheets);
        setBahrMergedClients(merged);
        setBahrParseReport(reports);

      } catch (err) {
        setBahrParseReport([{ type: 'error', message: `Failed to parse Excel: ${err.message}` }]);
      }
    };
    reader.readAsArrayBuffer(file);
  };

  // Handle Office CASES Excel file upload (second source)
  const handleOfficeCasesUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setOfficeCasesFile(file);
    setOfficeCasesSheets([]);
    setOfficeCasesRecords([]);
    setOfficeCasesParseReport([]);

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });

        const reports = [];
        const allSheets = [];
        const allClientRecords = [];

        reports.push({ type: 'info', message: `Loaded Office CASES workbook with ${workbook.SheetNames.length} sheets` });

        // Process each sheet (same logic as BAHR)
        workbook.SheetNames.forEach(sheetName => {
          const worksheet = workbook.Sheets[sheetName];
          const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

          if (rawRows.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": empty, skipped` });
            return;
          }

          // Find the header row by scanning for recognizable column names
          let headerRowIdx = 0;
          for (let i = 0; i < Math.min(rawRows.length, 15); i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowValues = row.map(v => String(v || '').trim());
            if (rowLooksLikeHeaders(rowValues)) {
              headerRowIdx = i;
              break;
            }
          }

          // Build JSON data using detected header row
          const headerValues = rawRows[headerRowIdx].map(v => String(v || '').trim());
          const jsonData = [];

          for (let i = headerRowIdx + 1; i < rawRows.length; i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowObj = {};
            let hasData = false;

            headerValues.forEach((header, idx) => {
              if (header && row[idx] !== undefined && row[idx] !== null) {
                const val = String(row[idx]).trim();
                if (val !== '') {
                  rowObj[header] = val;
                  hasData = true;
                }
              }
            });

            if (hasData) {
              jsonData.push(rowObj);
            }
          }

          const headerRow = headerRowIdx;
          const detectedHeaders = headerValues.filter(h => h !== '');

          if (jsonData.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": no data after header detection, skipped` });
            return;
          }

          const headers = detectedHeaders || Object.keys(jsonData[0] || {});

          allSheets.push({
            name: sheetName,
            rowCount: jsonData.length,
            headers,
            data: jsonData,
            headerRowOffset: headerRow,
          });

          // Extract clients from this sheet - prefix sheet name with source file
          const clientsFromSheet = parseSheetForClients(jsonData, `[Office CASES] ${sheetName}`, headerRow);
          allClientRecords.push(...clientsFromSheet);

          const headerNote = headerRow > 0 ? ` (headers in row ${headerRow + 1})` : '';

          if (clientsFromSheet.length === 0 && jsonData.length > 0) {
            const sampleHeaders = headers.slice(0, 8).join(', ');
            reports.push({
              type: 'warning',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, 0 clients found${headerNote}. Headers: [${sampleHeaders}...]`
            });
          } else {
            reports.push({
              type: 'success',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, ${clientsFromSheet.length} clients found${headerNote}`
            });
          }
        });

        setOfficeCasesSheets(allSheets);
        setOfficeCasesRecords(allClientRecords);
        setOfficeCasesParseReport(reports);

      } catch (err) {
        setOfficeCasesParseReport([{ type: 'error', message: `Failed to parse Office CASES Excel: ${err.message}` }]);
      }
    };
    reader.readAsArrayBuffer(file);
  };

  // Handle DocketWise CSV/Excel file upload
  const handleDocketWiseUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setDocketWiseFile(file);
    setDocketWiseSheets([]);
    setDocketWiseRecords([]);
    setDocketWiseParseReport([]);

    const isCSV = file.name.toLowerCase().endsWith('.csv');

    if (isCSV) {
      // Parse as CSV
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const parsed = parseCSV(text);
          const reports = [];

          reports.push({ type: 'info', message: `Loaded DocketWise CSV with ${parsed.rows.length} rows` });

          // Convert CSV rows to client records format
          const allClientRecords = [];
          const sheetName = '[DocketWise] Main';

          parsed.rows.forEach((row, rowIdx) => {
            // Try to find client name and A# from DocketWise columns
            let clientName = row['full_name'] || findColumnValue(row, CLIENT_NAME_PATTERNS);
            let aNumber = null;

            // Try to extract A# from alien_registration_number column
            const rawANumber = row['alien_registration_number'] || findColumnValue(row, A_NUMBER_PATTERNS);
            if (rawANumber && rawANumber !== 'Unspecified') {
              aNumber = extractANumberFromCell(rawANumber);
            }

            // Skip if no client identifier found or name is "Unspecified"
            if ((!clientName || clientName === 'Unspecified') && !aNumber) return;
            if (clientName === 'Unspecified') clientName = null;

            // Build data object with all non-empty fields
            const data = {};
            Object.entries(row).forEach(([key, value]) => {
              if (value !== undefined && value !== null && String(value).trim() !== '' && value !== 'Unspecified') {
                data[key] = String(value).trim();
              }
            });

            allClientRecords.push({
              sheetName,
              rowIndex: rowIdx + 2, // 1-indexed + header
              clientName: clientName || '(Unknown)',
              normalizedName: normalizeClientName(clientName),
              aNumber,
              data,
            });
          });

          const withANumber = allClientRecords.filter(c => c.aNumber).length;
          reports.push({
            type: 'success',
            message: `Extracted ${allClientRecords.length} clients (${withANumber} with A#, ${allClientRecords.length - withANumber} by name only)`
          });

          setDocketWiseSheets([{
            name: 'Main',
            rowCount: parsed.rows.length,
            headers: parsed.headers,
            data: parsed.rows,
            headerRowOffset: 0,
          }]);
          setDocketWiseRecords(allClientRecords);
          setDocketWiseParseReport(reports);

        } catch (err) {
          setDocketWiseParseReport([{ type: 'error', message: `Failed to parse DocketWise CSV: ${err.message}` }]);
        }
      };
      reader.readAsText(file);
    } else {
      // Parse as Excel
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });

          const reports = [];
          const allSheets = [];
          const allClientRecords = [];

          reports.push({ type: 'info', message: `Loaded DocketWise workbook with ${workbook.SheetNames.length} sheets` });

          workbook.SheetNames.forEach(sheetName => {
            const worksheet = workbook.Sheets[sheetName];
            const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

            if (rawRows.length === 0) {
              reports.push({ type: 'warning', message: `Sheet "${sheetName}": empty, skipped` });
              return;
            }

            // Find header row
            let headerRowIdx = 0;
            for (let i = 0; i < Math.min(rawRows.length, 15); i++) {
              const row = rawRows[i];
              if (!row || row.length === 0) continue;
              const rowValues = row.map(v => String(v || '').trim());
              // Look for DocketWise-specific headers
              if (rowValues.some(v => v.toLowerCase() === 'full_name' || v.toLowerCase() === 'alien_registration_number') || rowLooksLikeHeaders(rowValues)) {
                headerRowIdx = i;
                break;
              }
            }

            const headerValues = rawRows[headerRowIdx].map(v => String(v || '').trim());
            const jsonData = [];

            for (let i = headerRowIdx + 1; i < rawRows.length; i++) {
              const row = rawRows[i];
              if (!row || row.length === 0) continue;

              const rowObj = {};
              let hasData = false;

              headerValues.forEach((header, idx) => {
                if (header && row[idx] !== undefined && row[idx] !== null) {
                  const val = String(row[idx]).trim();
                  if (val !== '' && val !== 'Unspecified') {
                    rowObj[header] = val;
                    hasData = true;
                  }
                }
              });

              if (hasData) {
                jsonData.push(rowObj);
              }
            }

            if (jsonData.length === 0) {
              reports.push({ type: 'warning', message: `Sheet "${sheetName}": no data, skipped` });
              return;
            }

            const headers = headerValues.filter(h => h !== '');
            allSheets.push({
              name: sheetName,
              rowCount: jsonData.length,
              headers,
              data: jsonData,
              headerRowOffset: headerRowIdx,
            });

            // Extract clients - prefix with [DocketWise]
            const clientsFromSheet = parseSheetForClients(jsonData, `[DocketWise] ${sheetName}`, headerRowIdx);
            allClientRecords.push(...clientsFromSheet);

            reports.push({
              type: 'success',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, ${clientsFromSheet.length} clients found`
            });
          });

          setDocketWiseSheets(allSheets);
          setDocketWiseRecords(allClientRecords);
          setDocketWiseParseReport(reports);

        } catch (err) {
          setDocketWiseParseReport([{ type: 'error', message: `Failed to parse DocketWise Excel: ${err.message}` }]);
        }
      };
      reader.readAsArrayBuffer(file);
    }
  };

  // Combine and merge clients from all data sources
  const combinedMergedClients = React.useMemo(() => {
    // Start with BAHR records - we need the raw records, not merged ones
    // So we need to rebuild from bahrSheets
    const allRecords = [];

    // Extract records from BAHR sheets
    bahrSheets.forEach(sheet => {
      const clientsFromSheet = parseSheetForClients(sheet.data, `[BAHR] ${sheet.name}`, sheet.headerRowOffset);
      allRecords.push(...clientsFromSheet);
    });

    // Add Office CASES records (already have source prefix)
    allRecords.push(...officeCasesRecords);

    // Add DocketWise records (already have source prefix)
    allRecords.push(...docketWiseRecords);

    if (allRecords.length === 0) return [];

    // Merge all records together
    return mergeClientRecords(allRecords);
  }, [bahrSheets, officeCasesRecords, docketWiseRecords]);

  // Generate flattened output for export
  const generateBahrFlattenedOutput = () => {
    const output = [];

    combinedMergedClients.forEach(client => {
      // Add client header row
      output.push({
        type: 'client',
        clientName: client.primaryName,
        aNumber: client.aNumber || '',
        sheetCount: Object.keys(client.sheetData).length,
        recordCount: client.recordCount,
        allNames: client.names.join('; '),
      });

      // Add data rows for each sheet
      Object.entries(client.sheetData).forEach(([sheetName, records]) => {
        records.forEach(record => {
          Object.entries(record.data).forEach(([key, value]) => {
            // Skip client identifier fields (already in header)
            if (CLIENT_NAME_COLUMNS.includes(key) || A_NUMBER_COLUMNS.includes(key) || MATTER_COLUMNS.includes(key)) {
              return;
            }
            output.push({
              type: 'data',
              clientName: client.primaryName,
              aNumber: client.aNumber || '',
              sheetName,
              rowIndex: record.rowIndex,
              fieldName: key,
              fieldValue: value,
            });
          });
        });
      });
    });

    return output;
  };

  // Download client data as JSON with records organized by sheet/tab name
  const downloadBahrFlattenedCSV = () => {
    const clientsJson = combinedMergedClients.map(client => {
      const clientObj = {
        clientName: client.primaryName,
        aNumber: client.aNumber || '',
        allNames: client.names,
      };

      // Add records for each sheet, using sheet name as the key
      Object.entries(client.sheetData).forEach(([sheetName, records]) => {
        clientObj[sheetName] = records.map(record => record.data);
      });

      return clientObj;
    });

    const json = JSON.stringify(clientsJson, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'combined_client_data.json';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Download client summary as CSV
  const downloadBahrClientSummary = () => {
    const headers = ['Client Name', 'A#', 'Sheets Found In', 'Record Count', 'All Name Variants'];
    const rows = combinedMergedClients.map(client => ({
      'Client Name': client.primaryName,
      'A#': client.aNumber || '',
      'Sheets Found In': Object.keys(client.sheetData).join('; '),
      'Record Count': client.recordCount,
      'All Name Variants': client.names.join('; '),
    }));

    const csv = generateCSV(headers, rows);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'combined_client_summary.csv';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Phase 1: Client Import
  // Helper to find a value in sheet data by trying multiple column name patterns
  const findFieldInSheetData = (sheetData, patterns) => {
    for (const [sheetName, records] of Object.entries(sheetData)) {
      for (const record of records) {
        for (const [key, value] of Object.entries(record.data || {})) {
          const normalizedKey = normalizeColumnName(key);
          for (const pattern of patterns) {
            if (normalizedKey === pattern || normalizedKey.includes(pattern)) {
              if (value && String(value).trim()) {
                return String(value).trim();
              }
            }
          }
        }
      }
    }
    return '';
  };

  // Field patterns for extracting demographics from sheet data
  const FIELD_PATTERNS = {
    firstName: ['first name', 'firstname', 'given name', 'nombre', 'primer nombre'],
    lastName: ['last name', 'lastname', 'family name', 'surname', 'apellido', 'apellidos'],
    middleName: ['middle name', 'middlename', 'segundo nombre'],
    dob: ['dob', 'date of birth', 'birthdate', 'birth date', 'date_of_birth', 'fecha de nacimiento'],
    phone: [
      'phone', 'telephone', 'telphone', 'cell', 'mobile', 'telefono', 'celular',
      'home phone', 'work phone', 'business phone', 'primary phone', 'mobile phone',
      'cell phone', 'other phone', 'phone number', 'phone 1', 'phone 2', 'phone1', 'phone2',
      'daytime phone', 'evening phone', 'contact phone', 'alternate phone', 'alt phone',
      'fax', 'tel', 'numero de telefono', 'número de teléfono', 'tel movil', 'tel casa'
    ],
    email: ['email', 'e-mail', 'correo', 'correo electronico'],
    addressLine1: ['street', 'address', 'street number and name', 'direccion', 'calle'],
    addressLine2: ['address line 2', 'apt', 'suite', 'unit', 'apartamento'],
    city: ['city', 'ciudad'],
    state: ['state', 'estado', 'province'],
    zip: ['zip', 'zipcode', 'postal', 'codigo postal'],
    country: ['country', 'citizenship', 'nationality', 'pais', 'nacionalidad', '18.a'],
    entryDate: ['entry date', 'arrival', 'date of last arrival', '22.'],
    placeOfEntry: ['place of entry', 'place of last arrival', 'port of entry', '23.'],
  };

  // Check if a value looks like a phone number (10+ digits) vs A# (9 digits)
  // A# format: xxx-xxx-xxx (9 digits), Phone format: xxx-xxx-xxxx (10 digits)
  const isLikelyPhoneNumber = (value) => {
    if (!value) return false;
    const digits = String(value).replace(/\D/g, '');
    // Phone numbers have 10+ digits (US), A# has exactly 9
    // Also accept 11 digits (country code + 10)
    if (digits.length >= 10) return true;
    // 7 digits could be a local number without area code
    if (digits.length === 7) return true;
    // Exactly 9 digits is likely an A#, not a phone
    if (digits.length === 9) return false;
    return false;
  };

  // Check if a column name looks like an A# column (to exclude from phone search)
  const isANumberColumn = (columnName) => {
    const normalized = normalizeColumnName(columnName);
    return A_NUMBER_PATTERNS.some(pattern =>
      normalized === pattern || normalized.includes(pattern)
    );
  };

  // Specialized phone extractor that checks all phone-like columns and validates values
  const findPhoneInSheetData = (sheetData) => {
    const phoneValues = [];

    for (const [sheetName, records] of Object.entries(sheetData)) {
      for (const record of records) {
        for (const [key, value] of Object.entries(record.data || {})) {
          if (!value || !String(value).trim()) continue;

          const normalizedKey = normalizeColumnName(key);

          // Skip if this column is an A# column
          if (isANumberColumn(key)) continue;

          // Check if column matches phone patterns
          const isPhoneColumn = FIELD_PATTERNS.phone.some(pattern =>
            normalizedKey === pattern || normalizedKey.includes(pattern)
          );

          if (isPhoneColumn) {
            const strValue = String(value).trim();
            // Validate it looks like a phone number, not an A#
            if (isLikelyPhoneNumber(strValue)) {
              phoneValues.push(strValue);
            }
          }
        }
      }
    }

    // Return first valid phone found
    return phoneValues.length > 0 ? phoneValues[0] : '';
  };

  const runPhase1 = useCallback(() => {
    const reports = [];
    const bahrLookup = new Map();
    const clientsOutput = [];

    let validANumbers = 0;
    let invalidANumbers = 0;
    let missingANumbers = 0;

    if (combinedMergedClients.length === 0) {
      reports.push({ type: 'warning', message: 'No clients loaded from Phase 0. Please upload and parse Excel files first.' });
      setPhase1Result(null);
      setPhase1Report(reports);
      return;
    }

    reports.push({ type: 'info', message: `Processing ${combinedMergedClients.length} clients from Phase 0 data (combined from all Excel files)` });

    // Build client records from combinedMergedClients
    combinedMergedClients.forEach((client, idx) => {
      // Parse name from primaryName (usually "Last, First" or "First Last")
      let firstName = '';
      let lastName = '';
      let middleName = '';
      const name = client.primaryName || '';

      if (name.includes(',')) {
        // "Last, First Middle" format
        const parts = name.split(',').map(p => p.trim());
        lastName = parts[0] || '';
        const firstParts = (parts[1] || '').split(' ');
        firstName = firstParts[0] || '';
        middleName = firstParts.slice(1).join(' ');
      } else {
        // "First Last" format - try to find from sheet data first
        firstName = findFieldInSheetData(client.sheetData, FIELD_PATTERNS.firstName);
        lastName = findFieldInSheetData(client.sheetData, FIELD_PATTERNS.lastName);
        middleName = findFieldInSheetData(client.sheetData, FIELD_PATTERNS.middleName);

        // Fallback: split the name intelligently for Spanish names
        // Spanish naming convention: FirstName [MiddleName] PatronymicLastName MatronymicLastName
        // e.g., "Aaron Alberto Villareal Tomasini" -> First: "Aaron Alberto", Last: "Villareal Tomasini"
        if (!firstName && !lastName) {
          const parts = name.split(' ').filter(p => p.length > 0);
          if (parts.length >= 5) {
            // 5+ words: take first 2 as given names, rest as family names
            firstName = parts[0];
            middleName = parts[1];
            lastName = parts.slice(2).join(' ');
          } else if (parts.length === 4) {
            // 4 words: likely "First Middle PatronymicLast MatronymicLast"
            firstName = parts[0];
            middleName = parts[1];
            lastName = parts.slice(2).join(' ');
          } else if (parts.length === 3) {
            // 3 words: "First Last1 Last2" or "First Middle Last"
            firstName = parts[0];
            lastName = parts.slice(1).join(' ');
          } else if (parts.length >= 2) {
            firstName = parts[0];
            lastName = parts.slice(1).join(' ');
          } else {
            lastName = name;
          }
        }
      }

      // Extract other fields from sheet data (normalize dates to YYYY-MM-DD)
      const dob = normalizeDate(findFieldInSheetData(client.sheetData, FIELD_PATTERNS.dob));
      const rawANumber = client.aNumber || '';
      const aNumberResult = normalizeANumber(rawANumber);
      const nameKey = normalizeName(lastName, firstName);

      let aNumberStatus = '';
      if (aNumberResult.isValid) {
        aNumberStatus = 'valid';
        validANumbers++;
      } else if (!rawANumber) {
        aNumberStatus = 'missing';
        missingANumbers++;
      } else {
        aNumberStatus = 'invalid';
        invalidANumbers++;
        reports.push({
          type: 'warning',
          message: `${firstName} ${lastName}: Invalid A# "${rawANumber}"`
        });
      }

      // Build flatpack data object for uscis_flatpack_data field
      const flatpackData = {};
      Object.entries(client.sheetData).forEach(([sheetName, records]) => {
        flatpackData[sheetName] = records.map(record => record.data);
      });

      const flatpackObj = {
        clientName: client.primaryName,
        aNumber: client.aNumber || '',
        allNames: client.names,
        ...flatpackData
      };

      // Always generate Client ID (never use A# as ID)
      const generatedClientId = generateFallbackId(lastName, firstName, dob) || `PENDING-${idx}`;

      const record = {
        _nameKey: nameKey,
        _clientId: generatedClientId,
        _aNumberStatus: aNumberStatus,
        _flatpackData: flatpackObj,
        lastName,
        firstName,
        middleName,
        aNumber: aNumberResult.isValid ? aNumberResult.normalized : '',
        phone: findPhoneInSheetData(client.sheetData),
        email: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.email),
        addressLine1: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.addressLine1),
        addressLine2: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.addressLine2),
        state: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.state),
        city: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.city),
        zip: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.zip),
        country: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.country),
        entryDate: normalizeDate(findFieldInSheetData(client.sheetData, FIELD_PATTERNS.entryDate)),
        placeOfEntry: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.placeOfEntry),
        dob: dob,
        clioContactId: '', // Will be populated from Clio Contacts
      };

      // Store under multiple name keys for flexible matching
      bahrLookup.set(nameKey, record);
      // Also store with firstName+middleName combined (handles Clio having full first name)
      if (middleName) {
        const fullFirstNameKey = normalizeName(lastName, `${firstName} ${middleName}`);
        if (!bahrLookup.has(fullFirstNameKey)) {
          bahrLookup.set(fullFirstNameKey, record);
        }
      }
      // Also store with last name only for last-name-only fallback matching
      const lastNameOnlyKey = `LASTNAME_ONLY:${normalizeName(lastName, '').split('|')[0]}`;
      if (!bahrLookup.has(lastNameOnlyKey)) {
        bahrLookup.set(lastNameOnlyKey, record);
      } else {
        // Mark as ambiguous if multiple records have same last name
        bahrLookup.set(lastNameOnlyKey, 'AMBIGUOUS');
      }
      // Store with condensed last name (no spaces) for "De Leon" vs "DeLeon" matching
      const condensedLastName = lastName.replace(/\s+/g, '');
      if (condensedLastName !== lastName) {
        const condensedKey = normalizeName(condensedLastName, firstName);
        if (!bahrLookup.has(condensedKey)) {
          bahrLookup.set(condensedKey, record);
        }
      }
      // Store with first word of last name only (handles "Villareal" vs "Villareal Tomasini")
      if (lastName.includes(' ')) {
        const firstLastWord = lastName.split(' ')[0];
        const firstLastWordKey = normalizeName(firstLastWord, firstName);
        if (!bahrLookup.has(firstLastWordKey)) {
          bahrLookup.set(firstLastWordKey, record);
        }
        // Also with fullFirstName
        if (middleName) {
          const firstLastWordFullFirstKey = normalizeName(firstLastWord, `${firstName} ${middleName}`);
          if (!bahrLookup.has(firstLastWordFullFirstKey)) {
            bahrLookup.set(firstLastWordFullFirstKey, record);
          }
        }
      }
    });

    const uniqueClientCount = combinedMergedClients.length;
    reports.push({ type: 'info', message: `Built ${uniqueClientCount} client records from Phase 0 data (${bahrLookup.size} lookup keys)` });
    reports.push({
      type: validANumbers === uniqueClientCount ? 'success' : 'warning',
      message: `A# Validation: ${validANumbers} valid, ${invalidANumbers} malformed, ${missingANumbers} missing`
    });

    // Enrich with Clio Contacts
    let contactMatches = 0;
    let contactMisses = 0;
    const unmatchedClioSamples = [];
    const matchedSamples = [];

    if (phase1Data.clioContacts?.rows) {
      phase1Data.clioContacts.rows.forEach((row) => {
        const lastName = row['Last Name'] || '';
        const firstName = row['First Name'] || '';
        const nameKey = normalizeName(lastName, firstName);

        // Try exact match first
        let record = bahrLookup.get(nameKey);
        let matchType = 'exact';

        // Fallback 1: try first word only of firstName (handles "Juan Carlos" vs "Juan")
        if (!record && firstName.includes(' ')) {
          const firstWordOnly = firstName.split(' ')[0];
          const firstWordKey = normalizeName(lastName, firstWordOnly);
          record = bahrLookup.get(firstWordKey);
          matchType = 'first-word';
        }

        // Fallback 2: try condensed last name (no spaces) for "De Leon" vs "DeLeon"
        if (!record) {
          const condensedLastName = lastName.replace(/\s+/g, '');
          if (condensedLastName !== lastName) {
            const condensedKey = normalizeName(condensedLastName, firstName);
            record = bahrLookup.get(condensedKey);
            matchType = 'condensed-lastname';
          }
        }

        // Fallback 3: try last word of firstName (in case BAHR has "Alberto" but Clio has "Aaron Alberto")
        if (!record && firstName.includes(' ')) {
          const words = firstName.split(' ');
          const lastWordOnly = words[words.length - 1];
          const lastWordKey = normalizeName(lastName, lastWordOnly);
          record = bahrLookup.get(lastWordKey);
          matchType = 'last-word';
        }

        // Fallback 4: try each word of firstName
        if (!record && firstName.includes(' ')) {
          const words = firstName.split(' ');
          for (const word of words) {
            const wordKey = normalizeName(lastName, word);
            record = bahrLookup.get(wordKey);
            if (record) {
              matchType = 'any-word';
              break;
            }
          }
        }

        // Fallback 5: try first word of lastName only (handles "Villareal" vs "Villareal Tomasini")
        if (!record && lastName.includes(' ')) {
          const firstLastWord = lastName.split(' ')[0];
          const firstLastWordKey = normalizeName(firstLastWord, firstName);
          record = bahrLookup.get(firstLastWordKey);
          matchType = 'first-lastname-word';

          // Also try first word with first-word-only firstName
          if (!record && firstName.includes(' ')) {
            const firstWordOnly = firstName.split(' ')[0];
            const combinedKey = normalizeName(firstLastWord, firstWordOnly);
            record = bahrLookup.get(combinedKey);
            matchType = 'first-lastname-first-firstname';
          }
        }

        // Fallback 6: last name only match (only if unique in BAHR)
        if (!record) {
          const lastNameOnlyKey = `LASTNAME_ONLY:${normalizeName(lastName, '').split('|')[0]}`;
          const lastNameResult = bahrLookup.get(lastNameOnlyKey);
          if (lastNameResult && lastNameResult !== 'AMBIGUOUS') {
            record = lastNameResult;
            matchType = 'lastname-only';
          }
        }

        if (record) {
          // Phone enrichment - priority: Mobile > Primary > Home > Business > Other > Business2 > Home2
          if (!record.phone) {
            record.phone = row['Mobile Phone'] || row['Primary Phone'] || row['Home Phone'] || row['Business Phone'] || row['Other Phone'] || row['Business Phone 2'] || row['Home Phone 2'] || '';
          }

          // Email enrichment - with fallback to secondary email
          if (!record.email) {
            record.email = row['E-mail Address'] || row['E-mail 2 Address'] || '';
          }

          // Address enrichment from Clio - check all address types since users may have used any field
          // Priority: Home > Business > Billing > Other
          if (!record.addressLine1) {
            record.addressLine1 = row['Home Street'] || row['Business Street'] || row['Billing Street'] || row['Other Street'] || '';
          }
          if (!record.addressLine2) {
            record.addressLine2 = row['Home Street 2'] || row['Business Street 2'] || row['Billing Street 2'] || row['Other Street 2'] || '';
          }
          if (!record.city) {
            record.city = row['Home City'] || row['Business City'] || row['Billing City'] || row['Other City'] || '';
          }
          if (!record.state) {
            const rawState = row['Home State'] || row['Business State'] || row['Billing State'] || row['Other State'] || '';
            record.state = rawState ? rawState.trim().toUpperCase() : '';
          }
          if (!record.zip) {
            const rawZip = row['Home Postal Code'] || row['Business Postal Code'] || row['Billing Postal Code'] || row['Other Postal Code'] || '';
            // Extract first 5 digits for standard US zip format
            if (rawZip) {
              const match = rawZip.match(/\d{5}/);
              record.zip = match ? match[0] : rawZip.replace(/\D/g, '').slice(0, 5);
            }
          }
          if (!record.country) {
            record.country = row['Home Country/Region'] || row['Business Country/Region'] || row['Billing Country/Region'] || row['Other Country/Region'] || '';
          }

          // DOB enrichment from Clio Birthday field (normalize to YYYY-MM-DD)
          if (!record.dob && row['Birthday']) {
            record.dob = normalizeDate(row['Birthday']);
          }

          record.clioContactId = row['UniqueId'] || '';
          contactMatches++;
          if (matchedSamples.length < 5) {
            matchedSamples.push({ clio: `${lastName}, ${firstName}`, bahr: record._nameKey, type: matchType });
          }
        } else {
          contactMisses++;
          if (unmatchedClioSamples.length < 20) {
            unmatchedClioSamples.push({ lastName, firstName, nameKey });
          }
        }
      });

      reports.push({ type: 'info', message: `Matched ${contactMatches} Clio contacts, ${contactMisses} unmatched` });

      // Debug: show sample matches
      if (matchedSamples.length > 0) {
        reports.push({ type: 'success', message: `Sample matches:` });
        matchedSamples.forEach(s => {
          reports.push({ type: 'info', message: `  ✓ Clio "${s.clio}" → BAHR key "${s.bahr}" (${s.type})` });
        });
      }

      // Debug: show sample unmatched Clio contacts
      if (unmatchedClioSamples.length > 0) {
        reports.push({ type: 'warning', message: `Sample unmatched Clio contacts (showing ${unmatchedClioSamples.length}):` });
        unmatchedClioSamples.forEach(s => {
          reports.push({ type: 'info', message: `  ✗ "${s.lastName}, ${s.firstName}" → key "${s.nameKey}"` });
        });
      }

      // Debug: show sample BAHR keys for comparison
      const bahrKeysSample = Array.from(bahrLookup.keys()).slice(0, 20);
      reports.push({ type: 'info', message: `Sample BAHR lookup keys (${bahrLookup.size} total):` });
      bahrKeysSample.forEach(k => {
        const rec = bahrLookup.get(k);
        reports.push({ type: 'info', message: `  BAHR: "${rec.lastName}, ${rec.firstName}" → key "${k}"` });
      });
    }

    // Build output - deduplicate since same record is stored under multiple keys
    const outputtedRecords = new Set();
    bahrLookup.forEach((record) => {
      // Skip 'AMBIGUOUS' markers and already-output records
      if (record === 'AMBIGUOUS' || outputtedRecords.has(record._clientId)) {
        return;
      }
      outputtedRecords.add(record._clientId);
      clientsOutput.push({
        'Client ID': record._clientId,
        'A#': record.aNumber,
        'First Name': record.firstName,
        'Middle Name': record.middleName,
        'Family Name': record.lastName,
        'Phone Number': record.phone,
        'Client Email': record.email,
        'Address Line 1': record.addressLine1,
        'Address Line 2': record.addressLine2,
        'City': record.city,
        'State': record.state,
        'Zip (5)': record.zip,
        'Country': record.country,
        'Entry Date': record.entryDate,
        'Place of Entry': record.placeOfEntry,
        'DOB': record.dob,
        'clio_contact_id': record.clioContactId,
        'ICH Atty': ANDREW_BAHR_RECORD_ID,
        'Bahr Client': 'TRUE',
        'uscis_flatpack_data': JSON.stringify(record._flatpackData),
      });
    });

    setPhase1Result({ clients: clientsOutput });
    setPhase1Report(reports);
  }, [phase1Data, combinedMergedClients]);

  // Phase 2: Case Master Views
  const runPhase2 = useCallback(() => {
    const reports = [];

    // Build clio_contact_id -> Airtable Record ID lookup from Airtable export
    const clioContactToRecordId = new Map();
    const clientIdToRecordId = new Map();

    if (phase2Data.airtableClients?.rows) {
      phase2Data.airtableClients.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || row['Airtable Record ID'] || '';
        const clioContactId = row['clio_contact_id'] || '';
        const clientId = row['Client ID'] || row['A#'] || '';

        if (clioContactId && recordId) {
          clioContactToRecordId.set(clioContactId, recordId);
        }
        if (clientId && recordId) {
          clientIdToRecordId.set(clientId, recordId);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioContactToRecordId.size} clio_contact_id mappings from Airtable export` });
    }

    // Build MatterId -> Matter info lookup from Clio Matters
    const mattersLookup = new Map();

    if (phase2Data.clioMatters?.rows) {
      phase2Data.clioMatters.rows.forEach((row) => {
        const matterId = row['UniqueId'] || '';
        const clientId = row['ClientId'] || '';
        const displayNumber = row['DisplayNumber'] || '';
        const description = row['Description'] || '';
        const client = row['Client'] || '';
        const status = row['Status'] || '';
        const openDate = row['OpenDate'] || '';
        const closeDate = row['CloseDate'] || '';

        if (matterId) {
          mattersLookup.set(matterId, {
            matterId,
            clientId, // This is the clio_contact_id
            displayNumber,
            description,
            clientName: client,
            status,
            openDate,
            closeDate,
            notes: [],
          });
        }
      });
      reports.push({ type: 'info', message: `Loaded ${mattersLookup.size} matters from Clio Matters` });
    }

    // Aggregate notes by MatterId
    let notesMatched = 0;
    let notesUnmatched = 0;

    if (phase2Data.clioNotes?.rows) {
      phase2Data.clioNotes.rows.forEach((row) => {
        const matterId = row['MatterId'] || '';
        const subject = row['Subject'] || '';
        const detail = row['Detail'] || '';
        const date = row['Date'] || row['CreatedAt'] || '';
        const creator = row['Creator'] || '';

        if (mattersLookup.has(matterId)) {
          mattersLookup.get(matterId).notes.push({ date, subject, detail, creator });
          notesMatched++;
        } else {
          notesUnmatched++;
        }
      });
      reports.push({ type: 'info', message: `Matched ${notesMatched} notes, ${notesUnmatched} unmatched` });
    }

    // Build Case Master View output
    const caseMasterOutput = [];
    let linkedCount = 0;
    let unlinkedCount = 0;

    mattersLookup.forEach((matter) => {
      // Find Airtable Record ID for this client
      const clientRecordId = clioContactToRecordId.get(matter.clientId) || '';

      if (clientRecordId) {
        linkedCount++;
      } else {
        unlinkedCount++;
        reports.push({ type: 'warning', message: `Matter ${matter.displayNumber} - client not found in Airtable export (ClientId: ${matter.clientId})` });
      }

      // Sort notes by date descending and format
      const sortedNotes = matter.notes.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));

      const formattedNotes = sortedNotes.map((note) => {
        const datePart = note.date ? `[${note.date}]` : '[No Date]';
        const subjectPart = note.subject ? ` - ${note.subject}` : '';
        const creatorPart = note.creator ? `\nBy: ${note.creator}` : '';
        return `${'═'.repeat(55)}\n${datePart}${subjectPart}${creatorPart}\n${'─'.repeat(50)}\n${note.detail || '(No content)'}`;
      }).join('\n\n');

      caseMasterOutput.push({
        'Client': clientRecordId, // Airtable link field
        'clio_matter_id': matter.matterId,
        'PP ID': matter.displayNumber,
        'Description': matter.description,
        'File Case Status': matter.status === 'Open' ? 'Active' : matter.status,
        'Case Notes': formattedNotes,
        'Bahr Client': 'TRUE',
        '_client_name': matter.clientName,
        '_note_count': sortedNotes.length,
      });
    });

    reports.push({ type: 'info', message: `Generated ${caseMasterOutput.length} Case Master Views (${linkedCount} linked, ${unlinkedCount} unlinked)` });

    setPhase2Result({ caseMaster: caseMasterOutput });
    setPhase2Report(reports);
  }, [phase2Data]);

  // Phase 3: Events & Relationships
  const runPhase3 = useCallback(() => {
    const reports = [];

    // Build lookups from Airtable exports
    const clioContactToRecordId = new Map();
    const clioMatterToRecordId = new Map();
    const displayNumberToRecordId = new Map();

    if (phase3Data.airtableClients?.rows) {
      phase3Data.airtableClients.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || '';
        const clioContactId = row['clio_contact_id'] || '';
        if (clioContactId && recordId) {
          clioContactToRecordId.set(clioContactId, recordId);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioContactToRecordId.size} client mappings` });
    }

    if (phase3Data.airtableCaseMaster?.rows) {
      phase3Data.airtableCaseMaster.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || '';
        const clioMatterId = row['clio_matter_id'] || '';
        const displayNumber = row['PP ID'] || '';

        if (clioMatterId && recordId) {
          clioMatterToRecordId.set(clioMatterId, recordId);
        }
        if (displayNumber && recordId) {
          // Extract just the number part for matching (e.g., "00006" from "00006-Hernandez")
          const numMatch = displayNumber.match(/^(\d+)/);
          if (numMatch) {
            displayNumberToRecordId.set(numMatch[1], recordId);
          }
          displayNumberToRecordId.set(displayNumber, recordId);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioMatterToRecordId.size} case master mappings` });
    }

    // Process Events
    const eventsOutput = [];
    let eventsLinked = 0;
    let eventsUnlinked = 0;

    if (phase3Data.clioEvents?.rows) {
      phase3Data.clioEvents.rows.forEach((row) => {
        const summary = row['summary'] || '';
        const description = row['description'] || '';
        const startDateTime = row['start.dateTime'] || '';
        const location = row['location'] || '';

        const summaryParsed = parseEventSummary(summary);
        const descParsed = parseEventDescription(description);

        // Skip events without A#
        if (!summaryParsed.aNumber) {
          reports.push({ type: 'warning', message: `Event skipped (no A#): ${summary.slice(0, 50)}...` });
          return;
        }

        // Try to find Case Master View by matter ID from summary
        let caseMasterRecordId = '';
        if (summaryParsed.matterId) {
          // Try full match first
          caseMasterRecordId = displayNumberToRecordId.get(summaryParsed.matterId) || '';

          // Try just the number part
          if (!caseMasterRecordId) {
            const numMatch = summaryParsed.matterId.match(/^(\d+)/);
            if (numMatch) {
              caseMasterRecordId = displayNumberToRecordId.get(numMatch[1]) || '';
            }
          }
        }

        if (caseMasterRecordId) {
          eventsLinked++;
        } else {
          eventsUnlinked++;
          reports.push({ type: 'warning', message: `Event not linked to Case Master: ${summaryParsed.matterId || 'no matter ID'}` });
        }

        const court = location || descParsed.courtAddress || '';

        eventsOutput.push({
          'Case Master': caseMasterRecordId, // Link to Case Master View
          'A#': summaryParsed.aNumber,
          'Hearing Date/Time': startDateTime,
          'Event Type': 'Hearing',
          'Event Hearing Type': mapHearingType(summaryParsed.hearingType),
          'Court': court,
          'Judge': descParsed.judge,
          'MCH Attny': ANDREW_BAHR_RECORD_ID,
          'Bahr Client': 'TRUE',
          '_summary': summary.slice(0, 100),
        });
      });

      reports.push({ type: 'info', message: `Processed ${eventsOutput.length} events (${eventsLinked} linked, ${eventsUnlinked} unlinked)` });
    }

    // Process Relationships
    const relationshipsOutput = [];
    let relsLinked = 0;
    let relsUnlinked = 0;

    if (phase3Data.clioRelationships?.rows) {
      phase3Data.clioRelationships.rows.forEach((row) => {
        const relationshipDesc = row['RelationshipDescription'] || '';
        const contactId = row['ContactId'] || ''; // Object client (the related person)
        const matterId = row['MatterId'] || '';
        const contactName = row['Contact'] || '';

        // Find the subject client (primary client on the matter) - we need to look this up from the matter
        // For now, we'll use the Case Master View link
        const caseMasterRecordId = clioMatterToRecordId.get(matterId) || '';
        const objectClientRecordId = clioContactToRecordId.get(contactId) || '';

        if (caseMasterRecordId && objectClientRecordId) {
          relsLinked++;
        } else {
          relsUnlinked++;
          if (!caseMasterRecordId) {
            reports.push({ type: 'warning', message: `Relationship: Case Master not found for matter ${matterId}` });
          }
          if (!objectClientRecordId) {
            reports.push({ type: 'warning', message: `Relationship: Object client not found (${contactName}, ID: ${contactId})` });
          }
        }

        // Map relationship description to Airtable select options
        const relationshipMap = {
          'spouse': 'Spouse',
          'son': 'Child',
          'daughter': 'Child',
          'parent': 'Parent',
          'mother': 'Parent',
          'father': 'Parent',
          'sibling': 'Sibling',
          'brother': 'Sibling',
          'sister': 'Sibling',
        };
        const relationship = relationshipMap[relationshipDesc.toLowerCase()] || relationshipDesc;

        relationshipsOutput.push({
          'Case Master View': caseMasterRecordId,
          'Object Client': objectClientRecordId,
          'Relationship': relationship,
          'Bahr Client': 'TRUE',
          '_contact_name': contactName,
          '_original_relationship': relationshipDesc,
        });
      });

      reports.push({ type: 'info', message: `Processed ${relationshipsOutput.length} relationships (${relsLinked} linked, ${relsUnlinked} unlinked)` });
    }

    setPhase3Result({ events: eventsOutput, relationships: relationshipsOutput });
    setPhase3Report(reports);
  }, [phase3Data]);

  const downloadCSV = (data, filename, headers) => {
    const csv = generateCSV(headers, data);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div style={{
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      color: '#e4e4e7',
      padding: '2rem',
    }}>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        * { box-sizing: border-box; }
        .card {
          background: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 12px;
          padding: 1.5rem;
          backdrop-filter: blur(10px);
        }
        .upload-zone {
          border: 2px dashed rgba(99, 102, 241, 0.4);
          border-radius: 8px;
          padding: 1.5rem;
          text-align: center;
          cursor: pointer;
          transition: all 0.2s;
        }
        .upload-zone:hover {
          border-color: rgba(99, 102, 241, 0.8);
          background: rgba(99, 102, 241, 0.05);
        }
        .upload-zone.has-file {
          border-color: #22c55e;
          background: rgba(34, 197, 94, 0.1);
        }
        .btn {
          padding: 0.75rem 1.5rem;
          border-radius: 8px;
          font-weight: 600;
          font-size: 0.875rem;
          cursor: pointer;
          transition: all 0.2s;
          border: none;
          font-family: inherit;
        }
        .btn-primary {
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
          color: white;
        }
        .btn-primary:hover:not(:disabled) {
          transform: translateY(-2px);
          box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
        }
        .btn-primary:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
        .btn-secondary {
          background: rgba(255, 255, 255, 0.1);
          color: #e4e4e7;
          border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover {
          background: rgba(255, 255, 255, 0.15);
        }
        .phase-tab {
          padding: 1rem 1.5rem;
          cursor: pointer;
          border-radius: 8px 8px 0 0;
          transition: all 0.2s;
          color: #a1a1aa;
          background: rgba(255, 255, 255, 0.02);
          border: 1px solid transparent;
          border-bottom: none;
        }
        .phase-tab:hover { color: #e4e4e7; }
        .phase-tab.active {
          color: #6366f1;
          background: rgba(99, 102, 241, 0.1);
          border-color: rgba(99, 102, 241, 0.3);
        }
        .badge {
          display: inline-block;
          padding: 0.25rem 0.5rem;
          border-radius: 4px;
          font-size: 0.75rem;
          font-weight: 600;
        }
        .badge-info { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .badge-warning { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .badge-error { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .badge-success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .table-container { overflow-x: auto; margin-top: 1rem; }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        th { background: rgba(99, 102, 241, 0.1); font-weight: 600; color: #a5b4fc; }
        td { color: #d4d4d8; }
      `}</style>

      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <header style={{ marginBottom: '2rem', textAlign: 'center' }}>
          <h1 style={{
            fontSize: '2rem',
            fontWeight: '700',
            background: 'linear-gradient(135deg, #6366f1 0%, #a855f7 50%, #ec4899 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            marginBottom: '0.5rem',
          }}>
            Clio → Airtable Merger
          </h1>
          <p style={{ color: '#71717a', fontSize: '0.875rem' }}>
            3-Phase import: Clients → Case Master Views → Events & Relationships
          </p>
        </header>

        {/* Phase Tabs */}
        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '0', flexWrap: 'wrap' }}>
          {[
            { num: 0, label: 'Bahr Parser', desc: 'Excel Multi-Tab Flattener' },
            { num: 1, label: 'Phase 1: Clients', desc: 'Bahr + Clio Contacts' },
            { num: 2, label: 'Phase 2: Case Master', desc: 'Matters + Notes' },
            { num: 3, label: 'Phase 3: Events & Relationships', desc: 'Events + Related Contacts' },
            { num: 4, label: 'Dev Tools', desc: 'Schema & Record Lookup' },
          ].map(({ num, label, desc }) => (
            <div
              key={num}
              className={`phase-tab ${activePhase === num ? 'active' : ''}`}
              onClick={() => setActivePhase(num)}
            >
              <div style={{ fontWeight: 600 }}>{label}</div>
              <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{desc}</div>
            </div>
          ))}
        </div>

        {/* Phase Content */}
        <div className="card" style={{ borderTopLeftRadius: 0 }}>
          {/* Phase 0: Excel Parser (Both Files) */}
          {activePhase === 0 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Excel Data Parser</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Upload Excel workbooks and/or DocketWise exports to extract and merge client data.
                Clients are matched by A# (primary) or normalized name (fallback) and combined into a single flat-packed record per unique client.
              </p>

              {/* Data Source Uploads */}
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {/* BAHR Workbook Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    BAHR Workbook
                    <span className="badge badge-warning">Excel .xlsx</span>
                  </h4>
                  <label className={`upload-zone ${bahrExcelFile ? 'has-file' : ''}`}>
                    <input
                      type="file"
                      accept=".xlsx,.xls"
                      onChange={handleBahrExcelUpload}
                      style={{ display: 'none' }}
                    />
                    {bahrExcelFile ? (
                      <div>
                        <span style={{ color: '#22c55e' }}>✓</span> {bahrExcelFile.name}
                        <div style={{ fontSize: '0.75rem', color: '#71717a' }}>
                          {bahrSheets.length} sheets
                        </div>
                      </div>
                    ) : (
                      <div style={{ color: '#71717a' }}>Drop Excel file or click to upload</div>
                    )}
                  </label>
                </div>

                {/* Office CASES Workbook Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Office CASES Workbook
                    <span className="badge badge-info">Excel .xlsx</span>
                  </h4>
                  <label className={`upload-zone ${officeCasesFile ? 'has-file' : ''}`}>
                    <input
                      type="file"
                      accept=".xlsx,.xls"
                      onChange={handleOfficeCasesUpload}
                      style={{ display: 'none' }}
                    />
                    {officeCasesFile ? (
                      <div>
                        <span style={{ color: '#22c55e' }}>✓</span> {officeCasesFile.name}
                        <div style={{ fontSize: '0.75rem', color: '#71717a' }}>
                          {officeCasesSheets.length} sheets
                        </div>
                      </div>
                    ) : (
                      <div style={{ color: '#71717a' }}>Drop Excel file or click to upload</div>
                    )}
                  </label>
                </div>

                {/* DocketWise Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    DocketWise Export
                    <span className="badge badge-success">CSV/Excel</span>
                  </h4>
                  <label className={`upload-zone ${docketWiseFile ? 'has-file' : ''}`}>
                    <input
                      type="file"
                      accept=".csv,.xlsx,.xls"
                      onChange={handleDocketWiseUpload}
                      style={{ display: 'none' }}
                    />
                    {docketWiseFile ? (
                      <div>
                        <span style={{ color: '#22c55e' }}>✓</span> {docketWiseFile.name}
                        <div style={{ fontSize: '0.75rem', color: '#71717a' }}>
                          {docketWiseSheets.length} sheet{docketWiseSheets.length !== 1 ? 's' : ''}, {docketWiseRecords.length} clients
                        </div>
                      </div>
                    ) : (
                      <div style={{ color: '#71717a' }}>Drop CSV/Excel or click to upload</div>
                    )}
                  </label>
                </div>
              </div>

              {/* Combined Stats */}
              {(bahrExcelFile || officeCasesFile || docketWiseFile) && (
                <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                  <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Combined Results</h4>
                  <div style={{ fontSize: '0.9rem' }}>
                    <strong>{combinedMergedClients.length}</strong> unique clients merged from{' '}
                    <strong>{bahrSheets.length + officeCasesSheets.length + docketWiseSheets.length}</strong> total sheets
                  </div>
                  <div style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.25rem' }}>
                    BAHR: {bahrSheets.length} sheets | Office CASES: {officeCasesSheets.length} sheets | DocketWise: {docketWiseSheets.length} sheet{docketWiseSheets.length !== 1 ? 's' : ''}
                  </div>
                </div>
              )}

              {/* Parse Reports - Tabbed */}
              {(bahrParseReport.length > 0 || officeCasesParseReport.length > 0 || docketWiseParseReport.length > 0) && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Parse Reports</h4>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem' }}>
                    {/* BAHR Report */}
                    {bahrParseReport.length > 0 && (
                      <div>
                        <div style={{ fontSize: '0.75rem', color: '#a5b4fc', marginBottom: '0.25rem' }}>BAHR Workbook</div>
                        <div style={{ maxHeight: '120px', overflowY: 'auto', fontSize: '0.8rem', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '6px' }}>
                          {bahrParseReport.map((item, i) => (
                            <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                              <span className={`badge badge-${item.type}`}>{item.type}</span>
                              <span style={{ fontSize: '0.75rem' }}>{item.message}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {/* Office CASES Report */}
                    {officeCasesParseReport.length > 0 && (
                      <div>
                        <div style={{ fontSize: '0.75rem', color: '#60a5fa', marginBottom: '0.25rem' }}>Office CASES Workbook</div>
                        <div style={{ maxHeight: '120px', overflowY: 'auto', fontSize: '0.8rem', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '6px' }}>
                          {officeCasesParseReport.map((item, i) => (
                            <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                              <span className={`badge badge-${item.type}`}>{item.type}</span>
                              <span style={{ fontSize: '0.75rem' }}>{item.message}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {/* DocketWise Report */}
                    {docketWiseParseReport.length > 0 && (
                      <div>
                        <div style={{ fontSize: '0.75rem', color: '#4ade80', marginBottom: '0.25rem' }}>DocketWise Export</div>
                        <div style={{ maxHeight: '120px', overflowY: 'auto', fontSize: '0.8rem', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '6px' }}>
                          {docketWiseParseReport.map((item, i) => (
                            <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                              <span className={`badge badge-${item.type}`}>{item.type}</span>
                              <span style={{ fontSize: '0.75rem' }}>{item.message}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* Sheets Overview - Combined */}
              {(bahrSheets.length > 0 || officeCasesSheets.length > 0 || docketWiseSheets.length > 0) && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>All Sheets ({bahrSheets.length + officeCasesSheets.length + docketWiseSheets.length})</h4>
                  <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                    {bahrSheets.map((sheet, i) => (
                      <div
                        key={`bahr-${i}`}
                        style={{
                          background: 'rgba(99, 102, 241, 0.1)',
                          border: '1px solid rgba(99, 102, 241, 0.3)',
                          borderRadius: '6px',
                          padding: '0.5rem 0.75rem',
                          fontSize: '0.8rem',
                        }}
                      >
                        <div style={{ fontWeight: 600, color: '#a5b4fc' }}>[BAHR] {sheet.name}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                          {sheet.rowCount} rows • {sheet.headers.length} columns
                        </div>
                      </div>
                    ))}
                    {officeCasesSheets.map((sheet, i) => (
                      <div
                        key={`office-${i}`}
                        style={{
                          background: 'rgba(59, 130, 246, 0.1)',
                          border: '1px solid rgba(59, 130, 246, 0.3)',
                          borderRadius: '6px',
                          padding: '0.5rem 0.75rem',
                          fontSize: '0.8rem',
                        }}
                      >
                        <div style={{ fontWeight: 600, color: '#60a5fa' }}>[Office] {sheet.name}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                          {sheet.rowCount} rows • {sheet.headers.length} columns
                        </div>
                      </div>
                    ))}
                    {docketWiseSheets.map((sheet, i) => (
                      <div
                        key={`docketwise-${i}`}
                        style={{
                          background: 'rgba(34, 197, 94, 0.1)',
                          border: '1px solid rgba(34, 197, 94, 0.3)',
                          borderRadius: '6px',
                          padding: '0.5rem 0.75rem',
                          fontSize: '0.8rem',
                        }}
                      >
                        <div style={{ fontWeight: 600, color: '#4ade80' }}>[DocketWise] {sheet.name}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                          {sheet.rowCount} rows • {sheet.headers.length} columns
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Download Buttons */}
              {combinedMergedClients.length > 0 && (
                <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem' }}>
                  <button className="btn btn-primary" onClick={downloadBahrClientSummary}>
                    Download Client Summary ({combinedMergedClients.length} clients)
                  </button>
                  <button className="btn btn-secondary" onClick={downloadBahrFlattenedCSV}>
                    Download Client Data (JSON)
                  </button>
                </div>
              )}

              {/* Client Search and List */}
              {combinedMergedClients.length > 0 && (
                <div>
                  <div style={{ display: 'flex', gap: '1rem', alignItems: 'center', marginBottom: '1rem' }}>
                    <h4 style={{ margin: 0 }}>Merged Clients ({combinedMergedClients.length})</h4>
                    <input
                      type="text"
                      placeholder="Search by name or A#..."
                      value={bahrSearchTerm}
                      onChange={(e) => setBahrSearchTerm(e.target.value)}
                      style={{
                        flex: 1,
                        maxWidth: '300px',
                        padding: '0.5rem 0.75rem',
                        borderRadius: '6px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        background: 'rgba(0, 0, 0, 0.3)',
                        color: '#e4e4e7',
                        fontSize: '0.875rem',
                      }}
                    />
                  </div>

                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem', maxHeight: '500px' }}>
                    {/* Client List */}
                    <div style={{ overflowY: 'auto', maxHeight: '500px', background: 'rgba(0, 0, 0, 0.2)', borderRadius: '8px', padding: '0.5rem' }}>
                      {combinedMergedClients
                        .filter(client => {
                          if (!bahrSearchTerm) return true;
                          const search = bahrSearchTerm.toUpperCase();
                          return (
                            client.primaryName.toUpperCase().includes(search) ||
                            (client.aNumber && client.aNumber.includes(search)) ||
                            client.names.some(n => n.toUpperCase().includes(search))
                          );
                        })
                        .slice(0, 100)
                        .map((client, i) => (
                          <div
                            key={i}
                            onClick={() => setBahrSelectedClient(client)}
                            style={{
                              padding: '0.5rem 0.75rem',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              marginBottom: '0.25rem',
                              background: bahrSelectedClient === client ? 'rgba(99, 102, 241, 0.3)' : 'transparent',
                              borderLeft: client.aNumber ? '3px solid #22c55e' : '3px solid #f59e0b',
                            }}
                          >
                            <div style={{ fontWeight: 500, fontSize: '0.85rem' }}>{client.primaryName}</div>
                            <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                              {client.aNumber || 'No A#'} • {Object.keys(client.sheetData).length} sheets
                            </div>
                          </div>
                        ))}
                    </div>

                    {/* Client Detail */}
                    <div style={{ overflowY: 'auto', maxHeight: '500px', background: 'rgba(0, 0, 0, 0.2)', borderRadius: '8px', padding: '1rem' }}>
                      {bahrSelectedClient ? (
                        <div>
                          <div style={{ marginBottom: '1rem', paddingBottom: '1rem', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                            <h3 style={{ margin: 0, color: '#a5b4fc' }}>{bahrSelectedClient.primaryName}</h3>
                            <div style={{ fontSize: '0.9rem', color: bahrSelectedClient.aNumber ? '#4ade80' : '#fbbf24', marginTop: '0.25rem' }}>
                              A#: {bahrSelectedClient.aNumber || '(not found)'}
                            </div>
                            {bahrSelectedClient.names.length > 1 && (
                              <div style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.25rem' }}>
                                Also known as: {bahrSelectedClient.names.slice(1).join(', ')}
                              </div>
                            )}
                          </div>

                          {/* Data by Sheet */}
                          {Object.entries(bahrSelectedClient.sheetData).map(([sheetName, records]) => (
                            <div key={sheetName} style={{ marginBottom: '1rem' }}>
                              <h4 style={{ color: '#6366f1', fontSize: '0.9rem', marginBottom: '0.5rem' }}>
                                📄 {sheetName}
                              </h4>
                              {records.map((record, ri) => (
                                <div
                                  key={ri}
                                  style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: '6px',
                                    padding: '0.75rem',
                                    marginBottom: '0.5rem',
                                    fontSize: '0.8rem',
                                  }}
                                >
                                  <div style={{ fontSize: '0.7rem', color: '#71717a', marginBottom: '0.5rem' }}>
                                    Row {record.rowIndex}
                                  </div>
                                  {Object.entries(record.data).map(([key, value]) => (
                                    <div key={key} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                                      <span style={{ color: '#a5b4fc', minWidth: '120px', flexShrink: 0 }}>{key}:</span>
                                      <span style={{ color: '#e4e4e7', wordBreak: 'break-word' }}>{value}</span>
                                    </div>
                                  ))}
                                </div>
                              ))}
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div style={{ color: '#71717a', textAlign: 'center', padding: '2rem' }}>
                          Select a client to view their data across all sheets
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {/* Instructions */}
              {!bahrExcelFile && !officeCasesFile && !docketWiseFile && (
                <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                  <h4 style={{ color: '#a5b4fc', marginBottom: '0.5rem' }}>How it works</h4>
                  <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                    <li>Upload Excel workbooks (.xlsx) or DocketWise CSV exports</li>
                    <li>Parser reads all sheets/rows and extracts client data</li>
                    <li>Clients are matched across ALL sources by A# (priority) or name</li>
                    <li>Data from all files is merged into a single flat-packed record per client</li>
                    <li>View merged data or download combined CSV/JSON</li>
                  </ol>
                  <div style={{ marginTop: '1rem', fontSize: '0.8rem', color: '#71717a' }}>
                    <strong>Recognized columns (case-insensitive):</strong><br/>
                    Client names: {CLIENT_NAME_PATTERNS.slice(0, 6).join(', ')}, full_name...<br/>
                    A# columns: {A_NUMBER_PATTERNS.slice(0, 6).join(', ')}, alien_registration_number...<br/>
                    Matter fields: {MATTER_PATTERNS.slice(0, 4).join(', ')}... (extracts name from "01453-Name" format)<br/>
                    <br/>
                    <strong>Smart features:</strong><br/>
                    • Auto-detects header row (skips "Column 1", "Column 2" generic headers)<br/>
                    • Supports DocketWise exports (full_name, alien_registration_number, date_of_birth)<br/>
                    • Supports Spanish column names (Nombre del Cliente, etc.)<br/>
                    • Merges clients with same A# or name from different files
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 1: Clients */}
          {activePhase === 1 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 1: Client Import</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Uses Phase 0 data with optional Clio Contacts enrichment. Output includes <code>clio_contact_id</code>, <code>uscis_flatpack_data</code>, and <code>Bahr Client</code> fields.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {/* Phase 0 Data Status */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Combined Excel Data (from Phase 0)
                    <span className="badge badge-warning">Required</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>Parsed from both Excel files in Phase 0</p>
                  <div className={`upload-zone ${combinedMergedClients.length > 0 ? 'has-file' : ''}`} style={{ cursor: 'default' }}>
                    {combinedMergedClients.length > 0 ? (
                      <div>
                        <span style={{ color: '#22c55e' }}>✓</span> Phase 0 data loaded
                        <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{combinedMergedClients.length} unique clients</div>
                      </div>
                    ) : (
                      <div style={{ color: '#ef4444' }}>⚠ Parse Excel files in Phase 0 first</div>
                    )}
                  </div>
                </div>

                {/* Clio Contacts Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Clio Contacts Export
                    <span className="badge badge-info">Optional</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>UniqueId, phone, email enrichment</p>
                  <label className={`upload-zone ${phase1Files.clioContacts ? 'has-file' : ''}`}>
                    <input type="file" accept=".csv" onChange={handleFileUpload(1, 'clioContacts')} style={{ display: 'none' }} />
                    {phase1Files.clioContacts ? (
                      <div>
                        <span style={{ color: '#22c55e' }}>✓</span> {phase1Files.clioContacts.name}
                        <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{phase1Data.clioContacts?.rows?.length || 0} rows</div>
                      </div>
                    ) : (
                      <div style={{ color: '#71717a' }}>Drop CSV or click to upload</div>
                    )}
                  </label>
                </div>
              </div>

              <button
                className="btn btn-primary"
                onClick={runPhase1}
                disabled={combinedMergedClients.length === 0}
                style={{ marginBottom: '1.5rem' }}
              >
                Generate clients.csv
              </button>

              {phase1Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Validation Report</h4>
                  <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.8rem' }}>
                    {phase1Report.map((item, i) => (
                      <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                        <span className={`badge badge-${item.type}`}>{item.type}</span>
                        <span>{item.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {phase1Result && (
                <div>
                  <button
                    className="btn btn-secondary"
                    onClick={() => downloadCSV(
                      phase1Result.clients,
                      'phase1_clients.csv',
                      ['Client ID', 'A#', 'First Name', 'Middle Name', 'Family Name', 'Phone Number', 'Client Email', 'Address Line 1', 'Address Line 2', 'City', 'State', 'Zip (5)', 'Country', 'Entry Date', 'Place of Entry', 'DOB', 'clio_contact_id', 'ICH Atty', 'Bahr Client', 'uscis_flatpack_data']
                    )}
                  >
                    Download clients.csv ({phase1Result.clients.length} records)
                  </button>

                  <div className="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th>Client ID</th>
                          <th>A#</th>
                          <th>Name</th>
                          <th>clio_contact_id</th>
                          <th>ICH Atty</th>
                        </tr>
                      </thead>
                      <tbody>
                        {phase1Result.clients.slice(0, 5).map((row, i) => (
                          <tr key={i}>
                            <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Client ID']}</td>
                            <td>{row['A#'] || '—'}</td>
                            <td>{row['First Name']} {row['Family Name']}</td>
                            <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['clio_contact_id'] || '—'}</td>
                            <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['ICH Atty'].slice(0, 10)}...</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Next Steps</h4>
                    <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                      <li>Import <code>phase1_clients.csv</code> to Airtable Client Info table</li>
                      <li>Export Client Info table (include Record ID and clio_contact_id columns)</li>
                      <li>Proceed to Phase 2 with the export</li>
                    </ol>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 2: Case Master Views */}
          {activePhase === 2 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 2: Case Master Views</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Create Case Master Views from Clio Matters with aggregated notes. Links to Clients via Airtable Record ID.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {[
                  { key: 'airtableClients', label: 'Airtable Client Export', desc: 'Must include Record ID and clio_contact_id', required: true },
                  { key: 'clioMatters', label: 'Clio Matters Export', desc: 'UniqueId, ClientId, DisplayNumber', required: true },
                  { key: 'clioNotes', label: 'Clio Matter Notes', desc: 'MatterId, Subject, Detail, Date', required: false },
                ].map(({ key, label, desc, required }) => (
                  <div key={key}>
                    <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                      {label}
                      {required && <span className="badge badge-warning">Required</span>}
                    </h4>
                    <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>{desc}</p>
                    <label className={`upload-zone ${phase2Files[key] ? 'has-file' : ''}`}>
                      <input type="file" accept=".csv" onChange={handleFileUpload(2, key)} style={{ display: 'none' }} />
                      {phase2Files[key] ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {phase2Files[key].name}
                          <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{phase2Data[key]?.rows?.length || 0} rows</div>
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                      )}
                    </label>
                  </div>
                ))}
              </div>

              <button
                className="btn btn-primary"
                onClick={runPhase2}
                disabled={!phase2Data.airtableClients?.rows?.length || !phase2Data.clioMatters?.rows?.length}
                style={{ marginBottom: '1.5rem' }}
              >
                Generate case_master_views.csv
              </button>

              {phase2Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Validation Report</h4>
                  <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.8rem' }}>
                    {phase2Report.map((item, i) => (
                      <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                        <span className={`badge badge-${item.type}`}>{item.type}</span>
                        <span>{item.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {phase2Result && (
                <div>
                  <button
                    className="btn btn-secondary"
                    onClick={() => downloadCSV(
                      phase2Result.caseMaster,
                      'phase2_case_master_views.csv',
                      ['Client', 'clio_matter_id', 'PP ID', 'Description', 'File Case Status', 'Case Notes', 'Bahr Client', '_client_name', '_note_count']
                    )}
                  >
                    Download case_master_views.csv ({phase2Result.caseMaster.length} records)
                  </button>

                  <div className="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th>Client (Record ID)</th>
                          <th>PP ID</th>
                          <th>Description</th>
                          <th>Notes</th>
                        </tr>
                      </thead>
                      <tbody>
                        {phase2Result.caseMaster.slice(0, 5).map((row, i) => (
                          <tr key={i}>
                            <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Client'] ? row['Client'].slice(0, 12) + '...' : '—'}</td>
                            <td>{row['PP ID']}</td>
                            <td>{row['Description']?.slice(0, 30)}</td>
                            <td>{row['_note_count']} notes</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Next Steps</h4>
                    <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                      <li>Import <code>phase2_case_master_views.csv</code> to Airtable Case Master View table</li>
                      <li>Export Case Master View table (include Record ID and clio_matter_id columns)</li>
                      <li>Proceed to Phase 3 with both exports</li>
                    </ol>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 3: Events & Relationships */}
          {activePhase === 3 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 3: Events & Relationships</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Create Events linked to Case Master Views, and Relationships between clients.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {[
                  { key: 'airtableClients', label: 'Airtable Client Export', desc: 'Record ID + clio_contact_id', required: true },
                  { key: 'airtableCaseMaster', label: 'Airtable Case Master Export', desc: 'Record ID + clio_matter_id + PP ID', required: true },
                  { key: 'clioEvents', label: 'Clio Events Export', desc: 'Google Calendar events', required: false },
                  { key: 'clioRelationships', label: 'Clio Contact Related Matters', desc: 'ContactId, MatterId, RelationshipDescription', required: false },
                ].map(({ key, label, desc, required }) => (
                  <div key={key}>
                    <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                      {label}
                      {required && <span className="badge badge-warning">Required</span>}
                    </h4>
                    <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>{desc}</p>
                    <label className={`upload-zone ${phase3Files[key] ? 'has-file' : ''}`}>
                      <input type="file" accept=".csv" onChange={handleFileUpload(3, key)} style={{ display: 'none' }} />
                      {phase3Files[key] ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {phase3Files[key].name}
                          <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{phase3Data[key]?.rows?.length || 0} rows</div>
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                      )}
                    </label>
                  </div>
                ))}
              </div>

              <button
                className="btn btn-primary"
                onClick={runPhase3}
                disabled={!phase3Data.airtableClients?.rows?.length || !phase3Data.airtableCaseMaster?.rows?.length}
                style={{ marginBottom: '1.5rem' }}
              >
                Generate events.csv & relationships.csv
              </button>

              {phase3Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Validation Report</h4>
                  <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.8rem' }}>
                    {phase3Report.map((item, i) => (
                      <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                        <span className={`badge badge-${item.type}`}>{item.type}</span>
                        <span>{item.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {phase3Result && (
                <div>
                  <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem' }}>
                    <button
                      className="btn btn-secondary"
                      onClick={() => downloadCSV(
                        phase3Result.events,
                        'phase3_events.csv',
                        ['Case Master', 'A#', 'Hearing Date/Time', 'Event Type', 'Event Hearing Type', 'Court', 'Judge', 'MCH Attny', 'Bahr Client', '_summary']
                      )}
                    >
                      Download events.csv ({phase3Result.events.length})
                    </button>

                    <button
                      className="btn btn-secondary"
                      onClick={() => downloadCSV(
                        phase3Result.relationships,
                        'phase3_relationships.csv',
                        ['Case Master View', 'Object Client', 'Relationship', 'Bahr Client', '_contact_name', '_original_relationship']
                      )}
                    >
                      Download relationships.csv ({phase3Result.relationships.length})
                    </button>
                  </div>

                  {phase3Result.events.length > 0 && (
                    <div style={{ marginBottom: '1.5rem' }}>
                      <h4 style={{ marginBottom: '0.5rem' }}>Events Preview</h4>
                      <div className="table-container">
                        <table>
                          <thead>
                            <tr>
                              <th>Case Master (Record ID)</th>
                              <th>A#</th>
                              <th>Date/Time</th>
                              <th>Type</th>
                            </tr>
                          </thead>
                          <tbody>
                            {phase3Result.events.slice(0, 5).map((row, i) => (
                              <tr key={i}>
                                <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Case Master'] ? row['Case Master'].slice(0, 12) + '...' : '—'}</td>
                                <td>{row['A#']}</td>
                                <td>{row['Hearing Date/Time']?.slice(0, 16)}</td>
                                <td>{row['Event Hearing Type']}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}

                  {phase3Result.relationships.length > 0 && (
                    <div>
                      <h4 style={{ marginBottom: '0.5rem' }}>Relationships Preview</h4>
                      <div className="table-container">
                        <table>
                          <thead>
                            <tr>
                              <th>Case Master View</th>
                              <th>Object Client</th>
                              <th>Relationship</th>
                              <th>Contact Name</th>
                            </tr>
                          </thead>
                          <tbody>
                            {phase3Result.relationships.slice(0, 5).map((row, i) => (
                              <tr key={i}>
                                <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Case Master View'] ? row['Case Master View'].slice(0, 12) + '...' : '—'}</td>
                                <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Object Client'] ? row['Object Client'].slice(0, 12) + '...' : '—'}</td>
                                <td>{row['Relationship']}</td>
                                <td>{row['_contact_name']}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Dev Tools */}
          {activePhase === 4 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Developer Tools</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Fetch Airtable schema for relevant fields, look up specific records, and test Xano case notes API.
              </p>

              {/* API Key Input */}
              <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                <h4 style={{ marginBottom: '0.75rem', color: '#a5b4fc' }}>Airtable API Configuration</h4>
                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                  <input
                    type="password"
                    value={airtableApiKey}
                    onChange={(e) => setAirtableApiKey(e.target.value)}
                    placeholder="Enter your Airtable Personal Access Token (pat...)"
                    style={{
                      flex: 1,
                      padding: '0.5rem 0.75rem',
                      borderRadius: '6px',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      background: 'rgba(0, 0, 0, 0.3)',
                      color: '#e4e4e7',
                      fontFamily: 'monospace',
                      fontSize: '0.875rem',
                    }}
                  />
                  <button
                    className="btn btn-primary"
                    onClick={fetchAirtableBases}
                    disabled={devToolsLoading || !airtableApiKey}
                  >
                    {devToolsLoading ? 'Loading...' : 'Load Bases'}
                  </button>
                </div>
                <p style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.5rem' }}>
                  Get your API key from <a href="https://airtable.com/create/tokens" target="_blank" style={{ color: '#6366f1' }}>airtable.com/create/tokens</a>
                </p>
              </div>

              {/* Error Display */}
              {devToolsError && (
                <div style={{ marginBottom: '1rem', padding: '0.75rem', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px', border: '1px solid rgba(239, 68, 68, 0.3)', color: '#f87171', fontSize: '0.875rem' }}>
                  {devToolsError}
                </div>
              )}

              {/* Schema Viewer */}
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', marginBottom: '1.5rem' }}>
                {/* Base & Table Selection */}
                <div>
                  <h4 style={{ marginBottom: '0.75rem' }}>Schema Viewer</h4>

                  {devToolsBases.length > 0 && (
                    <div style={{ marginBottom: '1rem' }}>
                      <label style={{ display: 'block', fontSize: '0.75rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Select Base</label>
                      <select
                        value={devToolsBaseId}
                        onChange={(e) => {
                          setDevToolsBaseId(e.target.value);
                          setDevToolsTables([]);
                          setDevToolsSchema(null);
                          setDevToolsRecord(null);
                          if (e.target.value) fetchAirtableSchema(e.target.value);
                        }}
                        style={{
                          width: '100%',
                          padding: '0.5rem',
                          borderRadius: '6px',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          background: 'rgba(0, 0, 0, 0.3)',
                          color: '#e4e4e7',
                          fontSize: '0.875rem',
                        }}
                      >
                        <option value="">-- Select a base --</option>
                        {devToolsBases.map(base => (
                          <option key={base.id} value={base.id}>{base.name}</option>
                        ))}
                      </select>
                    </div>
                  )}

                  {devToolsTables.length > 0 && (
                    <div style={{ marginBottom: '1rem' }}>
                      <label style={{ display: 'block', fontSize: '0.75rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Select Table</label>
                      <select
                        value={devToolsTableName}
                        onChange={(e) => {
                          setDevToolsTableName(e.target.value);
                          setDevToolsRecord(null);
                        }}
                        style={{
                          width: '100%',
                          padding: '0.5rem',
                          borderRadius: '6px',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          background: 'rgba(0, 0, 0, 0.3)',
                          color: '#e4e4e7',
                          fontSize: '0.875rem',
                        }}
                      >
                        <option value="">-- Select a table --</option>
                        {devToolsTables.map(table => (
                          <option key={table.id} value={table.name}>{table.name}</option>
                        ))}
                      </select>
                    </div>
                  )}

                  {devToolsTableName && (
                    <button
                      className="btn btn-secondary"
                      onClick={() => fetchAirtableRecords(10)}
                      disabled={devToolsLoading}
                      style={{ marginRight: '0.5rem' }}
                    >
                      Preview 10 Records
                    </button>
                  )}
                </div>

                {/* Record Lookup */}
                <div>
                  <h4 style={{ marginBottom: '0.75rem' }}>Record Lookup</h4>
                  <div style={{ marginBottom: '0.75rem' }}>
                    <label style={{ display: 'block', fontSize: '0.75rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Record ID</label>
                    <input
                      type="text"
                      value={devToolsRecordId}
                      onChange={(e) => setDevToolsRecordId(e.target.value)}
                      placeholder="rec..."
                      style={{
                        width: '100%',
                        padding: '0.5rem',
                        borderRadius: '6px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        background: 'rgba(0, 0, 0, 0.3)',
                        color: '#e4e4e7',
                        fontFamily: 'monospace',
                        fontSize: '0.875rem',
                      }}
                    />
                  </div>
                  <button
                    className="btn btn-primary"
                    onClick={fetchAirtableRecord}
                    disabled={devToolsLoading || !devToolsBaseId || !devToolsTableName || !devToolsRecordId}
                  >
                    Fetch Record
                  </button>
                </div>
              </div>

              {/* Schema Display */}
              {devToolsSchema && devToolsTableName && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                    <h4 style={{ margin: 0 }}>Table Schema: {devToolsTableName}</h4>
                    <button
                      className="btn btn-secondary"
                      style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem' }}
                      onClick={() => {
                        const fields = devToolsTables.find(t => t.name === devToolsTableName)?.fields || [];
                        const simplified = fields.map(f => ({ name: f.name, type: f.type }));
                        const json = JSON.stringify(simplified, null, 2);
                        navigator.clipboard.writeText(json);
                        alert('Schema JSON copied to clipboard!');
                      }}
                    >
                      Copy JSON
                    </button>
                  </div>
                  <div style={{ maxHeight: '300px', overflowY: 'auto', background: 'rgba(0, 0, 0, 0.3)', borderRadius: '8px', padding: '1rem' }}>
                    <table style={{ width: '100%', fontSize: '0.8rem' }}>
                      <thead>
                        <tr>
                          <th style={{ textAlign: 'left', padding: '0.25rem 0.5rem' }}>Field Name</th>
                          <th style={{ textAlign: 'left', padding: '0.25rem 0.5rem' }}>Type</th>
                          <th style={{ textAlign: 'left', padding: '0.25rem 0.5rem' }}>Options</th>
                        </tr>
                      </thead>
                      <tbody>
                        {devToolsTables
                          .find(t => t.name === devToolsTableName)?.fields
                          ?.map(field => (
                            <tr key={field.id}>
                              <td style={{ padding: '0.25rem 0.5rem', fontFamily: 'monospace' }}>{field.name}</td>
                              <td style={{ padding: '0.25rem 0.5rem' }}>
                                <span className="badge badge-info">{field.type}</span>
                              </td>
                              <td style={{ padding: '0.25rem 0.5rem', fontSize: '0.7rem', color: '#71717a' }}>
                                {field.options?.choices?.map(c => c.name).join(', ') ||
                                 (field.options?.linkedTableId ? `→ ${field.options.linkedTableId}` : '') ||
                                 ''}
                              </td>
                            </tr>
                          ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {/* Record Display */}
              {devToolsRecord && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>
                    {devToolsRecord.records ? `Records (${devToolsRecord.records.length})` : `Record: ${devToolsRecord.id}`}
                  </h4>
                  <div style={{ maxHeight: '400px', overflowY: 'auto', background: 'rgba(0, 0, 0, 0.3)', borderRadius: '8px', padding: '1rem' }}>
                    <pre style={{ fontSize: '0.75rem', color: '#a1a1aa', whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                      {JSON.stringify(devToolsRecord, null, 2)}
                    </pre>
                  </div>
                </div>
              )}

              {/* Xano Case Notes */}
              <div style={{ marginTop: '2rem', padding: '1rem', background: 'rgba(236, 72, 153, 0.1)', borderRadius: '8px', border: '1px solid rgba(236, 72, 153, 0.3)' }}>
                <h4 style={{ marginBottom: '0.75rem', color: '#f472b6' }}>Xano Case Notes API</h4>
                <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '1rem' }}>
                  POST to: <code style={{ color: '#a1a1aa' }}>{XANO_CASE_NOTES_ENDPOINT}</code>
                </p>

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '0.75rem', marginBottom: '1rem' }}>
                  {['Activity', 'Type', 'Contact', 'Client_PP_ID', 'Matter', 'Created_By'].map(field => (
                    <div key={field}>
                      <label style={{ display: 'block', fontSize: '0.7rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>{field}</label>
                      <input
                        type="text"
                        value={caseNoteData[field]}
                        onChange={(e) => setCaseNoteData(prev => ({ ...prev, [field]: e.target.value }))}
                        style={{
                          width: '100%',
                          padding: '0.375rem 0.5rem',
                          borderRadius: '4px',
                          border: '1px solid rgba(255, 255, 255, 0.15)',
                          background: 'rgba(0, 0, 0, 0.2)',
                          color: '#e4e4e7',
                          fontSize: '0.8rem',
                        }}
                      />
                    </div>
                  ))}
                </div>

                <div style={{ marginBottom: '1rem' }}>
                  <label style={{ display: 'block', fontSize: '0.7rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Date</label>
                  <input
                    type="datetime-local"
                    value={caseNoteData.Date}
                    onChange={(e) => setCaseNoteData(prev => ({ ...prev, Date: e.target.value }))}
                    style={{
                      padding: '0.375rem 0.5rem',
                      borderRadius: '4px',
                      border: '1px solid rgba(255, 255, 255, 0.15)',
                      background: 'rgba(0, 0, 0, 0.2)',
                      color: '#e4e4e7',
                      fontSize: '0.8rem',
                    }}
                  />
                </div>

                <div style={{ marginBottom: '1rem' }}>
                  <label style={{ display: 'block', fontSize: '0.7rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Description</label>
                  <textarea
                    value={caseNoteData.Description}
                    onChange={(e) => setCaseNoteData(prev => ({ ...prev, Description: e.target.value }))}
                    rows={3}
                    style={{
                      width: '100%',
                      padding: '0.375rem 0.5rem',
                      borderRadius: '4px',
                      border: '1px solid rgba(255, 255, 255, 0.15)',
                      background: 'rgba(0, 0, 0, 0.2)',
                      color: '#e4e4e7',
                      fontSize: '0.8rem',
                      resize: 'vertical',
                    }}
                  />
                </div>

                <button
                  className="btn btn-primary"
                  onClick={postCaseNote}
                  disabled={devToolsLoading}
                  style={{ background: 'linear-gradient(135deg, #ec4899 0%, #f472b6 100%)' }}
                >
                  {devToolsLoading ? 'Posting...' : 'POST Case Note'}
                </button>

                {caseNoteResult && (
                  <div style={{ marginTop: '1rem', padding: '0.75rem', borderRadius: '6px', background: caseNoteResult.success ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)', border: `1px solid ${caseNoteResult.success ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)'}` }}>
                    <pre style={{ fontSize: '0.75rem', color: caseNoteResult.success ? '#4ade80' : '#f87171', whiteSpace: 'pre-wrap' }}>
                      {caseNoteResult.success ? JSON.stringify(caseNoteResult.data, null, 2) : caseNoteResult.error}
                    </pre>
                  </div>
                )}

                {/* Schema Reference */}
                <details style={{ marginTop: '1rem' }}>
                  <summary style={{ cursor: 'pointer', fontSize: '0.8rem', color: '#a1a1aa' }}>View Full Schema</summary>
                  <pre style={{ marginTop: '0.5rem', fontSize: '0.7rem', color: '#71717a', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '4px', overflowX: 'auto' }}>
                    {JSON.stringify(XANO_CASE_NOTES_SCHEMA, null, 2)}
                  </pre>
                </details>
              </div>

              {/* Expected Fields Reference */}
              <div style={{ marginTop: '1.5rem' }}>
                <h4 style={{ marginBottom: '0.75rem' }}>Expected Airtable Fields by Table</h4>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem' }}>
                  {Object.entries(AIRTABLE_TABLES).map(([tableName, fields]) => (
                    <div key={tableName} style={{ background: 'rgba(0, 0, 0, 0.2)', padding: '0.75rem', borderRadius: '6px' }}>
                      <h5 style={{ fontSize: '0.8rem', color: '#a5b4fc', marginBottom: '0.5rem' }}>{tableName}</h5>
                      <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                        {fields.map((f, i) => (
                          <span key={f}>
                            <code style={{ color: '#a1a1aa' }}>{f}</code>
                            {i < fields.length - 1 ? ', ' : ''}
                          </span>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Instructions */}
        <div className="card" style={{ marginTop: '1.5rem' }}>
          <h3 style={{ marginBottom: '1rem' }}>Import Order</h3>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem', fontSize: '0.875rem' }}>
            <div>
              <div style={{ color: '#6366f1', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 1</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Upload Bahr + Clio Contacts</li>
                <li>Download clients.csv</li>
                <li>Import to Airtable</li>
                <li>Export with Record IDs</li>
              </ol>
            </div>
            <div>
              <div style={{ color: '#a855f7', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 2</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Upload Airtable export + Clio Matters/Notes</li>
                <li>Download case_master_views.csv</li>
                <li>Import to Airtable</li>
                <li>Export with Record IDs</li>
              </ol>
            </div>
            <div>
              <div style={{ color: '#ec4899', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 3</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Upload both Airtable exports</li>
                <li>Upload Clio Events/Relationships</li>
                <li>Download events.csv & relationships.csv</li>
                <li>Import to Airtable</li>
              </ol>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<ClioAirtableMerger />);
  </script>
</body>
</html>
