<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clio → Airtable Merger</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback, useEffect } = React;

// Constants
const ANDREW_BAHR_RECORD_ID = 'recRaQ8cur6na6kIw';
const AIRTABLE_BASE_ID = 'app1tsUyKa7F3sy0D';
const CASE_MASTER_VIEW_TABLE_ID = 'tblgynOzESGvAXAsK';

// Available input fields for mapping (from Clio data and computed fields)
const AVAILABLE_INPUT_FIELDS = [
  { id: 'UniqueId', name: 'UniqueId', description: 'Clio Matter Unique ID' },
  { id: 'DisplayNumber', name: 'DisplayNumber', description: 'Clio Matter Display Number' },
  { id: 'Description', name: 'Description', description: 'Matter Description' },
  { id: 'Status', name: 'Status', description: 'Matter Status' },
  { id: 'OpenDate', name: 'OpenDate', description: 'Matter Open Date' },
  { id: 'CloseDate', name: 'CloseDate', description: 'Matter Close Date' },
  { id: 'ClientId', name: 'ClientId', description: 'Clio Client ID' },
  { id: '_aggregated_notes', name: '_aggregated_notes', description: 'Aggregated Case Notes (computed)' },
  { id: '_constant_true', name: '_constant_true', description: 'Boolean True (constant)' },
  { id: '_client_record_id', name: '_client_record_id', description: 'Airtable Client Record ID (linked)' },
  { id: '_matter_flatpack_data', name: '_matter_flatpack_data', description: 'Matter Flatpack JSON (computed)' },
  { id: '_client_name', name: '_client_name', description: 'Client Name (computed)' },
  { id: '_note_count', name: '_note_count', description: 'Note Count (computed)' },
  { id: '_mapped_status', name: '_mapped_status', description: 'Mapped Status Value (computed)' },
];

// API Configuration
const XANO_CASE_NOTES_ENDPOINT = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:l_gEBOGc/case_notes';

// Relevant Airtable tables for schema inspection
const AIRTABLE_TABLES = {
  'Client Info': ['Client ID', 'A#', 'First Name', 'Middle Name', 'Family Name', 'Phone Number', 'Client Email', 'Address Line 1', 'Address Line 2', 'City', 'State', 'Zip (5)', 'Country', 'Entry Date', 'Place of Entry', 'DOB', 'clio_contact_id', 'Bahr Client', 'uscis_flatpack_data'],
  'Case Master View': ['Client', 'clio_matter_id', 'Description', 'File Case Status', 'Case Notes', 'Bahr Client', 'Matter_Flatpack'], // PP ID removed - it's a computed field
  'Events': ['Case Master', 'A#', 'Hearing Date/Time', 'Event Type', 'Event Hearing Type', 'Court', 'Judge', 'MCH Attny', 'Bahr Client'],
  'Relationships': ['Case Master View', 'Object Client', 'Relationship', 'Bahr Client'],
};

// Xano Case Notes schema
const XANO_CASE_NOTES_SCHEMA = {
  id: 'integer',
  Activity: 'text',
  Type: 'enum',
  Date: 'timestamp',
  Description: 'text',
  Contact: 'text',
  Client_PP_ID: 'text',
  Matter: 'text',
  RecordId: 'text',
  Created_By: 'text',
  Softr_Link_to_clients: 'text',
  Updated: 'text',
  Modified: 'text',
  Due_Date: 'timestamp',
  Last_Update_By: 'text',
  unix_timestamp: 'text',
  time_raw: 'text',
  tags: ['text'],
  pp_note_id: 'text',
  matter: 'text',
  matter_id: 'text',
  source: 'text',
  client_airtable_id: 'text',
  eventId: 'text',
};

// State-machine CSV Parser - handles multiline quoted fields correctly
// Auto-detects delimiter (tab or comma)
const parseCSV = (text) => {
  if (!text || !text.trim()) return { headers: [], rows: [] };

  // Auto-detect delimiter by checking first line
  const firstLine = text.split(/\r?\n/)[0] || '';
  const tabCount = (firstLine.match(/\t/g) || []).length;
  const commaCount = (firstLine.match(/,/g) || []).length;
  const delimiter = tabCount > commaCount ? '\t' : ',';

  const rows = [];
  let currentRow = [];
  let currentField = '';
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const nextChar = text[i + 1];

    if (inQuotes) {
      if (char === '"' && nextChar === '"') {
        currentField += '"';
        i++;
      } else if (char === '"') {
        inQuotes = false;
      } else {
        currentField += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === delimiter) {
        currentRow.push(currentField.trim());
        currentField = '';
      } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
        currentRow.push(currentField.trim());
        currentField = '';
        if (currentRow.some(f => f !== '')) {
          rows.push([...currentRow]);
        }
        currentRow = [];
        if (char === '\r' && nextChar === '\n') {
          i++;
        }
      } else if (char === '\r') {
        currentRow.push(currentField.trim());
        currentField = '';
        if (currentRow.some(f => f !== '')) {
          rows.push([...currentRow]);
        }
        currentRow = [];
      } else {
        currentField += char;
      }
    }
  }

  if (currentField !== '' || currentRow.length > 0) {
    currentRow.push(currentField.trim());
    if (currentRow.some(f => f !== '')) {
      rows.push(currentRow);
    }
  }

  if (rows.length === 0) return { headers: [], rows: [] };

  const headers = rows[0];
  const dataRows = rows.slice(1).map(row => {
    const obj = {};
    headers.forEach((h, i) => obj[h] = row[i] || '');
    return obj;
  });

  return { headers, rows: dataRows };
};

// Normalize A# to ###-###-### format
const normalizeANumber = (aNum) => {
  if (!aNum || !aNum.trim()) {
    return { normalized: '', isValid: false, original: aNum, issue: 'empty' };
  }

  const digits = aNum.replace(/[^0-9]/g, '');

  if (digits.length === 9) {
    return {
      normalized: `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`,
      isValid: true,
      original: aNum,
      issue: null
    };
  }

  if (digits.length === 10 && digits[0] === '1') {
    return {
      normalized: `${digits.slice(1, 4)}-${digits.slice(4, 7)}-${digits.slice(7, 10)}`,
      isValid: true,
      original: aNum,
      issue: null
    };
  }

  return {
    normalized: digits,
    isValid: false,
    original: aNum,
    issue: `wrong-length-${digits.length}`
  };
};

// Generate fallback ID for clients without valid A#
const generateFallbackId = (lastName, firstName, dob) => {
  const cleanLast = (lastName || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 10);
  const cleanFirst = (firstName || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 10);
  const cleanDob = (dob || '').replace(/[^0-9]/g, '').slice(0, 8);

  if (!cleanLast && !cleanFirst) return null;

  return `PENDING-${cleanLast}-${cleanFirst}${cleanDob ? '-' + cleanDob : ''}`;
};

// Normalize name for matching
const normalizeName = (lastName, firstName) => {
  const clean = (s) => {
    if (!s) return '';
    // Normalize diacritics first (é→e, ñ→n, etc), then uppercase and remove non-alphabetic
    return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase().trim().replace(/[^A-Z\s]/g, '').replace(/\s+/g, ' ');
  };
  return `${clean(lastName)}|${clean(firstName)}`;
};

// Normalize date to YYYY-MM-DD format for Airtable
const normalizeDate = (value) => {
  if (!value) return '';
  const trimmed = value.trim();
  if (!trimmed) return '';

  // Already in ISO format (YYYY-MM-DD)
  if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
    return trimmed;
  }

  // Try MM/DD/YYYY format (common in Clio exports)
  const slashParts = trimmed.split('/');
  if (slashParts.length === 3) {
    const [m, d, y] = slashParts;
    const month = m.padStart(2, '0');
    const day = d.padStart(2, '0');
    // Handle 2-digit years
    let year = y;
    if (y.length === 2) {
      year = parseInt(y) > 50 ? '19' + y : '20' + y;
    }
    if (month >= '01' && month <= '12' && day >= '01' && day <= '31') {
      return `${year}-${month}-${day}`;
    }
  }

  // Try MM-DD-YYYY format
  const dashParts = trimmed.split('-');
  if (dashParts.length === 3 && dashParts[0].length <= 2) {
    const [m, d, y] = dashParts;
    const month = m.padStart(2, '0');
    const day = d.padStart(2, '0');
    let year = y;
    if (y.length === 2) {
      year = parseInt(y) > 50 ? '19' + y : '20' + y;
    }
    if (month >= '01' && month <= '12' && day >= '01' && day <= '31') {
      return `${year}-${month}-${day}`;
    }
  }

  // Try to parse with Date constructor as fallback
  const date = new Date(trimmed);
  if (!isNaN(date.getTime())) {
    return date.toISOString().split('T')[0];
  }

  // Return original if we can't parse
  return trimmed;
};

// Extract A# from text
const extractANumber = (text) => {
  if (!text) return null;

  const patterns = [
    /\|A-?(\d{3})-?(\d{3})-?(\d{3})/i,
    /A-Number:?\s*(\d{3})-?(\d{3})-?(\d{3})/i,
    /A#\s*:?\s*(\d{3})-?(\d{3})-?(\d{3})/i,
    /\bA-(\d{3})-?(\d{3})-?(\d{3})\b/i,
    /\b(\d{3})-?(\d{3})-?(\d{3})\b/,
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      const digits = match.slice(1).join('').replace(/\D/g, '');
      if (digits.length === 9) {
        return `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`;
      }
    }
  }
  return null;
};

// Parse event summary
const parseEventSummary = (summary) => {
  if (!summary) return { hearingType: '', clientName: '', aNumber: null, status: '', court: '', matterId: '' };

  const result = { hearingType: '', clientName: '', aNumber: null, status: '', court: '', matterId: '' };
  let working = summary;

  result.aNumber = extractANumber(working);

  working = working
    .replace(/\|A-?Number:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/\|A-?\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/A-Number:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/A#\s*:?\s*\d{3}-?\d{3}-?\d{3}/gi, '')
    .replace(/\bA-\d{3}-?\d{3}-?\d{3}\b/gi, '');

  // Extract matter ID (in parentheses like "00026-Mendez Alvarado")
  const matterMatch = working.match(/\((\d{4,}-[^)]+)\)/);
  if (matterMatch) {
    result.matterId = matterMatch[1];
    working = working.replace(matterMatch[0], '').trim();
  }

  // Extract hearing type
  const HEARING_TYPES = ['MASTER', 'MCH', 'INDIVIDUAL', 'ICH', 'BOND', 'STATUS', 'CUSTODY', 'CALENDAR'];
  for (const typeKw of HEARING_TYPES) {
    if (working.toUpperCase().includes(typeKw)) {
      result.hearingType = typeKw;
      break;
    }
  }

  return result;
};

// Parse event description
const parseEventDescription = (desc) => {
  if (!desc) return { judge: '', courtAddress: '' };

  const result = { judge: '', courtAddress: '' };

  const judgeMatch = desc.match(/JUDGE[:\s]+([A-Za-z][^\n|]+)/i);
  if (judgeMatch) {
    result.judge = judgeMatch[1].trim().replace(/\s*(COURT|ADDRESS|RIDER).*$/i, '').trim();
  }

  const addressMatch = desc.match(/COURT\s*ADDRESS[:\s]+([^\n]+)/i);
  if (addressMatch) {
    result.courtAddress = addressMatch[1].trim();
  }

  return result;
};

// Map hearing type from Clio to Airtable
const mapHearingType = (clioType) => {
  const mapping = {
    'MASTER': 'Master',
    'INDIVIDUAL': 'Individual',
    'ICH': 'Individual',
    'MCH': 'Master',
    'BOND': 'Bond',
    'STATUS': 'Status Docket',
  };
  return mapping[clioType?.toUpperCase()] || clioType;
};

// Generate CSV string from data
const generateCSV = (headers, rows) => {
  const escapeField = (field) => {
    const str = String(field ?? '');
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };

  const headerRow = headers.map(escapeField).join(',');
  const dataRows = rows.map(row => headers.map(h => escapeField(row[h])).join(','));
  return [headerRow, ...dataRows].join('\n');
};

// ============================================
// BAHR EXCEL PARSER - Extract clients from multi-tab Excel
// ============================================

// Column name variations for client identification (will be matched case-insensitively)
const CLIENT_NAME_PATTERNS = [
  'client', 'client name', 'name', 'full name', 'fullname', 'client full name',
  'full_name', // DocketWise format
  // Spanish variations (including common typos)
  'nombre del cliente', 'nombre del ciente', 'nombre', 'cliente',
  'nombre completo', 'nombre del client', 'nom del cliente',
  'beneficiario', 'solicitante', 'applicant',
];
const A_NUMBER_PATTERNS = [
  'a number', 'a- number', 'a#', 'a-number', 'alien number', 'a #',
  'anumber', 'a num', 'a-num', 'a no', 'a-no', 'alien #', 'alien no',
  'alien_registration_number', // DocketWise format
  // Spanish
  'numero a', 'número a', 'numero alien', 'número alien', 'num a',
  'numero de alien', 'número de alien', 'num. a', 'no. a',
];
const MATTER_PATTERNS = [
  'matter', 'case matter', 'matter number', 'matter no', 'case no', 'case number',
  'case', 'file', 'file number', 'file no',
  // Spanish
  'caso', 'número de caso', 'numero de caso', 'materia', 'asunto',
  'expediente', 'num caso', 'no. caso',
];

// Generic column names to skip when looking for real headers
const GENERIC_COLUMN_PATTERNS = /^(column\s*\d+|col\s*\d+|field\s*\d+|__empty|__rownum)$/i;

// Extract client name from a Matter field like "01453-Castillo Garcia"
const extractClientFromMatter = (matter) => {
  if (!matter) return null;
  const match = matter.match(/^\d+-(.+)$/);
  return match ? match[1].trim() : null;
};

// Normalize client name for matching (handles "Last First" and "First Last" and "Last, First")
const normalizeClientName = (name) => {
  if (!name) return null;
  // Remove extra spaces, convert to uppercase
  let cleaned = name.toUpperCase().trim().replace(/\s+/g, ' ');
  // Handle "Last, First" format
  if (cleaned.includes(',')) {
    const parts = cleaned.split(',').map(p => p.trim());
    cleaned = parts.join(' ');
  }
  // Remove accents/diacritics for matching
  cleaned = cleaned.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  return cleaned;
};

// Normalize column name for comparison
const normalizeColumnName = (col) => {
  if (!col) return '';
  return String(col).toLowerCase().trim().replace(/\s+/g, ' ').normalize('NFD').replace(/[\u0300-\u036f]/g, '');
};

// Check if a column name matches any of the patterns
const columnMatches = (colName, patterns) => {
  const normalized = normalizeColumnName(colName);
  return patterns.some(pattern => normalized === pattern || normalized.includes(pattern));
};

// Extract A# from various formats
const extractANumberFromCell = (value) => {
  if (!value) return null;
  const str = String(value).trim();
  // Remove any non-digit characters except dash
  const digits = str.replace(/[^0-9]/g, '');
  if (digits.length === 9) {
    return `${digits.slice(0,3)}-${digits.slice(3,6)}-${digits.slice(6,9)}`;
  }
  // Handle 10 digit with leading 1
  if (digits.length === 10 && digits[0] === '1') {
    return `${digits.slice(1,4)}-${digits.slice(4,7)}-${digits.slice(7,10)}`;
  }
  return null;
};

// Find a column value trying multiple possible column name patterns (case-insensitive)
const findColumnValue = (row, patterns) => {
  for (const [colName, value] of Object.entries(row)) {
    if (columnMatches(colName, patterns)) {
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        return String(value).trim();
      }
    }
  }
  return null;
};

// Check if row has generic column headers (Column 1, Column 2, etc.)
const hasGenericHeaders = (headers) => {
  if (!headers || headers.length === 0) return false;
  const genericCount = headers.filter(h => GENERIC_COLUMN_PATTERNS.test(String(h))).length;
  return genericCount >= headers.length * 0.5; // More than half are generic
};

// Check if headers contain any recognizable column patterns
const hasRecognizableHeaders = (headers) => {
  if (!headers || headers.length === 0) return false;
  return headers.some(h =>
    columnMatches(h, CLIENT_NAME_PATTERNS) ||
    columnMatches(h, A_NUMBER_PATTERNS) ||
    columnMatches(h, MATTER_PATTERNS)
  );
};

// Check if a row of values looks like a header row
const rowLooksLikeHeaders = (values) => {
  const hasClientCol = values.some(v => columnMatches(v, CLIENT_NAME_PATTERNS));
  const hasANumCol = values.some(v => columnMatches(v, A_NUMBER_PATTERNS));
  const hasMatterCol = values.some(v => columnMatches(v, MATTER_PATTERNS));
  return hasClientCol || hasANumCol || hasMatterCol;
};

// Rebuild data using a specific row as headers
const rebuildDataWithHeaders = (jsonData, headerRowIndex) => {
  const headerRow = jsonData[headerRowIndex];
  const newHeaders = Object.values(headerRow).map(v => String(v || '').trim());
  const newData = [];

  for (let j = headerRowIndex + 1; j < jsonData.length; j++) {
    const dataRow = jsonData[j];
    const newRow = {};
    const oldValues = Object.values(dataRow);

    newHeaders.forEach((header, idx) => {
      if (header && oldValues[idx] !== undefined) {
        newRow[header] = oldValues[idx];
      }
    });

    // Only include non-empty rows
    if (Object.values(newRow).some(v => v !== undefined && v !== null && String(v).trim() !== '')) {
      newData.push(newRow);
    }
  }

  return { newHeaders, newData };
};

// Find the real header row in sheet data (skips metadata rows)
const findHeaderRow = (jsonData) => {
  if (jsonData.length === 0) return { headerRow: 0, data: jsonData };

  const firstRowHeaders = Object.keys(jsonData[0]);

  // Case 1: First row headers are already recognizable - use as-is
  if (hasRecognizableHeaders(firstRowHeaders) && !hasGenericHeaders(firstRowHeaders)) {
    return { headerRow: 0, data: jsonData };
  }

  // Case 2: Need to find the real header row
  // Scan through first 10 rows looking for recognizable headers
  for (let i = 0; i < Math.min(jsonData.length, 10); i++) {
    const row = jsonData[i];
    const values = Object.values(row).map(v => String(v || '').trim());

    if (rowLooksLikeHeaders(values)) {
      // This row looks like headers - rebuild data with these as column names
      const { newHeaders, newData } = rebuildDataWithHeaders(jsonData, i);
      return { headerRow: i + 1, data: newData, detectedHeaders: newHeaders };
    }
  }

  // Case 3: No recognizable headers found - return as-is and hope for the best
  return { headerRow: 0, data: jsonData };
};

// Parse a single sheet and extract client records
const parseSheetForClients = (sheetData, sheetName, headerRowOffset = 0) => {
  const clients = [];

  sheetData.forEach((row, rowIdx) => {
    // Try to find client identifier using patterns (case-insensitive)
    let clientName = findColumnValue(row, CLIENT_NAME_PATTERNS);
    let aNumber = null;

    // Try to extract A# from dedicated columns
    const rawANumber = findColumnValue(row, A_NUMBER_PATTERNS);
    if (rawANumber) {
      aNumber = extractANumberFromCell(rawANumber);
    }

    // If no client name, try to extract from Matter column
    if (!clientName) {
      const matter = findColumnValue(row, MATTER_PATTERNS);
      if (matter) {
        clientName = extractClientFromMatter(matter);
      }
    }

    // Skip if no client identifier found
    if (!clientName && !aNumber) return;

    // Build data object with all non-empty fields from this row
    const data = {};
    Object.entries(row).forEach(([key, value]) => {
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        // Skip internal fields and generic column names
        if (!key.startsWith('__') && !GENERIC_COLUMN_PATTERNS.test(key)) {
          data[key] = String(value).trim();
        }
      }
    });

    clients.push({
      sheetName,
      rowIndex: rowIdx + 2 + headerRowOffset, // 1-indexed + header row + offset
      clientName: clientName || '(Unknown)',
      normalizedName: normalizeClientName(clientName),
      aNumber,
      data,
    });
  });

  return clients;
};

// Merge client records across sheets
const mergeClientRecords = (allRecords) => {
  // Group by A# first (most reliable), then by normalized name
  const byANumber = new Map();
  const byName = new Map();

  allRecords.forEach(record => {
    if (record.aNumber) {
      if (!byANumber.has(record.aNumber)) {
        byANumber.set(record.aNumber, []);
      }
      byANumber.get(record.aNumber).push(record);
    } else if (record.normalizedName) {
      if (!byName.has(record.normalizedName)) {
        byName.set(record.normalizedName, []);
      }
      byName.get(record.normalizedName).push(record);
    }
  });

  // Build merged client list
  const mergedClients = [];
  const processedNames = new Set();

  // First, process clients with A#
  byANumber.forEach((records, aNumber) => {
    const names = [...new Set(records.map(r => r.clientName).filter(Boolean))];
    const normalizedNames = [...new Set(records.map(r => r.normalizedName).filter(Boolean))];

    // Mark these names as processed
    normalizedNames.forEach(n => processedNames.add(n));

    // Group data by sheet
    const sheetData = {};
    records.forEach(r => {
      if (!sheetData[r.sheetName]) {
        sheetData[r.sheetName] = [];
      }
      sheetData[r.sheetName].push({
        rowIndex: r.rowIndex,
        data: r.data,
      });
    });

    mergedClients.push({
      aNumber,
      names,
      primaryName: names[0] || '(Unknown)',
      sheetData,
      recordCount: records.length,
    });
  });

  // Then, process clients without A# (by name only)
  byName.forEach((records, normalizedName) => {
    // Skip if already processed via A#
    if (processedNames.has(normalizedName)) return;

    const names = [...new Set(records.map(r => r.clientName).filter(Boolean))];

    // Group data by sheet
    const sheetData = {};
    records.forEach(r => {
      if (!sheetData[r.sheetName]) {
        sheetData[r.sheetName] = [];
      }
      sheetData[r.sheetName].push({
        rowIndex: r.rowIndex,
        data: r.data,
      });
    });

    mergedClients.push({
      aNumber: null,
      names,
      primaryName: names[0] || '(Unknown)',
      sheetData,
      recordCount: records.length,
    });
  });

  // Sort by name
  mergedClients.sort((a, b) => a.primaryName.localeCompare(b.primaryName));

  return mergedClients;
};

// Main App Component
function ClioAirtableMerger() {
  const [activePhase, setActivePhase] = useState(0);

  // Phase 0 state (Bahr Excel Parser)
  const [bahrExcelFile, setBahrExcelFile] = useState(null);
  const [bahrSheets, setBahrSheets] = useState([]);
  const [bahrMergedClients, setBahrMergedClients] = useState([]);
  const [bahrParseReport, setBahrParseReport] = useState([]);
  const [bahrSelectedClient, setBahrSelectedClient] = useState(null);
  const [bahrSearchTerm, setBahrSearchTerm] = useState('');

  // Second Excel file state (Office CASES)
  const [officeCasesFile, setOfficeCasesFile] = useState(null);
  const [officeCasesSheets, setOfficeCasesSheets] = useState([]);
  const [officeCasesRecords, setOfficeCasesRecords] = useState([]);
  const [officeCasesParseReport, setOfficeCasesParseReport] = useState([]);

  // DocketWise CSV state
  const [docketWiseFile, setDocketWiseFile] = useState(null);
  const [docketWiseSheets, setDocketWiseSheets] = useState([]);
  const [docketWiseRecords, setDocketWiseRecords] = useState([]);
  const [docketWiseParseReport, setDocketWiseParseReport] = useState([]);

  // Phase 1 state
  const [phase1Files, setPhase1Files] = useState({ bahr: null, clioContacts: null });
  const [phase1Data, setPhase1Data] = useState({ bahr: null, clioContacts: null });
  const [phase1Result, setPhase1Result] = useState(null);
  const [phase1Report, setPhase1Report] = useState([]);

  // Phase 2 state
  const [phase2Files, setPhase2Files] = useState({ airtableClients: null, clioMatters: null, clioNotes: null });
  const [phase2Data, setPhase2Data] = useState({ airtableClients: null, clioMatters: null, clioNotes: null });
  const [phase2Result, setPhase2Result] = useState(null);
  const [phase2Report, setPhase2Report] = useState([]);
  const [phase2Sync, setPhase2Sync] = useState({
    loading: false,
    fetchedClients: [],
    logs: [],
    progress: { current: 0, total: 0, phase: '' }
  });

  // Phase 2 Field Mapping Configuration - will be populated from Airtable schema
  const [phase2FieldMapping, setPhase2FieldMapping] = useState({
    outputFields: {}, // Will be populated from schema: { fieldId: { inputField, fieldId, fieldName, fieldType, enabled } }
    statusMapping: {
      'Open': 'Active',
      'Closed': 'Closed',
      'Pending': 'Pending',
    },
    includeInternalFields: true,
  });
  const [showFieldMapping, setShowFieldMapping] = useState(false);

  // Case Master View schema from Airtable
  const [caseMasterSchema, setCaseMasterSchema] = useState({
    loading: false,
    error: null,
    fields: [], // Array of { id, name, type, options }
    loaded: false,
  });

  // Phase 3 state
  const [phase3Files, setPhase3Files] = useState({
    airtableClients: null,
    airtableCaseMaster: null,
    clioEvents: null,
    clioRelationships: null
  });
  const [phase3Data, setPhase3Data] = useState({
    airtableClients: null,
    airtableCaseMaster: null,
    clioEvents: null,
    clioRelationships: null
  });
  const [phase3Result, setPhase3Result] = useState(null);
  const [phase3Report, setPhase3Report] = useState([]);

// Phase 3 Airtable Sync State
  const [phase3SyncState, setPhase3SyncState] = useState({
    loading: false,
    judges: [], // Airtable Judges View records
    users: [], // Airtable Users records
    existingEvents: [],
    existingRelationships: [],
    preview: { events: { new: [], existing: [], errors: [] }, relationships: { new: [], existing: [], errors: [] } },
    logs: [],
    progress: { current: 0, total: 0, phase: '' }
  });

  // Phase 4 state (Case Notes to Xano)
  const [phase4Files, setPhase4Files] = useState({
    airtableClients: null,
    airtableCaseMaster: null,
    clioNotes: null
  });
  const [phase4Data, setPhase4Data] = useState({
    airtableClients: null,
    airtableCaseMaster: null,
    clioNotes: null
  });
  const [phase4Result, setPhase4Result] = useState(null);
  const [phase4Report, setPhase4Report] = useState([]);
  const [phase4Progress, setPhase4Progress] = useState({ current: 0, total: 0, status: 'idle' });

  // Developer Tools state - initialized from localStorage
  const [airtableApiKey, setAirtableApiKey] = useState(localStorage.getItem('airtable_api_key') || '');
  const [devToolsBaseId, setDevToolsBaseId] = useState(localStorage.getItem('airtable_base_id') || '');
  const [devToolsTableName, setDevToolsTableName] = useState(localStorage.getItem('airtable_table_name') || '');
  const [devToolsRecordId, setDevToolsRecordId] = useState('');
  const [devToolsSchema, setDevToolsSchema] = useState(null);
  const [devToolsRecord, setDevToolsRecord] = useState(null);
  const [devToolsLoading, setDevToolsLoading] = useState(false);
  const [devToolsError, setDevToolsError] = useState(null);
  const [devToolsBases, setDevToolsBases] = useState([]);
  const [devToolsTables, setDevToolsTables] = useState([]);
  const [caseNoteData, setCaseNoteData] = useState({
    Activity: '',
    Type: '',
    Date: '',
    Description: '',
    Contact: '',
    Client_PP_ID: '',
    Matter: '',
    RecordId: '',
    Created_By: '',
    source: 'clio-merge',
  });
  const [caseNoteResult, setCaseNoteResult] = useState(null);

  // API Sync State
  const [syncState, setSyncState] = useState({
    loading: false,
    existingRecords: [],
    preview: { new: [], existing: [], errors: [] },
    logs: [],
    progress: { current: 0, total: 0, phase: '' }
  });

  // Field mapping configuration - source field to Airtable field
  // Note: 'Client ID' is excluded because it's a computed/formula field in Airtable
  const [fieldMapping, setFieldMapping] = useState({
    'A#': { airtable: 'A#', enabled: true },
    'First Name': { airtable: 'First Name', enabled: true },
    'Middle Name': { airtable: 'Middle Name', enabled: true },
    'Family Name': { airtable: 'Family Name', enabled: true },
    'Phone Number': { airtable: 'Phone Number', enabled: true },
    'Client Email': { airtable: 'Client Email', enabled: true },
    'Address Line 1': { airtable: 'Address Line 1', enabled: true },
    'Address Line 2': { airtable: 'Address Line 2', enabled: true },
    'City': { airtable: 'City', enabled: true },
    'State': { airtable: 'State', enabled: true },
    'Zip (5)': { airtable: 'Zip (5)', enabled: true },
    'Country': { airtable: 'Country', enabled: true },
    'Entry Date': { airtable: 'Entry Date', enabled: true },
    'Place of Entry': { airtable: 'Place of Entry', enabled: true },
    'DOB': { airtable: 'DOB', enabled: true },
    'clio_contact_id': { airtable: 'clio_contact_id', enabled: true },
    'uscis_flatpack_data': { airtable: 'uscis_flatpack_data', enabled: true },
  });

  // Toggle field mapping
  const toggleFieldMapping = (sourceField) => {
    setFieldMapping(prev => ({
      ...prev,
      [sourceField]: { ...prev[sourceField], enabled: !prev[sourceField].enabled }
    }));
  };

  // Auto-save API key, base ID, and table name to localStorage
  useEffect(() => {
    if (airtableApiKey) localStorage.setItem('airtable_api_key', airtableApiKey);
    if (devToolsBaseId) localStorage.setItem('airtable_base_id', devToolsBaseId);
    if (devToolsTableName) localStorage.setItem('airtable_table_name', devToolsTableName);
  }, [airtableApiKey, devToolsBaseId, devToolsTableName]);

  // Add sync log
  const addSyncLog = (message, type = 'info') => {
    setSyncState(prev => ({
      ...prev,
      logs: [...prev.logs, { message, type, time: new Date().toLocaleTimeString() }]
    }));
  };

  // Fetch existing Client Info records for deduplication
  const fetchExistingClients = async () => {
    if (!airtableApiKey || !devToolsBaseId) {
      addSyncLog('Please enter API key and select a Base first', 'error');
      return;
    }

    setSyncState(prev => ({ ...prev, loading: true, logs: [] }));
    addSyncLog('Fetching existing Client Info records...', 'info');

    try {
      const allRecords = [];
      let offset = null;

      do {
        const url = offset
          ? `https://api.airtable.com/v0/${devToolsBaseId}/Client%20Info?offset=${offset}`
          : `https://api.airtable.com/v0/${devToolsBaseId}/Client%20Info`;

        const response = await fetch(
          url,
          { headers: { 'Authorization': `Bearer ${airtableApiKey}` } }
        );

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        allRecords.push(...data.records);
        offset = data.offset;
        addSyncLog(`Fetched ${allRecords.length} records...`, 'info');
      } while (offset);

      setSyncState(prev => ({ ...prev, existingRecords: allRecords, loading: false }));
      addSyncLog(`Total: ${allRecords.length} existing records in Client Info`, 'success');

      // Build lookup stats
      const withANum = allRecords.filter(r => r.fields['A#']).length;
      const withClio = allRecords.filter(r => r.fields['clio_contact_id']).length;
      addSyncLog(`  - ${withANum} with A#, ${withClio} with clio_contact_id`, 'info');
    } catch (err) {
      addSyncLog(`Error: ${err.message}`, 'error');
      setSyncState(prev => ({ ...prev, loading: false }));
    }
  };

  // Check for duplicates against existing records
  const checkDuplicates = () => {
    if (!phase1Result?.clients?.length) {
      addSyncLog('No Phase 1 data to check', 'error');
      return;
    }

    addSyncLog(`Checking ${phase1Result.clients.length} records for duplicates...`, 'info');

    // Build lookup maps from existing records
    const aNumLookup = new Map();
    const clioIdLookup = new Map();
    const clientIdLookup = new Map();

    syncState.existingRecords.forEach(rec => {
      if (rec.fields['A#']) aNumLookup.set(rec.fields['A#'].toLowerCase().trim(), rec);
      if (rec.fields['clio_contact_id']) clioIdLookup.set(String(rec.fields['clio_contact_id']).toLowerCase().trim(), rec);
      if (rec.fields['Client ID']) clientIdLookup.set(rec.fields['Client ID'].toLowerCase().trim(), rec);
    });

    const preview = { new: [], existing: [], errors: [] };

    phase1Result.clients.forEach((client, idx) => {
      let existingRecord = null;
      let matchedOn = '';

      // Check A# first (most reliable)
      if (client['A#']) {
        const match = aNumLookup.get(client['A#'].toLowerCase().trim());
        if (match) { existingRecord = match; matchedOn = `A#: ${client['A#']}`; }
      }

      // Check clio_contact_id
      if (!existingRecord && client['clio_contact_id']) {
        const match = clioIdLookup.get(String(client['clio_contact_id']).toLowerCase().trim());
        if (match) { existingRecord = match; matchedOn = `clio_contact_id: ${client['clio_contact_id']}`; }
      }

      // Check Client ID
      if (!existingRecord && client['Client ID']) {
        const match = clientIdLookup.get(client['Client ID'].toLowerCase().trim());
        if (match) { existingRecord = match; matchedOn = `Client ID: ${client['Client ID']}`; }
      }

      if (existingRecord) {
        preview.existing.push({ client, existingRecord, matchedOn, idx });
      } else if (!client['First Name'] && !client['Family Name']) {
        preview.errors.push({ client, error: 'Missing name', idx });
      } else {
        preview.new.push({ client, idx });
      }
    });

    setSyncState(prev => ({ ...prev, preview }));
    addSyncLog(`Duplicate check complete:`, 'success');
    addSyncLog(`  - ${preview.new.length} NEW records to create`, 'info');
    addSyncLog(`  - ${preview.existing.length} EXISTING (will skip)`, 'warning');
    addSyncLog(`  - ${preview.errors.length} with errors`, preview.errors.length > 0 ? 'error' : 'info');
  };

  // Export duplicates to CSV
  const exportDuplicatesCSV = () => {
    const duplicates = syncState.preview.existing;
    if (duplicates.length === 0) {
      addSyncLog('No duplicates to export', 'warning');
      return;
    }

    const headers = [
      'First Name',
      'Family Name',
      'Middle Name',
      'A#',
      'clio_contact_id',
      'Client ID',
      'Phone Number',
      'Client Email',
      'DOB',
      'Matched On',
      'Existing Airtable ID'
    ];

    const data = duplicates.map(({ client, existingRecord, matchedOn }) => ({
      'First Name': client['First Name'] || '',
      'Family Name': client['Family Name'] || '',
      'Middle Name': client['Middle Name'] || '',
      'A#': client['A#'] || '',
      'clio_contact_id': client['clio_contact_id'] || '',
      'Client ID': client['Client ID'] || '',
      'Phone Number': client['Phone Number'] || '',
      'Client Email': client['Client Email'] || '',
      'DOB': client['DOB'] || '',
      'Matched On': matchedOn,
      'Existing Airtable ID': existingRecord?.id || ''
    }));

    downloadCSV(data, 'duplicate_clients.csv', headers);
    addSyncLog(`Exported ${duplicates.length} duplicates to CSV`, 'success');
  };

  // Upload new records to Airtable
  const uploadToAirtable = async (testMode = false) => {
    const recordsToCreate = testMode ? syncState.preview.new.slice(0, 5) : syncState.preview.new;

    if (recordsToCreate.length === 0) {
      addSyncLog('No new records to upload', 'warning');
      return;
    }

    setSyncState(prev => ({ ...prev, loading: true, progress: { current: 0, total: recordsToCreate.length, phase: 'Uploading' } }));
    addSyncLog(`${testMode ? 'TEST: ' : ''}Starting upload of ${recordsToCreate.length} records...`, 'info');

    let created = 0;
    let failed = 0;

    // Process in batches of 10
    for (let i = 0; i < recordsToCreate.length; i += 10) {
      const batch = recordsToCreate.slice(i, i + 10);

      const airtableRecords = batch.map(({ client }, batchIdx) => {
        const fields = {};

        // Apply field mapping - only include enabled fields
        Object.entries(fieldMapping).forEach(([sourceField, config]) => {
          if (config.enabled) {
            const value = client[sourceField];
            if (value !== undefined && value !== null && value !== '') {
              fields[config.airtable] = value;
            }
          }
        });

        // Always include Bahr Client
        fields['Bahr Client'] = true;

        // VERBOSE LOGGING: Log each record's fields
        const recordName = `${fields['First Name'] || ''} ${fields['Family Name'] || ''}`.trim() || `Record ${batchIdx + 1}`;
        addSyncLog(`  Preparing: ${recordName}`, 'info');
        Object.entries(fields).forEach(([fieldName, fieldValue]) => {
          const displayValue = Array.isArray(fieldValue) ? `[${fieldValue.join(', ')}]` : fieldValue;
          const valueType = Array.isArray(fieldValue) ? '(array)' : `(${typeof fieldValue})`;
          addSyncLog(`    ${fieldName}: ${displayValue} ${valueType}`, 'info');
        });

        return { fields };
      });

      // Log the full payload being sent
      addSyncLog(`Sending batch ${Math.floor(i/10) + 1} to Airtable...`, 'info');

      try {
        const response = await fetch(
          `https://api.airtable.com/v0/${devToolsBaseId}/Client%20Info`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${airtableApiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ records: airtableRecords })
          }
        );

        if (!response.ok) {
          const errData = await response.json().catch(() => ({}));
          // Enhanced error logging - show full error details
          addSyncLog(`API Error Response: ${JSON.stringify(errData)}`, 'error');
          throw new Error(errData.error?.message || `HTTP ${response.status}`);
        }

        const result = await response.json();
        created += result.records.length;
        addSyncLog(`Batch ${Math.floor(i/10) + 1}: Created ${result.records.length} records`, 'success');

        setSyncState(prev => ({
          ...prev,
          progress: { ...prev.progress, current: i + batch.length }
        }));
      } catch (err) {
        failed += batch.length;
        addSyncLog(`Batch ${Math.floor(i/10) + 1} failed: ${err.message}`, 'error');
        // Log the full payload that failed
        addSyncLog(`Failed payload:`, 'error');
        airtableRecords.forEach((rec, idx) => {
          addSyncLog(`  Record ${idx + 1}: ${JSON.stringify(rec.fields)}`, 'error');
        });
      }

      // Rate limiting - wait 250ms between batches
      await new Promise(resolve => setTimeout(resolve, 250));
    }

    setSyncState(prev => ({ ...prev, loading: false, progress: { current: recordsToCreate.length, total: recordsToCreate.length, phase: 'Complete' } }));
    addSyncLog(`Upload complete: ${created} created, ${failed} failed`, created > 0 ? 'success' : 'error');

    // Refresh existing records and re-check duplicates
    if (created > 0) {
      await fetchExistingClients();
      checkDuplicates();
    }
  };

  // ============================================
  // PHASE 3 AIRTABLE INTEGRATION
  // ============================================

  // Add Phase 3 sync log
  const addPhase3Log = (message, type = 'info') => {
    setPhase3SyncState(prev => ({
      ...prev,
      logs: [...prev.logs, { message, type, time: new Date().toLocaleTimeString() }]
    }));
  };

  // Fetch Judges View records from Airtable
  const fetchJudges = async () => {
    if (!airtableApiKey) {
      addPhase3Log('Please enter API key first', 'error');
      return [];
    }

    addPhase3Log('Fetching Judges View records...', 'info');
    const allRecords = [];
    let offset = null;

    try {
      do {
        const url = offset
          ? `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Judges%20View?offset=${offset}`
          : `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Judges%20View`;

        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${airtableApiKey}` }
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        allRecords.push(...data.records);
        offset = data.offset;
      } while (offset);

      addPhase3Log(`Loaded ${allRecords.length} judges`, 'success');
      return allRecords;
    } catch (err) {
      addPhase3Log(`Error fetching judges: ${err.message}`, 'error');
      return [];
    }
  };

  // Fetch Users records from Airtable
  const fetchUsers = async () => {
    if (!airtableApiKey) {
      addPhase3Log('Please enter API key first', 'error');
      return [];
    }

    addPhase3Log('Fetching Users records...', 'info');
    const allRecords = [];
    let offset = null;

    try {
      do {
        const url = offset
          ? `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Users?offset=${offset}`
          : `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Users`;

        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${airtableApiKey}` }
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        allRecords.push(...data.records);
        offset = data.offset;
      } while (offset);

      addPhase3Log(`Loaded ${allRecords.length} users`, 'success');
      return allRecords;
    } catch (err) {
      addPhase3Log(`Error fetching users: ${err.message}`, 'error');
      return [];
    }
  };

  // Initialize Phase 3 lookup tables
  const initPhase3Lookups = async () => {
    if (!airtableApiKey) {
      addPhase3Log('Please enter API key first', 'error');
      return;
    }

    setPhase3SyncState(prev => ({ ...prev, loading: true, logs: [] }));

    const [judges, users] = await Promise.all([fetchJudges(), fetchUsers()]);

    setPhase3SyncState(prev => ({
      ...prev,
      judges,
      users,
      loading: false
    }));

    addPhase3Log(`Ready: ${judges.length} judges, ${users.length} users loaded`, 'success');
  };

  // Map judge name to Airtable record ID
  const findJudgeRecordId = (judgeName) => {
    if (!judgeName) return null;
    const normalized = judgeName.toUpperCase().trim();

    for (const judge of phase3SyncState.judges) {
      const airtableName = (judge.fields['Judge'] || '').toUpperCase().trim();
      if (airtableName && (airtableName.includes(normalized) || normalized.includes(airtableName))) {
        return judge.id;
      }
    }
    return null;
  };

  // Map user/attorney name to Airtable record ID
  const findUserRecordId = (userName) => {
    if (!userName) return ANDREW_BAHR_RECORD_ID; // Default to Andrew Bahr
    const normalized = userName.toUpperCase().trim();

    for (const user of phase3SyncState.users) {
      const name = (user.fields['Name'] || '').toUpperCase().trim();
      const firstName = (user.fields['First Name'] || '').toUpperCase().trim();
      const lastName = (user.fields['Last Name'] || '').toUpperCase().trim();

      if (name && (name.includes(normalized) || normalized.includes(name))) {
        return user.id;
      }
      if (firstName && lastName && normalized.includes(firstName) && normalized.includes(lastName)) {
        return user.id;
      }
    }
    return ANDREW_BAHR_RECORD_ID; // Default fallback
  };

  // Map court name from Clio to Airtable Court/Office options
  const mapCourtToAirtable = (courtStr) => {
    if (!courtStr) return null;
    const normalized = courtStr.toUpperCase();

    // Common court mappings
    const courtMappings = {
      'STERLING': 'Sterling IM',
      'ARLINGTON': 'Arlington IM ',
      'ANNANDALE': 'Annandale IM',
      'BALTIMORE': 'Baltimore IM',
      'HYATTSVILLE': 'Hyattsville IM',
      'FALLS CHURCH': 'Falls Church IAC',
      'CHARLOTTE': 'Charlotte IM ',
      'DALLAS': 'Dallas IM',
      'HOUSTON': 'Houston IM',
      'LOS ANGELES': 'Los Angeles IM',
      'NEW YORK': 'New York IM',
      'MIAMI': 'Miami IM',
      'ATLANTA': 'Atlanta IM',
      'CHICAGO': 'Chicago IM',
      'SAN ANTONIO': 'San Antonio IM',
      'DENVER': 'Denver IM',
      'SEATTLE': 'Seattle IM',
      'BOSTON': 'Boston IM',
      'NEWARK': 'Newark IM',
      'PHILADELPHIA': 'Philadelphia IM',
      'ORLANDO': 'Orlando IM',
      'SAN FRANCISCO': 'San Francisco IM',
      'SAN DIEGO': 'San Diego IM',
      'HARLINGEN': 'Harlingen IM',
      'EL PASO': 'El Paso IM',
      'PEARSALL': 'Pearsall IM',
      'LUMPKIN': 'Lumpkin, GA',
      'STEWART': 'Stewart, GA',
      'ADELANTO': 'Adelanto IM',
      'MEMPHIS': 'Memphis IM',
      'NEW ORLEANS': 'New Orleans IM',
      'OMAHA': 'Omaha IM',
      'LAS VEGAS': 'Las Vegas IM',
      'DETROIT': 'Detroit IM',
      'CLEVELAND': 'Cleveland IM',
      'LOUISVILLE': 'Louisville, KY',
      'ELIZABETH': 'Elizabeth IM',
      'OAKDALE': 'Oakdale IM',
      'CHELMSFORD': 'Chelmsford IM',
      'FORT WORTH': 'Fort Worth IAC',
      'HARTFORD': 'Hartford IM',
      'BUFFALO': 'Buffalo IM',
      'FORT SNELLING': 'Fort Snelling IM',
      'PITTSBURGH': 'Pittsburgh USCIS',
    };

    for (const [key, value] of Object.entries(courtMappings)) {
      if (normalized.includes(key)) {
        return value;
      }
    }

    return null; // Will need manual review
  };

  // Map Event Hearing Type from Clio to Airtable options
  const mapEventHearingType = (clioType) => {
    if (!clioType) return null;
    const normalized = clioType.toUpperCase();

    const typeMap = {
      'MASTER': 'Master',
      'MCH': 'Master',
      'INDIVIDUAL': 'Individual',
      'ICH': 'Individual',
      'BOND': 'Bond',
      'STATUS': 'Status Docket',
      'STATUS DOCKET': 'Status Docket',
      'CUSTODY': 'Custody',
      'CALENDAR': 'Calendar Control',
      'PRE-HEARING': 'Pre-Hearing Conf',
      'PREHEARING': 'Pre-Hearing Conf',
      'ASYLUM INTERVIEW': 'Asylum Interview',
      'USCIS': 'USCIS Interview',
      'CALL UP': 'Call up Date',
      'CONTESTED': 'Contested Hearing',
      'APPEAL': 'Appeal Notice Due',
      'BRIEF': 'Brief Due',
    };

    for (const [key, value] of Object.entries(typeMap)) {
      if (normalized.includes(key)) {
        return value;
      }
    }

    return 'Master'; // Default fallback
  };

  // Upload Events to Airtable
  const uploadEventsToAirtable = async (testMode = false) => {
    if (!phase3Result?.events?.length) {
      addPhase3Log('No events to upload', 'warning');
      return;
    }

    const eventsToCreate = testMode ? phase3Result.events.slice(0, 5) : phase3Result.events;

    // Filter to only events with Case Master links
    const validEvents = eventsToCreate.filter(e => e['Case Master']);

    if (validEvents.length === 0) {
      addPhase3Log('No events with valid Case Master links to upload', 'warning');
      return;
    }

    setPhase3SyncState(prev => ({
      ...prev,
      loading: true,
      progress: { current: 0, total: validEvents.length, phase: 'Uploading Events' }
    }));

    addPhase3Log(`${testMode ? 'TEST: ' : ''}Starting upload of ${validEvents.length} events...`, 'info');

    let created = 0;
    let failed = 0;

    // Process in batches of 10
    for (let i = 0; i < validEvents.length; i += 10) {
      const batch = validEvents.slice(i, i + 10);

      const airtableRecords = batch.map(event => {
        const fields = {
          'Case Master': [event['Case Master']], // Link field - array of record IDs
          'Hearing Date/Time': event['Hearing Date/Time'] || null,
          'Event Type': 'Court Event',
          'Event Hearing Type': mapEventHearingType(event['Event Hearing Type']) ? [mapEventHearingType(event['Event Hearing Type'])] : ['Master'],
          'Bahr Client': true,
        };

        // Add Court/Office if we can map it
        const court = mapCourtToAirtable(event['Court']);
        if (court) {
          fields['Court/Office'] = [court];
        }

        // Add Judge link if we can find it
        const judgeId = findJudgeRecordId(event['Judge']);
        if (judgeId) {
          fields['Judge'] = [judgeId];
        }

        // Add MCH Attny - default to Andrew Bahr
        fields['MCH Attny'] = [ANDREW_BAHR_RECORD_ID];

        // Add clio_contact_id if available
        if (event['clio_contact_id']) {
          fields['clio_contact_id'] = event['clio_contact_id'];
        }

        return { fields };
      });

      try {
        const response = await fetch(
          `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Events`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${airtableApiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ records: airtableRecords })
          }
        );

        if (!response.ok) {
          const errData = await response.json().catch(() => ({}));
          throw new Error(errData.error?.message || `HTTP ${response.status}`);
        }

        const result = await response.json();
        created += result.records.length;
        addPhase3Log(`Events batch ${Math.floor(i/10) + 1}: Created ${result.records.length} records`, 'success');

        setPhase3SyncState(prev => ({
          ...prev,
          progress: { ...prev.progress, current: i + batch.length }
        }));
      } catch (err) {
        failed += batch.length;
        addPhase3Log(`Events batch ${Math.floor(i/10) + 1} failed: ${err.message}`, 'error');
      }

      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 250));
    }

    setPhase3SyncState(prev => ({
      ...prev,
      loading: false,
      progress: { current: validEvents.length, total: validEvents.length, phase: 'Events Complete' }
    }));

    addPhase3Log(`Events upload complete: ${created} created, ${failed} failed`, created > 0 ? 'success' : 'error');
  };

  // Upload Relationships to Airtable
  const uploadRelationshipsToAirtable = async (testMode = false) => {
    if (!phase3Result?.relationships?.length) {
      addPhase3Log('No relationships to upload', 'warning');
      return;
    }

    const relsToCreate = testMode ? phase3Result.relationships.slice(0, 5) : phase3Result.relationships;

    // Filter to only relationships with valid links
    const validRels = relsToCreate.filter(r => r['Case Master View'] && r['Object Client']);

    if (validRels.length === 0) {
      addPhase3Log('No relationships with valid links to upload', 'warning');
      return;
    }

    setPhase3SyncState(prev => ({
      ...prev,
      loading: true,
      progress: { current: 0, total: validRels.length, phase: 'Uploading Relationships' }
    }));

    addPhase3Log(`${testMode ? 'TEST: ' : ''}Starting upload of ${validRels.length} relationships...`, 'info');

    let created = 0;
    let failed = 0;

    // Map relationship types to Airtable options
    const relationshipMap = {
      'Spouse': 'LEGAL SPOUSE',
      'Child': 'CHILD',
      'Parent': 'PARENT',
      'Sibling': 'SIBLING',
      'Partner': 'PARTNER',
      'Custodian': 'CUSTODIAN',
      'Ward': 'LEGAL WARD',
    };

    // Process in batches of 10
    for (let i = 0; i < validRels.length; i += 10) {
      const batch = validRels.slice(i, i + 10);

      const airtableRecords = batch.map(rel => {
        const relType = relationshipMap[rel['Relationship']] || rel['Relationship']?.toUpperCase() || 'CHILD';

        const fields = {
          'Case Master View': [rel['Case Master View']], // Link field
          'Object Client': [rel['Object Client']], // Link field
          'Relationship': relType,
          'Bahr Client': true,
        };

        // Add clio_contact_ids if available
        if (rel['clio_contact_id_a']) {
          fields['clio_contact_id_a'] = rel['clio_contact_id_a'];
        }
        if (rel['clio_contact_id_b']) {
          fields['clio_contact_id_b'] = rel['clio_contact_id_b'];
        }

        return { fields };
      });

      try {
        const response = await fetch(
          `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Relationships`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${airtableApiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ records: airtableRecords })
          }
        );

        if (!response.ok) {
          const errData = await response.json().catch(() => ({}));
          throw new Error(errData.error?.message || `HTTP ${response.status}`);
        }

        const result = await response.json();
        created += result.records.length;
        addPhase3Log(`Relationships batch ${Math.floor(i/10) + 1}: Created ${result.records.length} records`, 'success');

        setPhase3SyncState(prev => ({
          ...prev,
          progress: { ...prev.progress, current: i + batch.length }
        }));
      } catch (err) {
        failed += batch.length;
        addPhase3Log(`Relationships batch ${Math.floor(i/10) + 1} failed: ${err.message}`, 'error');
      }

      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 250));
    }

    setPhase3SyncState(prev => ({
      ...prev,
      loading: false,
      progress: { current: validRels.length, total: validRels.length, phase: 'Relationships Complete' }
    }));

    addPhase3Log(`Relationships upload complete: ${created} created, ${failed} failed`, created > 0 ? 'success' : 'error');
  };

  // Fetch Airtable bases
  const fetchAirtableBases = async () => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    try {
      const response = await fetch('https://api.airtable.com/v0/meta/bases', {
        headers: {
          'Authorization': `Bearer ${airtableApiKey}`,
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsBases(data.bases || []);
    } catch (err) {
      setDevToolsError(`Failed to fetch bases: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // Fetch tables for a base (schema)
  const fetchAirtableSchema = async (baseId) => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    if (!baseId) {
      setDevToolsError('Please select a base first');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    try {
      const response = await fetch(`https://api.airtable.com/v0/meta/bases/${baseId}/tables`, {
        headers: {
          'Authorization': `Bearer ${airtableApiKey}`,
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsTables(data.tables || []);
      setDevToolsSchema(data);
    } catch (err) {
      setDevToolsError(`Failed to fetch schema: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // Fetch Case Master View schema and initialize field mappings
  const fetchCaseMasterViewSchema = async () => {
    if (!airtableApiKey) {
      setCaseMasterSchema(prev => ({ ...prev, error: 'Please enter your Airtable API key first' }));
      return;
    }

    setCaseMasterSchema(prev => ({ ...prev, loading: true, error: null }));

    try {
      const response = await fetch(`https://api.airtable.com/v0/meta/bases/${AIRTABLE_BASE_ID}/tables`, {
        headers: {
          'Authorization': `Bearer ${airtableApiKey}`,
        },
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const caseMasterTable = data.tables.find(t => t.id === CASE_MASTER_VIEW_TABLE_ID);

      if (!caseMasterTable) {
        throw new Error(`Table ${CASE_MASTER_VIEW_TABLE_ID} not found in base`);
      }

      // Filter out computed field types that cannot be written to
      const COMPUTED_FIELD_TYPES = ['formula', 'rollup', 'lookup', 'count', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy'];

      const allFields = caseMasterTable.fields.map(f => ({
        id: f.id,
        name: f.name,
        type: f.type,
        options: f.options || null,
      }));

      const fields = allFields.filter(f => !COMPUTED_FIELD_TYPES.includes(f.type));
      const skippedCount = allFields.length - fields.length;

      setCaseMasterSchema({
        loading: false,
        error: null,
        fields,
        loaded: true,
      });

      // Initialize field mappings from schema with smart defaults
      // Note: PP ID is a computed field and is automatically excluded from the schema
      const defaultInputMappings = {
        'clio_matter_id': 'UniqueId',
        'Description': 'Description',
        'File Case Status': '_mapped_status',
        'Case Notes': '_aggregated_notes',
        'Bahr Client': '_constant_true',
        'Client': '_client_record_id',
        'Edit Client Info': '_client_record_id', // Link to Airtable client record
        'Matter_Flatpack': '_matter_flatpack_data',
      };

      const outputFields = {};
      fields.forEach(field => {
        outputFields[field.id] = {
          inputField: defaultInputMappings[field.name] || '',
          fieldId: field.id,
          fieldName: field.name,
          fieldType: field.type,
          enabled: defaultInputMappings[field.name] ? true : false,
        };
      });

      setPhase2FieldMapping(prev => ({
        ...prev,
        outputFields,
      }));

      addPhase2Log(`Loaded schema: ${fields.length} writable fields from Case Master View table (${skippedCount} computed fields excluded)`, 'success');

    } catch (err) {
      setCaseMasterSchema(prev => ({
        ...prev,
        loading: false,
        error: `Failed to fetch schema: ${err.message}`,
      }));
      addPhase2Log(`Schema fetch failed: ${err.message}`, 'error');
    }
  };

  // Fetch a specific record
  const fetchAirtableRecord = async () => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    if (!devToolsBaseId || !devToolsTableName || !devToolsRecordId) {
      setDevToolsError('Please provide Base ID, Table Name, and Record ID');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    setDevToolsRecord(null);
    try {
      const response = await fetch(
        `https://api.airtable.com/v0/${devToolsBaseId}/${encodeURIComponent(devToolsTableName)}/${devToolsRecordId}`,
        {
          headers: {
            'Authorization': `Bearer ${airtableApiKey}`,
          },
        }
      );
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsRecord(data);
    } catch (err) {
      setDevToolsError(`Failed to fetch record: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // Fetch records from a table (list view)
  const fetchAirtableRecords = async (maxRecords = 10) => {
    if (!airtableApiKey) {
      setDevToolsError('Please enter your Airtable API key first');
      return;
    }
    if (!devToolsBaseId || !devToolsTableName) {
      setDevToolsError('Please select a base and table first');
      return;
    }
    setDevToolsLoading(true);
    setDevToolsError(null);
    try {
      const response = await fetch(
        `https://api.airtable.com/v0/${devToolsBaseId}/${encodeURIComponent(devToolsTableName)}?maxRecords=${maxRecords}`,
        {
          headers: {
            'Authorization': `Bearer ${airtableApiKey}`,
          },
        }
      );
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setDevToolsRecord(data);
    } catch (err) {
      setDevToolsError(`Failed to fetch records: ${err.message}`);
    } finally {
      setDevToolsLoading(false);
    }
  };

  // POST case note to Xano
  const postCaseNote = async () => {
    setDevToolsLoading(true);
    setDevToolsError(null);
    setCaseNoteResult(null);
    try {
      const payload = {
        ...caseNoteData,
        Date: caseNoteData.Date ? new Date(caseNoteData.Date).getTime() / 1000 : null,
        Due_Date: null,
        tags: [],
        unix_timestamp: String(Math.floor(Date.now() / 1000)),
        time_raw: new Date().toISOString(),
      };

      const response = await fetch(XANO_CASE_NOTES_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const data = await response.json();
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${JSON.stringify(data)}`);
      }
      setCaseNoteResult({ success: true, data });
    } catch (err) {
      setCaseNoteResult({ success: false, error: err.message });
    } finally {
      setDevToolsLoading(false);
    }
  };

  const handleFileUpload = (phase, type) => (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target.result;
      const parsed = parseCSV(text);

      if (phase === 1) {
        setPhase1Files(prev => ({ ...prev, [type]: file }));
        setPhase1Data(prev => ({ ...prev, [type]: parsed }));
      } else if (phase === 2) {
        setPhase2Files(prev => ({ ...prev, [type]: file }));
        setPhase2Data(prev => ({ ...prev, [type]: parsed }));
      } else if (phase === 3) {
        setPhase3Files(prev => ({ ...prev, [type]: file }));
        setPhase3Data(prev => ({ ...prev, [type]: parsed }));
      } else if (phase === 4) {
        setPhase4Files(prev => ({ ...prev, [type]: file }));
        setPhase4Data(prev => ({ ...prev, [type]: parsed }));
      }
    };
    reader.readAsText(file);
  };

  // Clear uploaded file handlers
  const clearBahrFile = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setBahrExcelFile(null);
    setBahrSheets([]);
    setBahrMergedClients([]);
    setBahrParseReport([]);
    setBahrSelectedClient(null);
  };

  const clearOfficeCasesFile = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setOfficeCasesFile(null);
    setOfficeCasesSheets([]);
    setOfficeCasesMergedClients([]);
    setOfficeCasesParseReport([]);
  };

  const clearDocketWiseFile = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDocketWiseFile(null);
    setDocketWiseSheets([]);
    setDocketWiseRecords([]);
    setDocketWiseParseReport([]);
  };

  const clearPhase1File = (type) => (e) => {
    e.preventDefault();
    e.stopPropagation();
    setPhase1Files(prev => ({ ...prev, [type]: null }));
    setPhase1Data(prev => ({ ...prev, [type]: null }));
  };

  const clearPhase2File = (type) => (e) => {
    e.preventDefault();
    e.stopPropagation();
    setPhase2Files(prev => ({ ...prev, [type]: null }));
    setPhase2Data(prev => ({ ...prev, [type]: null }));
  };

  const clearPhase3File = (type) => (e) => {
    e.preventDefault();
    e.stopPropagation();
    setPhase3Files(prev => ({ ...prev, [type]: null }));
    setPhase3Data(prev => ({ ...prev, [type]: null }));
  };

  const clearPhase4File = (type) => (e) => {
    e.preventDefault();
    e.stopPropagation();
    setPhase4Files(prev => ({ ...prev, [type]: null }));
    setPhase4Data(prev => ({ ...prev, [type]: null }));
  };

  // Handle Bahr Excel file upload
  const handleBahrExcelUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setBahrExcelFile(file);
    setBahrSheets([]);
    setBahrMergedClients([]);
    setBahrParseReport([]);
    setBahrSelectedClient(null);

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });

        const reports = [];
        const allSheets = [];
        const allClientRecords = [];

        reports.push({ type: 'info', message: `Loaded workbook with ${workbook.SheetNames.length} sheets` });

        // Process each sheet
        workbook.SheetNames.forEach(sheetName => {
          const worksheet = workbook.Sheets[sheetName];

          // Read as raw 2D array first to have full control over header detection
          const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

          if (rawRows.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": empty, skipped` });
            return;
          }

          // Find the header row by scanning for recognizable column names
          let headerRowIdx = 0;
          for (let i = 0; i < Math.min(rawRows.length, 15); i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowValues = row.map(v => String(v || '').trim());
            if (rowLooksLikeHeaders(rowValues)) {
              headerRowIdx = i;
              break;
            }
          }

          // Build JSON data using detected header row
          const headerValues = rawRows[headerRowIdx].map(v => String(v || '').trim());
          const jsonData = [];

          for (let i = headerRowIdx + 1; i < rawRows.length; i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowObj = {};
            let hasData = false;

            headerValues.forEach((header, idx) => {
              if (header && row[idx] !== undefined && row[idx] !== null) {
                const val = String(row[idx]).trim();
                if (val !== '') {
                  rowObj[header] = val;
                  hasData = true;
                }
              }
            });

            if (hasData) {
              jsonData.push(rowObj);
            }
          }

          const headerRow = headerRowIdx;
          const detectedHeaders = headerValues.filter(h => h !== '');

          if (jsonData.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": no data after header detection, skipped` });
            return;
          }

          // Get column headers
          const headers = detectedHeaders || Object.keys(jsonData[0] || {});

          allSheets.push({
            name: sheetName,
            rowCount: jsonData.length,
            headers,
            data: jsonData,
            headerRowOffset: headerRow,
          });

          // Extract clients from this sheet
          const clientsFromSheet = parseSheetForClients(jsonData, sheetName, headerRow);
          allClientRecords.push(...clientsFromSheet);

          const headerNote = headerRow > 0 ? ` (headers in row ${headerRow + 1})` : '';

          if (clientsFromSheet.length === 0 && jsonData.length > 0) {
            // Debug: show what headers were found to help identify missing patterns
            const sampleHeaders = headers.slice(0, 8).join(', ');
            reports.push({
              type: 'warning',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, 0 clients found${headerNote}. Headers: [${sampleHeaders}...]`
            });
          } else {
            reports.push({
              type: 'success',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, ${clientsFromSheet.length} clients found${headerNote}`
            });
          }
        });

        // Merge clients across sheets
        const merged = mergeClientRecords(allClientRecords);

        const withANumber = merged.filter(c => c.aNumber).length;
        const withoutANumber = merged.filter(c => !c.aNumber).length;

        reports.push({
          type: 'info',
          message: `Merged into ${merged.length} unique clients (${withANumber} with A#, ${withoutANumber} by name only)`
        });

        setBahrSheets(allSheets);
        setBahrMergedClients(merged);
        setBahrParseReport(reports);

      } catch (err) {
        setBahrParseReport([{ type: 'error', message: `Failed to parse Excel: ${err.message}` }]);
      }
    };
    reader.readAsArrayBuffer(file);
  };

  // Handle Office CASES Excel file upload (second source)
  const handleOfficeCasesUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setOfficeCasesFile(file);
    setOfficeCasesSheets([]);
    setOfficeCasesRecords([]);
    setOfficeCasesParseReport([]);

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });

        const reports = [];
        const allSheets = [];
        const allClientRecords = [];

        reports.push({ type: 'info', message: `Loaded Office CASES workbook with ${workbook.SheetNames.length} sheets` });

        // Process each sheet (same logic as BAHR)
        workbook.SheetNames.forEach(sheetName => {
          const worksheet = workbook.Sheets[sheetName];
          const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

          if (rawRows.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": empty, skipped` });
            return;
          }

          // Find the header row by scanning for recognizable column names
          let headerRowIdx = 0;
          for (let i = 0; i < Math.min(rawRows.length, 15); i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowValues = row.map(v => String(v || '').trim());
            if (rowLooksLikeHeaders(rowValues)) {
              headerRowIdx = i;
              break;
            }
          }

          // Build JSON data using detected header row
          const headerValues = rawRows[headerRowIdx].map(v => String(v || '').trim());
          const jsonData = [];

          for (let i = headerRowIdx + 1; i < rawRows.length; i++) {
            const row = rawRows[i];
            if (!row || row.length === 0) continue;

            const rowObj = {};
            let hasData = false;

            headerValues.forEach((header, idx) => {
              if (header && row[idx] !== undefined && row[idx] !== null) {
                const val = String(row[idx]).trim();
                if (val !== '') {
                  rowObj[header] = val;
                  hasData = true;
                }
              }
            });

            if (hasData) {
              jsonData.push(rowObj);
            }
          }

          const headerRow = headerRowIdx;
          const detectedHeaders = headerValues.filter(h => h !== '');

          if (jsonData.length === 0) {
            reports.push({ type: 'warning', message: `Sheet "${sheetName}": no data after header detection, skipped` });
            return;
          }

          const headers = detectedHeaders || Object.keys(jsonData[0] || {});

          allSheets.push({
            name: sheetName,
            rowCount: jsonData.length,
            headers,
            data: jsonData,
            headerRowOffset: headerRow,
          });

          // Extract clients from this sheet - prefix sheet name with source file
          const clientsFromSheet = parseSheetForClients(jsonData, `[Office CASES] ${sheetName}`, headerRow);
          allClientRecords.push(...clientsFromSheet);

          const headerNote = headerRow > 0 ? ` (headers in row ${headerRow + 1})` : '';

          if (clientsFromSheet.length === 0 && jsonData.length > 0) {
            const sampleHeaders = headers.slice(0, 8).join(', ');
            reports.push({
              type: 'warning',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, 0 clients found${headerNote}. Headers: [${sampleHeaders}...]`
            });
          } else {
            reports.push({
              type: 'success',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, ${clientsFromSheet.length} clients found${headerNote}`
            });
          }
        });

        setOfficeCasesSheets(allSheets);
        setOfficeCasesRecords(allClientRecords);
        setOfficeCasesParseReport(reports);

      } catch (err) {
        setOfficeCasesParseReport([{ type: 'error', message: `Failed to parse Office CASES Excel: ${err.message}` }]);
      }
    };
    reader.readAsArrayBuffer(file);
  };

  // Handle DocketWise CSV/Excel file upload
  const handleDocketWiseUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setDocketWiseFile(file);
    setDocketWiseSheets([]);
    setDocketWiseRecords([]);
    setDocketWiseParseReport([]);

    const isCSV = file.name.toLowerCase().endsWith('.csv');

    if (isCSV) {
      // Parse as CSV
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const parsed = parseCSV(text);
          const reports = [];

          reports.push({ type: 'info', message: `Loaded DocketWise CSV with ${parsed.rows.length} rows` });

          // Convert CSV rows to client records format
          const allClientRecords = [];
          const sheetName = '[DocketWise] Main';

          parsed.rows.forEach((row, rowIdx) => {
            // Try to find client name and A# from DocketWise columns
            let clientName = row['full_name'] || findColumnValue(row, CLIENT_NAME_PATTERNS);
            let aNumber = null;

            // Try to extract A# from alien_registration_number column
            const rawANumber = row['alien_registration_number'] || findColumnValue(row, A_NUMBER_PATTERNS);
            if (rawANumber && rawANumber !== 'Unspecified') {
              aNumber = extractANumberFromCell(rawANumber);
            }

            // Skip if no client identifier found or name is "Unspecified"
            if ((!clientName || clientName === 'Unspecified') && !aNumber) return;
            if (clientName === 'Unspecified') clientName = null;

            // Build data object with all non-empty fields
            const data = {};
            Object.entries(row).forEach(([key, value]) => {
              if (value !== undefined && value !== null && String(value).trim() !== '' && value !== 'Unspecified') {
                data[key] = String(value).trim();
              }
            });

            allClientRecords.push({
              sheetName,
              rowIndex: rowIdx + 2, // 1-indexed + header
              clientName: clientName || '(Unknown)',
              normalizedName: normalizeClientName(clientName),
              aNumber,
              data,
            });
          });

          const withANumber = allClientRecords.filter(c => c.aNumber).length;
          reports.push({
            type: 'success',
            message: `Extracted ${allClientRecords.length} clients (${withANumber} with A#, ${allClientRecords.length - withANumber} by name only)`
          });

          setDocketWiseSheets([{
            name: 'Main',
            rowCount: parsed.rows.length,
            headers: parsed.headers,
            data: parsed.rows,
            headerRowOffset: 0,
          }]);
          setDocketWiseRecords(allClientRecords);
          setDocketWiseParseReport(reports);

        } catch (err) {
          setDocketWiseParseReport([{ type: 'error', message: `Failed to parse DocketWise CSV: ${err.message}` }]);
        }
      };
      reader.readAsText(file);
    } else {
      // Parse as Excel
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });

          const reports = [];
          const allSheets = [];
          const allClientRecords = [];

          reports.push({ type: 'info', message: `Loaded DocketWise workbook with ${workbook.SheetNames.length} sheets` });

          workbook.SheetNames.forEach(sheetName => {
            const worksheet = workbook.Sheets[sheetName];
            const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

            if (rawRows.length === 0) {
              reports.push({ type: 'warning', message: `Sheet "${sheetName}": empty, skipped` });
              return;
            }

            // Find header row
            let headerRowIdx = 0;
            for (let i = 0; i < Math.min(rawRows.length, 15); i++) {
              const row = rawRows[i];
              if (!row || row.length === 0) continue;
              const rowValues = row.map(v => String(v || '').trim());
              // Look for DocketWise-specific headers
              if (rowValues.some(v => v.toLowerCase() === 'full_name' || v.toLowerCase() === 'alien_registration_number') || rowLooksLikeHeaders(rowValues)) {
                headerRowIdx = i;
                break;
              }
            }

            const headerValues = rawRows[headerRowIdx].map(v => String(v || '').trim());
            const jsonData = [];

            for (let i = headerRowIdx + 1; i < rawRows.length; i++) {
              const row = rawRows[i];
              if (!row || row.length === 0) continue;

              const rowObj = {};
              let hasData = false;

              headerValues.forEach((header, idx) => {
                if (header && row[idx] !== undefined && row[idx] !== null) {
                  const val = String(row[idx]).trim();
                  if (val !== '' && val !== 'Unspecified') {
                    rowObj[header] = val;
                    hasData = true;
                  }
                }
              });

              if (hasData) {
                jsonData.push(rowObj);
              }
            }

            if (jsonData.length === 0) {
              reports.push({ type: 'warning', message: `Sheet "${sheetName}": no data, skipped` });
              return;
            }

            const headers = headerValues.filter(h => h !== '');
            allSheets.push({
              name: sheetName,
              rowCount: jsonData.length,
              headers,
              data: jsonData,
              headerRowOffset: headerRowIdx,
            });

            // Extract clients - prefix with [DocketWise]
            const clientsFromSheet = parseSheetForClients(jsonData, `[DocketWise] ${sheetName}`, headerRowIdx);
            allClientRecords.push(...clientsFromSheet);

            reports.push({
              type: 'success',
              message: `Sheet "${sheetName}": ${jsonData.length} rows, ${clientsFromSheet.length} clients found`
            });
          });

          setDocketWiseSheets(allSheets);
          setDocketWiseRecords(allClientRecords);
          setDocketWiseParseReport(reports);

        } catch (err) {
          setDocketWiseParseReport([{ type: 'error', message: `Failed to parse DocketWise Excel: ${err.message}` }]);
        }
      };
      reader.readAsArrayBuffer(file);
    }
  };

  // Combine and merge clients from all data sources
  const combinedMergedClients = React.useMemo(() => {
    // Start with BAHR records - we need the raw records, not merged ones
    // So we need to rebuild from bahrSheets
    const allRecords = [];

    // Extract records from BAHR sheets
    bahrSheets.forEach(sheet => {
      const clientsFromSheet = parseSheetForClients(sheet.data, `[BAHR] ${sheet.name}`, sheet.headerRowOffset);
      allRecords.push(...clientsFromSheet);
    });

    // Add Office CASES records (already have source prefix)
    allRecords.push(...officeCasesRecords);

    // Add DocketWise records (already have source prefix)
    allRecords.push(...docketWiseRecords);

    if (allRecords.length === 0) return [];

    // Merge all records together
    return mergeClientRecords(allRecords);
  }, [bahrSheets, officeCasesRecords, docketWiseRecords]);

  // Generate flattened output for export
  const generateBahrFlattenedOutput = () => {
    const output = [];

    combinedMergedClients.forEach(client => {
      // Add client header row
      output.push({
        type: 'client',
        clientName: client.primaryName,
        aNumber: client.aNumber || '',
        sheetCount: Object.keys(client.sheetData).length,
        recordCount: client.recordCount,
        allNames: client.names.join('; '),
      });

      // Add data rows for each sheet
      Object.entries(client.sheetData).forEach(([sheetName, records]) => {
        records.forEach(record => {
          Object.entries(record.data).forEach(([key, value]) => {
            // Skip client identifier fields (already in header)
            if (CLIENT_NAME_COLUMNS.includes(key) || A_NUMBER_COLUMNS.includes(key) || MATTER_COLUMNS.includes(key)) {
              return;
            }
            output.push({
              type: 'data',
              clientName: client.primaryName,
              aNumber: client.aNumber || '',
              sheetName,
              rowIndex: record.rowIndex,
              fieldName: key,
              fieldValue: value,
            });
          });
        });
      });
    });

    return output;
  };

  // Download client data as JSON with records organized by sheet/tab name
  const downloadBahrFlattenedCSV = () => {
    const clientsJson = combinedMergedClients.map(client => {
      const clientObj = {
        clientName: client.primaryName,
        aNumber: client.aNumber || '',
        allNames: client.names,
      };

      // Add records for each sheet, using sheet name as the key
      Object.entries(client.sheetData).forEach(([sheetName, records]) => {
        clientObj[sheetName] = records.map(record => record.data);
      });

      return clientObj;
    });

    const json = JSON.stringify(clientsJson, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'combined_client_data.json';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Download client summary as CSV
  const downloadBahrClientSummary = () => {
    const headers = ['Client Name', 'A#', 'Sheets Found In', 'Record Count', 'All Name Variants'];
    const rows = combinedMergedClients.map(client => ({
      'Client Name': client.primaryName,
      'A#': client.aNumber || '',
      'Sheets Found In': Object.keys(client.sheetData).join('; '),
      'Record Count': client.recordCount,
      'All Name Variants': client.names.join('; '),
    }));

    const csv = generateCSV(headers, rows);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'combined_client_summary.csv';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Phase 1: Client Import
  // Helper to find a value in sheet data by trying multiple column name patterns
  const findFieldInSheetData = (sheetData, patterns) => {
    for (const [sheetName, records] of Object.entries(sheetData)) {
      for (const record of records) {
        for (const [key, value] of Object.entries(record.data || {})) {
          const normalizedKey = normalizeColumnName(key);
          for (const pattern of patterns) {
            if (normalizedKey === pattern || normalizedKey.includes(pattern)) {
              if (value && String(value).trim()) {
                return String(value).trim();
              }
            }
          }
        }
      }
    }
    return '';
  };

  // Field patterns for extracting demographics from sheet data
  const FIELD_PATTERNS = {
    firstName: ['first name', 'firstname', 'given name', 'nombre', 'primer nombre'],
    lastName: ['last name', 'lastname', 'family name', 'surname', 'apellido', 'apellidos'],
    middleName: ['middle name', 'middlename', 'segundo nombre'],
    dob: ['dob', 'date of birth', 'birthdate', 'birth date', 'date_of_birth', 'fecha de nacimiento'],
    phone: [
      'phone', 'telephone', 'telphone', 'cell', 'mobile', 'telefono', 'celular',
      'home phone', 'work phone', 'business phone', 'primary phone', 'mobile phone',
      'cell phone', 'other phone', 'phone number', 'phone 1', 'phone 2', 'phone1', 'phone2',
      'daytime phone', 'evening phone', 'contact phone', 'alternate phone', 'alt phone',
      'fax', 'tel', 'numero de telefono', 'número de teléfono', 'tel movil', 'tel casa'
    ],
    email: ['email', 'e-mail', 'correo', 'correo electronico'],
    addressLine1: ['street', 'address', 'street number and name', 'direccion', 'calle'],
    addressLine2: ['address line 2', 'apt', 'suite', 'unit', 'apartamento'],
    city: ['city', 'ciudad'],
    state: ['state', 'estado', 'province'],
    zip: ['zip', 'zipcode', 'postal', 'codigo postal'],
    country: ['country', 'citizenship', 'nationality', 'pais', 'nacionalidad', '18.a'],
    entryDate: ['entry date', 'arrival', 'date of last arrival', '22.'],
    placeOfEntry: ['place of entry', 'place of last arrival', 'port of entry', '23.'],
  };

  // Check if a value looks like a phone number (10+ digits) vs A# (9 digits)
  // A# format: xxx-xxx-xxx (9 digits), Phone format: xxx-xxx-xxxx (10 digits)
  const isLikelyPhoneNumber = (value) => {
    if (!value) return false;
    const digits = String(value).replace(/\D/g, '');
    // Phone numbers have 10+ digits (US), A# has exactly 9
    // Also accept 11 digits (country code + 10)
    if (digits.length >= 10) return true;
    // 7 digits could be a local number without area code
    if (digits.length === 7) return true;
    // Exactly 9 digits is likely an A#, not a phone
    if (digits.length === 9) return false;
    return false;
  };

  // Check if a column name looks like an A# column (to exclude from phone search)
  const isANumberColumn = (columnName) => {
    const normalized = normalizeColumnName(columnName);
    return A_NUMBER_PATTERNS.some(pattern =>
      normalized === pattern || normalized.includes(pattern)
    );
  };

  // Specialized phone extractor that checks all phone-like columns and validates values
  const findPhoneInSheetData = (sheetData) => {
    const phoneValues = [];

    for (const [sheetName, records] of Object.entries(sheetData)) {
      for (const record of records) {
        for (const [key, value] of Object.entries(record.data || {})) {
          if (!value || !String(value).trim()) continue;

          const normalizedKey = normalizeColumnName(key);

          // Skip if this column is an A# column
          if (isANumberColumn(key)) continue;

          // Check if column matches phone patterns
          const isPhoneColumn = FIELD_PATTERNS.phone.some(pattern =>
            normalizedKey === pattern || normalizedKey.includes(pattern)
          );

          if (isPhoneColumn) {
            const strValue = String(value).trim();
            // Validate it looks like a phone number, not an A#
            if (isLikelyPhoneNumber(strValue)) {
              phoneValues.push(strValue);
            }
          }
        }
      }
    }

    // Return first valid phone found
    return phoneValues.length > 0 ? phoneValues[0] : '';
  };

  const runPhase1 = useCallback(() => {
    const reports = [];
    const bahrLookup = new Map();
    const clientsOutput = [];

    let validANumbers = 0;
    let invalidANumbers = 0;
    let missingANumbers = 0;

    if (combinedMergedClients.length === 0) {
      reports.push({ type: 'warning', message: 'No clients loaded from Phase 0. Please upload and parse Excel files first.' });
      setPhase1Result(null);
      setPhase1Report(reports);
      return;
    }

    reports.push({ type: 'info', message: `Processing ${combinedMergedClients.length} clients from Phase 0 data (combined from all Excel files)` });

    // Build client records from combinedMergedClients
    combinedMergedClients.forEach((client, idx) => {
      // Parse name from primaryName (usually "Last, First" or "First Last")
      let firstName = '';
      let lastName = '';
      let middleName = '';
      const name = client.primaryName || '';

      if (name.includes(',')) {
        // "Last, First Middle" format
        const parts = name.split(',').map(p => p.trim());
        lastName = parts[0] || '';
        const firstParts = (parts[1] || '').split(' ');
        firstName = firstParts[0] || '';
        middleName = firstParts.slice(1).join(' ');
      } else {
        // "First Last" format - try to find from sheet data first
        firstName = findFieldInSheetData(client.sheetData, FIELD_PATTERNS.firstName);
        lastName = findFieldInSheetData(client.sheetData, FIELD_PATTERNS.lastName);
        middleName = findFieldInSheetData(client.sheetData, FIELD_PATTERNS.middleName);

        // Fallback: split the name intelligently for Spanish names
        // Spanish naming convention: FirstName [MiddleName] PatronymicLastName MatronymicLastName
        // e.g., "Aaron Alberto Villareal Tomasini" -> First: "Aaron Alberto", Last: "Villareal Tomasini"
        if (!firstName && !lastName) {
          const parts = name.split(' ').filter(p => p.length > 0);
          if (parts.length >= 5) {
            // 5+ words: take first 2 as given names, rest as family names
            firstName = parts[0];
            middleName = parts[1];
            lastName = parts.slice(2).join(' ');
          } else if (parts.length === 4) {
            // 4 words: likely "First Middle PatronymicLast MatronymicLast"
            firstName = parts[0];
            middleName = parts[1];
            lastName = parts.slice(2).join(' ');
          } else if (parts.length === 3) {
            // 3 words: "First Last1 Last2" or "First Middle Last"
            firstName = parts[0];
            lastName = parts.slice(1).join(' ');
          } else if (parts.length >= 2) {
            firstName = parts[0];
            lastName = parts.slice(1).join(' ');
          } else {
            lastName = name;
          }
        }
      }

      // Extract other fields from sheet data (normalize dates to YYYY-MM-DD)
      const dob = normalizeDate(findFieldInSheetData(client.sheetData, FIELD_PATTERNS.dob));
      const rawANumber = client.aNumber || '';
      const aNumberResult = normalizeANumber(rawANumber);
      const nameKey = normalizeName(lastName, firstName);

      let aNumberStatus = '';
      if (aNumberResult.isValid) {
        aNumberStatus = 'valid';
        validANumbers++;
      } else if (!rawANumber) {
        aNumberStatus = 'missing';
        missingANumbers++;
      } else {
        aNumberStatus = 'invalid';
        invalidANumbers++;
        reports.push({
          type: 'warning',
          message: `${firstName} ${lastName}: Invalid A# "${rawANumber}"`
        });
      }

      // Build flatpack data object for uscis_flatpack_data field
      const flatpackData = {};
      Object.entries(client.sheetData).forEach(([sheetName, records]) => {
        flatpackData[sheetName] = records.map(record => record.data);
      });

      const flatpackObj = {
        clientName: client.primaryName,
        aNumber: client.aNumber || '',
        allNames: client.names,
        ...flatpackData
      };

      // Always generate Client ID (never use A# as ID)
      const generatedClientId = generateFallbackId(lastName, firstName, dob) || `PENDING-${idx}`;

      const record = {
        _nameKey: nameKey,
        _clientId: generatedClientId,
        _aNumberStatus: aNumberStatus,
        _flatpackData: flatpackObj,
        lastName,
        firstName,
        middleName,
        aNumber: aNumberResult.isValid ? aNumberResult.normalized : '',
        phone: findPhoneInSheetData(client.sheetData),
        email: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.email),
        addressLine1: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.addressLine1),
        addressLine2: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.addressLine2),
        state: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.state),
        city: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.city),
        zip: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.zip),
        country: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.country),
        entryDate: normalizeDate(findFieldInSheetData(client.sheetData, FIELD_PATTERNS.entryDate)),
        placeOfEntry: findFieldInSheetData(client.sheetData, FIELD_PATTERNS.placeOfEntry),
        dob: dob,
        clioContactId: '', // Will be populated from Clio Contacts
      };

      // Store under multiple name keys for flexible matching
      bahrLookup.set(nameKey, record);
      // Also store with firstName+middleName combined (handles Clio having full first name)
      if (middleName) {
        const fullFirstNameKey = normalizeName(lastName, `${firstName} ${middleName}`);
        if (!bahrLookup.has(fullFirstNameKey)) {
          bahrLookup.set(fullFirstNameKey, record);
        }
      }
      // Also store with last name only for last-name-only fallback matching
      const lastNameOnlyKey = `LASTNAME_ONLY:${normalizeName(lastName, '').split('|')[0]}`;
      if (!bahrLookup.has(lastNameOnlyKey)) {
        bahrLookup.set(lastNameOnlyKey, record);
      } else {
        // Mark as ambiguous if multiple records have same last name
        bahrLookup.set(lastNameOnlyKey, 'AMBIGUOUS');
      }
      // Store with condensed last name (no spaces) for "De Leon" vs "DeLeon" matching
      const condensedLastName = lastName.replace(/\s+/g, '');
      if (condensedLastName !== lastName) {
        const condensedKey = normalizeName(condensedLastName, firstName);
        if (!bahrLookup.has(condensedKey)) {
          bahrLookup.set(condensedKey, record);
        }
      }
      // Store with first word of last name only (handles "Villareal" vs "Villareal Tomasini")
      if (lastName.includes(' ')) {
        const firstLastWord = lastName.split(' ')[0];
        const firstLastWordKey = normalizeName(firstLastWord, firstName);
        if (!bahrLookup.has(firstLastWordKey)) {
          bahrLookup.set(firstLastWordKey, record);
        }
        // Also with fullFirstName
        if (middleName) {
          const firstLastWordFullFirstKey = normalizeName(firstLastWord, `${firstName} ${middleName}`);
          if (!bahrLookup.has(firstLastWordFullFirstKey)) {
            bahrLookup.set(firstLastWordFullFirstKey, record);
          }
        }
      }
    });

    const uniqueClientCount = combinedMergedClients.length;
    reports.push({ type: 'info', message: `Built ${uniqueClientCount} client records from Phase 0 data (${bahrLookup.size} lookup keys)` });
    reports.push({
      type: validANumbers === uniqueClientCount ? 'success' : 'warning',
      message: `A# Validation: ${validANumbers} valid, ${invalidANumbers} malformed, ${missingANumbers} missing`
    });

    // Enrich with Clio Contacts
    let contactMatches = 0;
    let contactMisses = 0;
    const unmatchedClioSamples = [];
    const matchedSamples = [];

    if (phase1Data.clioContacts?.rows) {
      phase1Data.clioContacts.rows.forEach((row) => {
        const lastName = row['Last Name'] || '';
        const firstName = row['First Name'] || '';
        const nameKey = normalizeName(lastName, firstName);

        // Try exact match first
        let record = bahrLookup.get(nameKey);
        let matchType = 'exact';

        // Fallback 1: try first word only of firstName (handles "Juan Carlos" vs "Juan")
        if (!record && firstName.includes(' ')) {
          const firstWordOnly = firstName.split(' ')[0];
          const firstWordKey = normalizeName(lastName, firstWordOnly);
          record = bahrLookup.get(firstWordKey);
          matchType = 'first-word';
        }

        // Fallback 2: try condensed last name (no spaces) for "De Leon" vs "DeLeon"
        if (!record) {
          const condensedLastName = lastName.replace(/\s+/g, '');
          if (condensedLastName !== lastName) {
            const condensedKey = normalizeName(condensedLastName, firstName);
            record = bahrLookup.get(condensedKey);
            matchType = 'condensed-lastname';
          }
        }

        // Fallback 3: try last word of firstName (in case BAHR has "Alberto" but Clio has "Aaron Alberto")
        if (!record && firstName.includes(' ')) {
          const words = firstName.split(' ');
          const lastWordOnly = words[words.length - 1];
          const lastWordKey = normalizeName(lastName, lastWordOnly);
          record = bahrLookup.get(lastWordKey);
          matchType = 'last-word';
        }

        // Fallback 4: try each word of firstName
        if (!record && firstName.includes(' ')) {
          const words = firstName.split(' ');
          for (const word of words) {
            const wordKey = normalizeName(lastName, word);
            record = bahrLookup.get(wordKey);
            if (record) {
              matchType = 'any-word';
              break;
            }
          }
        }

        // Fallback 5: try first word of lastName only (handles "Villareal" vs "Villareal Tomasini")
        if (!record && lastName.includes(' ')) {
          const firstLastWord = lastName.split(' ')[0];
          const firstLastWordKey = normalizeName(firstLastWord, firstName);
          record = bahrLookup.get(firstLastWordKey);
          matchType = 'first-lastname-word';

          // Also try first word with first-word-only firstName
          if (!record && firstName.includes(' ')) {
            const firstWordOnly = firstName.split(' ')[0];
            const combinedKey = normalizeName(firstLastWord, firstWordOnly);
            record = bahrLookup.get(combinedKey);
            matchType = 'first-lastname-first-firstname';
          }
        }

        // Fallback 6: last name only match (only if unique in BAHR)
        if (!record) {
          const lastNameOnlyKey = `LASTNAME_ONLY:${normalizeName(lastName, '').split('|')[0]}`;
          const lastNameResult = bahrLookup.get(lastNameOnlyKey);
          if (lastNameResult && lastNameResult !== 'AMBIGUOUS') {
            record = lastNameResult;
            matchType = 'lastname-only';
          }
        }

        if (record) {
          // Phone enrichment - priority: Mobile > Primary > Home > Business > Other > Business2 > Home2
          if (!record.phone) {
            record.phone = row['Mobile Phone'] || row['Primary Phone'] || row['Home Phone'] || row['Business Phone'] || row['Other Phone'] || row['Business Phone 2'] || row['Home Phone 2'] || '';
          }

          // Email enrichment - with fallback to secondary email
          if (!record.email) {
            record.email = row['E-mail Address'] || row['E-mail 2 Address'] || '';
          }

          // Address enrichment from Clio - check all address types since users may have used any field
          // Priority: Home > Business > Billing > Other
          if (!record.addressLine1) {
            record.addressLine1 = row['Home Street'] || row['Business Street'] || row['Billing Street'] || row['Other Street'] || '';
          }
          if (!record.addressLine2) {
            record.addressLine2 = row['Home Street 2'] || row['Business Street 2'] || row['Billing Street 2'] || row['Other Street 2'] || '';
          }
          if (!record.city) {
            record.city = row['Home City'] || row['Business City'] || row['Billing City'] || row['Other City'] || '';
          }
          if (!record.state) {
            const rawState = row['Home State'] || row['Business State'] || row['Billing State'] || row['Other State'] || '';
            record.state = rawState ? rawState.trim().toUpperCase() : '';
          }
          if (!record.zip) {
            const rawZip = row['Home Postal Code'] || row['Business Postal Code'] || row['Billing Postal Code'] || row['Other Postal Code'] || '';
            // Extract first 5 digits for standard US zip format
            if (rawZip) {
              const match = rawZip.match(/\d{5}/);
              record.zip = match ? match[0] : rawZip.replace(/\D/g, '').slice(0, 5);
            }
          }
          if (!record.country) {
            record.country = row['Home Country/Region'] || row['Business Country/Region'] || row['Billing Country/Region'] || row['Other Country/Region'] || '';
          }

          // DOB enrichment from Clio Birthday field (normalize to YYYY-MM-DD)
          if (!record.dob && row['Birthday']) {
            record.dob = normalizeDate(row['Birthday']);
          }

          record.clioContactId = row['UniqueId'] || '';
          contactMatches++;
          if (matchedSamples.length < 5) {
            matchedSamples.push({ clio: `${lastName}, ${firstName}`, bahr: record._nameKey, type: matchType });
          }
        } else {
          contactMisses++;
          if (unmatchedClioSamples.length < 20) {
            unmatchedClioSamples.push({ lastName, firstName, nameKey });
          }
        }
      });

      reports.push({ type: 'info', message: `Matched ${contactMatches} Clio contacts, ${contactMisses} unmatched` });

      // Debug: show sample matches
      if (matchedSamples.length > 0) {
        reports.push({ type: 'success', message: `Sample matches:` });
        matchedSamples.forEach(s => {
          reports.push({ type: 'info', message: `  ✓ Clio "${s.clio}" → BAHR key "${s.bahr}" (${s.type})` });
        });
      }

      // Debug: show sample unmatched Clio contacts
      if (unmatchedClioSamples.length > 0) {
        reports.push({ type: 'warning', message: `Sample unmatched Clio contacts (showing ${unmatchedClioSamples.length}):` });
        unmatchedClioSamples.forEach(s => {
          reports.push({ type: 'info', message: `  ✗ "${s.lastName}, ${s.firstName}" → key "${s.nameKey}"` });
        });
      }

      // Debug: show sample BAHR keys for comparison
      const bahrKeysSample = Array.from(bahrLookup.keys()).slice(0, 20);
      reports.push({ type: 'info', message: `Sample BAHR lookup keys (${bahrLookup.size} total):` });
      bahrKeysSample.forEach(k => {
        const rec = bahrLookup.get(k);
        reports.push({ type: 'info', message: `  BAHR: "${rec.lastName}, ${rec.firstName}" → key "${k}"` });
      });
    }

    // Build output - deduplicate since same record is stored under multiple keys
    const outputtedRecords = new Set();
    bahrLookup.forEach((record) => {
      // Skip 'AMBIGUOUS' markers and already-output records
      if (record === 'AMBIGUOUS' || outputtedRecords.has(record._clientId)) {
        return;
      }
      outputtedRecords.add(record._clientId);
      clientsOutput.push({
        'Client ID': record._clientId,
        'A#': record.aNumber,
        'First Name': record.firstName,
        'Middle Name': record.middleName,
        'Family Name': record.lastName,
        'Phone Number': record.phone,
        'Client Email': record.email,
        'Address Line 1': record.addressLine1,
        'Address Line 2': record.addressLine2,
        'City': record.city,
        'State': record.state,
        'Zip (5)': record.zip,
        'Country': record.country,
        'Entry Date': record.entryDate,
        'Place of Entry': record.placeOfEntry,
        'DOB': record.dob,
        'clio_contact_id': record.clioContactId,
        'Bahr Client': 'TRUE',
        'uscis_flatpack_data': JSON.stringify(record._flatpackData),
      });
    });

    setPhase1Result({ clients: clientsOutput });
    setPhase1Report(reports);
  }, [phase1Data, combinedMergedClients]);

  // Phase 2 Airtable fetch helpers
  const addPhase2Log = (message, type = 'info') => {
    setPhase2Sync(prev => ({
      ...prev,
      logs: [...prev.logs, { message, type, time: new Date().toLocaleTimeString() }]
    }));
  };

  // Fetch Client Info records from Airtable for Phase 2
  const fetchPhase2Clients = async () => {
    if (!airtableApiKey || !devToolsBaseId) {
      addPhase2Log('Please enter API key and Base ID in Phase 1 first', 'error');
      return;
    }

    setPhase2Sync(prev => ({ ...prev, loading: true, logs: [] }));
    addPhase2Log('Fetching Client Info records from Airtable...', 'info');

    try {
      const allRecords = [];
      let offset = null;

      do {
        const url = offset
          ? `https://api.airtable.com/v0/${devToolsBaseId}/Client%20Info?offset=${offset}`
          : `https://api.airtable.com/v0/${devToolsBaseId}/Client%20Info`;

        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${airtableApiKey}` }
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        allRecords.push(...data.records);
        offset = data.offset;

        setPhase2Sync(prev => ({
          ...prev,
          progress: { current: allRecords.length, total: allRecords.length, phase: 'Fetching...' }
        }));
        addPhase2Log(`Fetched ${allRecords.length} records...`, 'info');
      } while (offset);

      // Convert to the format expected by runPhase2 (matching CSV structure)
      const rows = allRecords.map(rec => ({
        'Record ID': rec.id,
        'clio_contact_id': rec.fields['clio_contact_id'] || '',
        'Client ID': rec.fields['Client ID'] || '',
        'A#': rec.fields['A#'] || '',
        'First Name': rec.fields['First Name'] || '',
        'Family Name': rec.fields['Family Name'] || '',
      }));

      // Update phase2Data with fetched records
      setPhase2Data(prev => ({
        ...prev,
        airtableClients: { rows, headers: ['Record ID', 'clio_contact_id', 'Client ID', 'A#', 'First Name', 'Family Name'] }
      }));

      setPhase2Sync(prev => ({
        ...prev,
        loading: false,
        fetchedClients: allRecords,
        progress: { current: allRecords.length, total: allRecords.length, phase: 'Complete' }
      }));

      // Stats
      const withClio = allRecords.filter(r => r.fields['clio_contact_id']).length;
      const withANum = allRecords.filter(r => r.fields['A#']).length;
      addPhase2Log(`Total: ${allRecords.length} clients fetched from Airtable`, 'success');
      addPhase2Log(`  ${withClio} with clio_contact_id, ${withANum} with A#`, 'info');
    } catch (err) {
      addPhase2Log(`Error: ${err.message}`, 'error');
      setPhase2Sync(prev => ({ ...prev, loading: false }));
    }
  };

  // Create missing client records in Airtable for Phase 2
  // Returns a map of clio_contact_id -> Airtable Record ID for newly created records
  const createMissingClientsInAirtable = async (missingClients) => {
    const createdRecords = new Map();

    if (!missingClients || missingClients.length === 0) {
      return createdRecords;
    }

    if (!airtableApiKey || !devToolsBaseId) {
      addPhase2Log('Cannot create clients: API key or Base ID not configured', 'error');
      return createdRecords;
    }

    addPhase2Log(`Creating ${missingClients.length} missing client records in Airtable...`, 'info');

    setPhase2Sync(prev => ({
      ...prev,
      loading: true,
      progress: { current: 0, total: missingClients.length, phase: 'Creating Client Records' }
    }));

    let created = 0;
    let failed = 0;

    // Process in batches of 10 (Airtable API limit)
    for (let i = 0; i < missingClients.length; i += 10) {
      const batch = missingClients.slice(i, i + 10);

      const airtableRecords = batch.map(client => ({
        fields: {
          'clio_contact_id': client.clientId,
          'Bahr Client': true,
          // Add client name if we have it (may be combined first/last or just a name)
          ...(client.clientName ? { 'Family Name': client.clientName } : {})
        }
      }));

      try {
        const response = await fetch(
          `https://api.airtable.com/v0/${devToolsBaseId}/Client%20Info`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${airtableApiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ records: airtableRecords })
          }
        );

        if (!response.ok) {
          const errData = await response.json().catch(() => ({}));
          throw new Error(errData.error?.message || `HTTP ${response.status}`);
        }

        const result = await response.json();

        // Map the created records back to their clio_contact_ids
        result.records.forEach((record, idx) => {
          const clioContactId = batch[idx].clientId;
          const recordId = record.id;
          createdRecords.set(clioContactId, recordId);
        });

        created += result.records.length;
        addPhase2Log(`Batch ${Math.floor(i/10) + 1}: Created ${result.records.length} client records`, 'success');

        setPhase2Sync(prev => ({
          ...prev,
          progress: { ...prev.progress, current: i + batch.length }
        }));
      } catch (err) {
        failed += batch.length;
        addPhase2Log(`Batch ${Math.floor(i/10) + 1} failed: ${err.message}`, 'error');
      }

      // Rate limiting: 250ms between batches
      await new Promise(resolve => setTimeout(resolve, 250));
    }

    setPhase2Sync(prev => ({
      ...prev,
      loading: false,
      progress: { current: missingClients.length, total: missingClients.length, phase: 'Client Creation Complete' }
    }));

    addPhase2Log(`Client creation complete: ${created} created, ${failed} failed`, created > 0 ? 'success' : 'error');

    return createdRecords;
  };

  // Phase 2: Case Master Views
  const runPhase2 = useCallback(async () => {
    const reports = [];

    // Set loading state
    setPhase2Sync(prev => ({ ...prev, loading: true }));

    try {
    // Build clio_contact_id -> Airtable Record ID lookup from Airtable export
    const clioContactToRecordId = new Map();
    const clientIdToRecordId = new Map();

    if (phase2Data.airtableClients?.rows) {
      phase2Data.airtableClients.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || row['Airtable Record ID'] || '';
        const clioContactId = String(row['clio_contact_id'] || '').trim();
        const clientId = row['Client ID'] || row['A#'] || '';

        if (clioContactId && recordId) {
          clioContactToRecordId.set(clioContactId, recordId);
        }
        if (clientId && recordId) {
          clientIdToRecordId.set(String(clientId).trim(), recordId);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioContactToRecordId.size} clio_contact_id → Record ID mappings from Airtable (${phase2Data.airtableClients.rows.length} total rows)` });
      // Show sample mapping for debugging
      if (clioContactToRecordId.size > 0) {
        const sampleEntries = Array.from(clioContactToRecordId.entries()).slice(0, 2);
        reports.push({ type: 'info', message: `Sample Airtable clio_contact_id values: ${sampleEntries.map(([k, v]) => `"${k}" → ${v}`).join(', ')}` });
      } else {
        // Show what columns are available in the Airtable export for debugging
        const sampleRow = phase2Data.airtableClients.rows[0];
        if (sampleRow) {
          const columns = Object.keys(sampleRow).join(', ');
          reports.push({ type: 'warning', message: `No clio_contact_id mappings found. Available columns: ${columns}` });
        }
      }
    }

    // Build MatterId -> Matter info lookup from Clio Matters
    const mattersLookup = new Map();

    // Try multiple possible field names for clio_id in Clio export
    const CLIO_ID_FIELD_NAMES = ['clio_id', 'Client.id', 'ClientId', 'Client ID', 'clio_contact_id', 'Contact ID', 'ContactId'];
    let detectedClioIdField = null;
    let clioMattersColumns = [];

    if (phase2Data.clioMatters?.rows) {
      // First, detect which field name is being used for the client ID
      const sampleRow = phase2Data.clioMatters.rows[0];
      if (sampleRow) {
        clioMattersColumns = Object.keys(sampleRow);
        reports.push({ type: 'info', message: `Clio Matters columns: ${clioMattersColumns.join(', ')}` });

        // Find the first matching field name that has values
        for (const fieldName of CLIO_ID_FIELD_NAMES) {
          if (clioMattersColumns.includes(fieldName)) {
            // Check if this field has actual values
            const hasValues = phase2Data.clioMatters.rows.some(row => row[fieldName] && String(row[fieldName]).trim());
            if (hasValues) {
              detectedClioIdField = fieldName;
              reports.push({ type: 'info', message: `Using field "${fieldName}" for client ID matching` });
              break;
            }
          }
        }

        if (!detectedClioIdField) {
          reports.push({ type: 'warning', message: `No client ID field found in Clio export. Looked for: ${CLIO_ID_FIELD_NAMES.join(', ')}` });
        }
      }

      phase2Data.clioMatters.rows.forEach((row) => {
        const matterId = row['UniqueId'] || '';
        // Use detected field name, or try all possibilities
        let clientId = '';
        if (detectedClioIdField) {
          clientId = String(row[detectedClioIdField] || '').trim();
        } else {
          // Fallback: try all possible field names
          for (const fieldName of CLIO_ID_FIELD_NAMES) {
            if (row[fieldName]) {
              clientId = String(row[fieldName]).trim();
              break;
            }
          }
        }
        const displayNumber = row['DisplayNumber'] || '';
        const description = row['Description'] || '';
        const client = row['Client'] || '';
        const status = row['Status'] || '';
        const openDate = row['OpenDate'] || '';
        const closeDate = row['CloseDate'] || '';

        if (matterId) {
          mattersLookup.set(matterId, {
            matterId,
            clientId, // This is the clio_contact_id used for Airtable linking
            displayNumber,
            description,
            clientName: client,
            status,
            openDate,
            closeDate,
            notes: [],
          });
        }
      });
      reports.push({ type: 'info', message: `Loaded ${mattersLookup.size} matters from Clio Matters` });
      // Show sample ClientId values for comparison with clio_contact_id
      if (mattersLookup.size > 0) {
        const sampleMatters = Array.from(mattersLookup.values()).slice(0, 2);
        const hasClientIds = sampleMatters.some(m => m.clientId);
        reports.push({ type: hasClientIds ? 'info' : 'warning', message: `Sample Clio client ID values: ${sampleMatters.map(m => m.clientId ? `"${m.clientId}"` : '(empty)').join(', ')}` });
      }
    }

    // Aggregate notes by MatterId
    let notesMatched = 0;
    let notesUnmatched = 0;

    // Try multiple possible field names for matter ID in notes
    const NOTE_MATTER_ID_FIELDS = ['MatterId', 'Matter.id', 'Matter ID', 'matter_id', 'UniqueId', 'Matter'];
    let detectedNoteMatterIdField = null;
    let clioNotesColumns = [];

    if (phase2Data.clioNotes?.rows) {
      // First, detect which field name is being used for the matter ID in notes
      const sampleNoteRow = phase2Data.clioNotes.rows[0];
      if (sampleNoteRow) {
        clioNotesColumns = Object.keys(sampleNoteRow);
        reports.push({ type: 'info', message: `Clio Notes columns: ${clioNotesColumns.join(', ')}` });

        // Find the first matching field name that has values matching matters
        for (const fieldName of NOTE_MATTER_ID_FIELDS) {
          if (clioNotesColumns.includes(fieldName)) {
            // Check if this field has values that match matter IDs
            const hasMatchingValues = phase2Data.clioNotes.rows.some(row => {
              const noteId = String(row[fieldName] || '').trim();
              return noteId && mattersLookup.has(noteId);
            });
            if (hasMatchingValues) {
              detectedNoteMatterIdField = fieldName;
              reports.push({ type: 'info', message: `Using field "${fieldName}" for note-to-matter matching` });
              break;
            }
          }
        }

        if (!detectedNoteMatterIdField) {
          // Still try to find a field with values even if no matches
          for (const fieldName of NOTE_MATTER_ID_FIELDS) {
            if (clioNotesColumns.includes(fieldName)) {
              const hasValues = phase2Data.clioNotes.rows.some(row => row[fieldName] && String(row[fieldName]).trim());
              if (hasValues) {
                detectedNoteMatterIdField = fieldName;
                reports.push({ type: 'warning', message: `Using field "${fieldName}" for notes but no matching matter IDs found` });
                break;
              }
            }
          }
        }

        if (!detectedNoteMatterIdField) {
          reports.push({ type: 'warning', message: `No matter ID field found in Clio Notes. Looked for: ${NOTE_MATTER_ID_FIELDS.join(', ')}` });
        }
      }

      phase2Data.clioNotes.rows.forEach((row) => {
        // Use detected field name or try all possibilities
        let matterId = '';
        if (detectedNoteMatterIdField) {
          matterId = String(row[detectedNoteMatterIdField] || '').trim();
        } else {
          for (const fieldName of NOTE_MATTER_ID_FIELDS) {
            if (row[fieldName]) {
              matterId = String(row[fieldName]).trim();
              break;
            }
          }
        }
        const subject = row['Subject'] || '';
        const detail = row['Detail'] || '';
        const date = row['Date'] || row['CreatedAt'] || '';
        const creator = row['Creator'] || '';

        if (mattersLookup.has(matterId)) {
          mattersLookup.get(matterId).notes.push({ date, subject, detail, creator });
          notesMatched++;
        } else {
          notesUnmatched++;
        }
      });
      reports.push({ type: notesMatched > 0 ? 'info' : 'warning', message: `Matched ${notesMatched} notes, ${notesUnmatched} unmatched` });

      // Show sample note matter IDs for debugging
      if (phase2Data.clioNotes.rows.length > 0 && detectedNoteMatterIdField) {
        const sampleNoteIds = phase2Data.clioNotes.rows.slice(0, 3).map(r => String(r[detectedNoteMatterIdField] || '').trim());
        const sampleMatterIds = Array.from(mattersLookup.keys()).slice(0, 3);
        reports.push({ type: 'info', message: `Sample note ${detectedNoteMatterIdField}: ${sampleNoteIds.map(id => `"${id}"`).join(', ')}` });
        reports.push({ type: 'info', message: `Sample matter UniqueId: ${sampleMatterIds.map(id => `"${id}"`).join(', ')}` });
      }
    }

    // Identify clients that don't have Airtable records and need to be created
    const missingClients = [];
    const seenClientIds = new Set();

    mattersLookup.forEach((matter) => {
      const clientId = matter.clientId;
      if (clientId && !clioContactToRecordId.has(clientId) && !seenClientIds.has(clientId)) {
        seenClientIds.add(clientId);
        missingClients.push({
          clientId: clientId,
          clientName: matter.clientName || ''
        });
      }
    });

    if (missingClients.length > 0) {
      reports.push({ type: 'info', message: `Found ${missingClients.length} clients without Airtable records - creating them...` });

      // Create missing clients in Airtable
      const createdRecords = await createMissingClientsInAirtable(missingClients);

      // Update the lookup map with newly created records
      createdRecords.forEach((recordId, clientId) => {
        clioContactToRecordId.set(clientId, recordId);
      });

      reports.push({ type: 'success', message: `Created ${createdRecords.size} new client records in Airtable` });
    }

    // Build Case Master View output using field mappings
    const caseMasterOutput = [];
    let linkedCount = 0;
    let unlinkedCount = 0;

    // Track sample matches and unmatched for testing UI
    const sampleMatches = [];
    const sampleUnmatched = [];

    // Get enabled output field mappings
    const enabledFields = Object.entries(phase2FieldMapping.outputFields)
      .filter(([, config]) => config.enabled && config.inputField)
      .reduce((acc, [fieldId, config]) => {
        acc[fieldId] = config;
        return acc;
      }, {});

    // Debug: Show which fields are mapped to _client_record_id
    const clientLinkFields = Object.entries(enabledFields)
      .filter(([, config]) => config.inputField === '_client_record_id')
      .map(([, config]) => config.fieldName);
    if (clientLinkFields.length > 0) {
      reports.push({ type: 'info', message: `Client link field(s): ${clientLinkFields.join(', ')}` });
    } else {
      reports.push({ type: 'warning', message: `No fields mapped to _client_record_id. Re-fetch schema to apply default mappings.` });
    }

    mattersLookup.forEach((matter) => {
      // Find Airtable Record ID for this client
      const clientRecordId = clioContactToRecordId.get(matter.clientId) || '';

      if (clientRecordId) {
        linkedCount++;
        // Capture sample matches (up to 5)
        if (sampleMatches.length < 5) {
          sampleMatches.push({
            displayNumber: matter.displayNumber,
            clientName: matter.clientName,
            clioClientId: matter.clientId,
            airtableRecordId: clientRecordId,
          });
        }
      } else {
        unlinkedCount++;
        // Capture sample unmatched (up to 5)
        if (sampleUnmatched.length < 5) {
          sampleUnmatched.push({
            displayNumber: matter.displayNumber,
            clientName: matter.clientName,
            clioClientId: matter.clientId,
          });
        }
      }

      // Sort notes by date descending and format
      const sortedNotes = matter.notes.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));

      const formattedNotes = sortedNotes.map((note) => {
        const datePart = note.date ? `[${note.date}]` : '[No Date]';
        const subjectPart = note.subject ? ` - ${note.subject}` : '';
        const creatorPart = note.creator ? `\nBy: ${note.creator}` : '';
        return `${'═'.repeat(55)}\n${datePart}${subjectPart}${creatorPart}\n${'─'.repeat(50)}\n${note.detail || '(No content)'}`;
      }).join('\n\n');

      // Apply status mapping transformation
      const rawStatus = matter.status || '';
      const mappedStatus = phase2FieldMapping.statusMapping[rawStatus] || rawStatus;

      // Build output record using field mappings - keyed by field ID for Airtable API
      const outputRecord = {
        _fieldMapping: {}, // Store mapping info for reference
      };

      // Map each enabled field by its Airtable field ID
      Object.entries(enabledFields).forEach(([fieldId, config]) => {
        let value;

        switch (config.inputField) {
          case '_client_record_id':
            value = clientRecordId ? [clientRecordId] : [];
            break;
          case '_aggregated_notes':
            value = formattedNotes;
            break;
          case '_constant_true':
            value = true;
            break;
          case '_mapped_status':
            value = mappedStatus;
            break;
          case '_client_name':
            value = matter.clientName;
            break;
          case '_note_count':
            value = sortedNotes.length;
            break;
          case 'UniqueId':
            value = matter.matterId;
            break;
          case 'DisplayNumber':
            value = matter.displayNumber;
            break;
          case 'Description':
            value = matter.description;
            break;
          case 'Status':
            value = matter.status;
            break;
          case 'ClientId':
            value = matter.clientId;
            break;
          case 'OpenDate':
            value = matter.openDate;
            break;
          case 'CloseDate':
            value = matter.closeDate;
            break;
          case '_matter_flatpack_data':
            // Build flatpack data object containing all matter data from all sources
            const matterFlatpackData = {
              matterId: matter.matterId,
              clientId: matter.clientId,
              displayNumber: matter.displayNumber,
              description: matter.description,
              clientName: matter.clientName,
              status: matter.status,
              mappedStatus: mappedStatus,
              openDate: matter.openDate,
              closeDate: matter.closeDate,
              notes: sortedNotes.map(note => ({
                date: note.date,
                subject: note.subject,
                detail: note.detail,
                creator: note.creator
              })),
              noteCount: sortedNotes.length,
              clientRecordId: clientRecordId || null
            };
            value = JSON.stringify(matterFlatpackData);
            break;
          default:
            // For any other input field, try to get it from matter object
            value = matter[config.inputField] || '';
        }

        // Store value with field name as key (for CSV compatibility)
        outputRecord[config.fieldName] = value;
        // Also store mapping info for display/debugging
        outputRecord._fieldMapping[fieldId] = {
          fieldName: config.fieldName,
          fieldType: config.fieldType,
          inputField: config.inputField,
        };
      });

      // Always add internal fields for reference (these help with debugging/viewing)
      outputRecord['_client_name'] = matter.clientName;
      outputRecord['_note_count'] = sortedNotes.length;
      outputRecord['_displayNumber'] = matter.displayNumber;
      outputRecord['_client_record_id'] = clientRecordId || ''; // Debug: always include for visibility

      // ALWAYS include all Clio matter data (regardless of schema mappings)
      // This ensures CSV download has complete data even if Airtable schema isn't fetched
      outputRecord['Matter_ID'] = matter.matterId;
      outputRecord['Display_Number'] = matter.displayNumber;
      outputRecord['Client_Name'] = matter.clientName;
      outputRecord['Client_ID'] = matter.clientId;
      outputRecord['Description'] = matter.description;
      outputRecord['Status'] = matter.status;
      outputRecord['Mapped_Status'] = mappedStatus;
      outputRecord['Open_Date'] = matter.openDate;
      outputRecord['Close_Date'] = matter.closeDate;
      outputRecord['Notes'] = formattedNotes;
      outputRecord['Note_Count'] = sortedNotes.length;
      outputRecord['Airtable_Record_ID'] = clientRecordId || '';

      caseMasterOutput.push(outputRecord);
    });

    reports.push({ type: 'info', message: `Generated ${caseMasterOutput.length} Case Master Views (${linkedCount} linked to Airtable clients, ${unlinkedCount} unlinked)` });

    // Build matching stats for test UI
    const matchingStats = {
      totalMatters: caseMasterOutput.length,
      linkedCount,
      unlinkedCount,
      airtableClientsLoaded: clioContactToRecordId.size,
      sampleMatches,
      sampleUnmatched,
      // Get sample Airtable clio_contact_ids for comparison
      sampleAirtableIds: Array.from(clioContactToRecordId.keys()).slice(0, 5),
      // Get sample Clio ClientIds for comparison
      sampleClioClientIds: Array.from(mattersLookup.values()).slice(0, 5).map(m => m.clientId),
      // Detected field name and available columns for debugging
      detectedClioIdField,
      clioMattersColumns,
      // Notes matching stats
      notesMatched,
      notesUnmatched,
      detectedNoteMatterIdField,
      clioNotesColumns,
    };

    setPhase2Result({ caseMaster: caseMasterOutput, matchingStats });
    setPhase2Report(reports);
    } catch (err) {
      console.error('runPhase2 error:', err);
      setPhase2Report([{ type: 'error', message: `Error generating Case Master Views: ${err.message}` }]);
    } finally {
      setPhase2Sync(prev => ({ ...prev, loading: false }));
    }
  }, [phase2Data, phase2FieldMapping, airtableApiKey, devToolsBaseId]);

  // Download Phase 2 data as JSON with flatpack field
  const downloadPhase2JSON = () => {
    if (!phase2Result?.caseMaster?.length) {
      alert('No data to download. Generate Case Master Views first.');
      return;
    }

    // Build JSON array where each matter is the master object with all data flatpacked
    const jsonData = phase2Result.caseMaster.map(record => {
      // Build flatpack object with all data at the same level
      const flatpackData = {
        // Core matter identifiers
        matterId: record.Matter_ID || record._matterId || '',
        displayNumber: record.Display_Number || record._displayNumber || '',

        // Client info
        clientId: record.Client_ID || record._clientId || '',
        clientName: record.Client_Name || record._client_name || '',
        airtableRecordId: record.Airtable_Record_ID || record._client_record_id || '',

        // Matter details
        description: record.Description || '',
        status: record.Status || '',
        mappedStatus: record.Mapped_Status || '',
        openDate: record.Open_Date || '',
        closeDate: record.Close_Date || '',

        // Notes - formatted as single field
        notes: record.Notes || '',
        noteCount: record.Note_Count || record._note_count || 0,
      };

      // Return the matter object with flatpack field containing all data as JSON string
      return {
        // Matter as the master object - all fields at same level
        matterId: flatpackData.matterId,
        displayNumber: flatpackData.displayNumber,
        clientId: flatpackData.clientId,
        clientName: flatpackData.clientName,
        airtableRecordId: flatpackData.airtableRecordId,
        description: flatpackData.description,
        status: flatpackData.status,
        mappedStatus: flatpackData.mappedStatus,
        openDate: flatpackData.openDate,
        closeDate: flatpackData.closeDate,
        notes: flatpackData.notes,
        noteCount: flatpackData.noteCount,
        // Flatpack field with all data as JSON string
        flatpack: JSON.stringify(flatpackData),
      };
    });

    const json = JSON.stringify(jsonData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'case_master_views.json';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Upload Case Master Views to Airtable using field IDs
  const uploadCaseMasterViewsToAirtable = async (testMode = false) => {
    if (!phase2Result?.caseMaster?.length) {
      addPhase2Log('No Case Master Views to upload. Generate them first.', 'warning');
      return;
    }

    if (!caseMasterSchema.loaded) {
      addPhase2Log('Schema not loaded. Please fetch schema first.', 'warning');
      return;
    }

    const recordsToCreate = testMode ? phase2Result.caseMaster.slice(0, 5) : phase2Result.caseMaster;

    // Filter to only records with valid Client links (optional - include all for completeness)
    const validRecords = recordsToCreate;

    if (validRecords.length === 0) {
      addPhase2Log('No records to upload', 'warning');
      return;
    }

    setPhase2Sync(prev => ({
      ...prev,
      loading: true,
      progress: { current: 0, total: validRecords.length, phase: 'Uploading Case Master Views' }
    }));

    addPhase2Log(`${testMode ? 'TEST: ' : ''}Starting upload of ${validRecords.length} Case Master Views to table ${CASE_MASTER_VIEW_TABLE_ID}...`, 'info');

    let created = 0;
    let failed = 0;

    // Get list of valid field IDs and names from schema
    const validFieldIds = new Set(caseMasterSchema.fields.map(f => f.id));
    const fieldNameToId = new Map(caseMasterSchema.fields.map(f => [f.name, f.id]));
    const fieldIdToName = new Map(caseMasterSchema.fields.map(f => [f.id, f.name]));

    // Build mapping from our output field names to Airtable field names
    // Note: Only includes fields that exist in the Airtable schema
    // Excluded computed fields (cannot write): PP ID, Client Name, Client ID, Note Count
    // Excluded non-existent fields: Status, Open Date, Close Date
    // Excluded singleSelect fields: File Case Status (use schema mapping instead)
    const ourFieldToAirtable = {
      'Matter_ID': 'clio_matter_id',
      'Description': 'Description',
      'Notes': 'Case Notes',
      'Airtable_Record_ID': 'Edit Client Info', // Link field
    };

    // Debug: Log schema fields
    addPhase2Log(`Schema has ${caseMasterSchema.fields.length} fields: ${caseMasterSchema.fields.slice(0, 5).map(f => f.name).join(', ')}...`, 'info');

    // Debug: Log first record structure
    if (validRecords.length > 0) {
      const firstRec = validRecords[0];
      const recKeys = Object.keys(firstRec).filter(k => !k.startsWith('_'));
      addPhase2Log(`First record has ${recKeys.length} fields: ${recKeys.slice(0, 8).join(', ')}...`, 'info');
      // Show sample values
      const sampleFields = ['Display_Number', 'Client_Name', 'Airtable_Record_ID'].map(k => `${k}="${firstRec[k] || '(empty)'}"`).join(', ');
      addPhase2Log(`Sample values: ${sampleFields}`, 'info');
    }

    // Debug: Count records with valid client links
    const clientLinkFieldId = Object.entries(phase2FieldMapping.outputFields)
      .find(([, config]) => config.inputField === '_client_record_id' && config.enabled)?.[0];
    if (clientLinkFieldId) {
      const withClientLink = validRecords.filter(r => Array.isArray(r[clientLinkFieldId]) && r[clientLinkFieldId].length > 0 && r[clientLinkFieldId][0]).length;
      addPhase2Log(`Client links (schema-mapped): ${withClientLink}/${validRecords.length} records`, 'info');
    }
    // Also check our direct field
    const withDirectLink = validRecords.filter(r => r['Airtable_Record_ID']).length;
    addPhase2Log(`Client links (Airtable_Record_ID): ${withDirectLink}/${validRecords.length} records`, 'info');

    // Process in batches of 10 (Airtable API limit)
    for (let i = 0; i < validRecords.length; i += 10) {
      const batch = validRecords.slice(i, i + 10);

      const airtableRecords = batch.map((record, recIdx) => {
        const fields = {};

        // Map our standard field names to Airtable field names, then use field name directly
        // Airtable API accepts field names, not just field IDs
        Object.entries(record).forEach(([key, value]) => {
          // Skip internal fields (starting with _)
          if (key.startsWith('_')) return;
          if (value === undefined || value === null || value === '') return;

          // Check if this is one of our standard fields that needs mapping
          const airtableFieldName = ourFieldToAirtable[key];
          if (airtableFieldName) {
            // Special handling for link fields
            if (key === 'Airtable_Record_ID' && value) {
              // Link fields need to be arrays of record IDs
              fields[airtableFieldName] = [value];
            } else {
              fields[airtableFieldName] = value;
            }
            return;
          }

          // Also try schema-mapped fields (keyed by field ID)
          if (validFieldIds.has(key)) {
            const config = phase2FieldMapping.outputFields[key];
            if (!config || !config.enabled) return;

            // Handle special field types based on Airtable field type
            if (config.fieldType === 'multipleRecordLinks') {
              if (Array.isArray(value) && value.length > 0 && value[0]) {
                fields[key] = value;
              }
            } else if (config.fieldType === 'checkbox') {
              fields[key] = Boolean(value);
            } else if (config.fieldType === 'singleSelect') {
              const schemaField = caseMasterSchema.fields.find(f => f.id === key);
              const validOptions = schemaField?.options?.choices?.map(c => c.name) || [];
              if (value && validOptions.includes(value)) {
                fields[key] = value;
              }
            } else if (config.fieldType === 'multipleSelects') {
              const schemaField = caseMasterSchema.fields.find(f => f.id === key);
              const validOptions = schemaField?.options?.choices?.map(c => c.name) || [];
              if (Array.isArray(value)) {
                const validValues = value.filter(v => validOptions.includes(v));
                if (validValues.length > 0) {
                  fields[key] = validValues;
                }
              } else if (value && validOptions.includes(value)) {
                fields[key] = [value];
              }
            } else {
              fields[key] = value;
            }
          }
        });

        // Debug: Log first record's fields being sent
        if (i === 0 && recIdx === 0) {
          const fieldList = Object.entries(fields).map(([k, v]) => `${k}=${typeof v === 'string' ? v.slice(0, 20) : JSON.stringify(v)}`).join(', ');
          addPhase2Log(`First record fields being sent: ${fieldList.slice(0, 200)}...`, 'info');
        }

        return { fields };
      });

      try {
        // Use table ID in the URL for proper API call
        const response = await fetch(
          `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${CASE_MASTER_VIEW_TABLE_ID}`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${airtableApiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ records: airtableRecords })
          }
        );

        if (!response.ok) {
          const errData = await response.json().catch(() => ({}));
          throw new Error(errData.error?.message || `HTTP ${response.status}`);
        }

        const result = await response.json();
        created += result.records.length;
        addPhase2Log(`Batch ${Math.floor(i/10) + 1}: Created ${result.records.length} records`, 'success');

        setPhase2Sync(prev => ({
          ...prev,
          progress: { ...prev.progress, current: i + batch.length }
        }));
      } catch (err) {
        failed += batch.length;
        addPhase2Log(`Batch ${Math.floor(i/10) + 1} failed: ${err.message}`, 'error');
        // Log first record of failed batch for debugging
        if (batch.length > 0) {
          addPhase2Log(`First record fields: ${Object.keys(batch[0]).filter(k => !k.startsWith('_')).join(', ')}`, 'info');
        }
      }

      // Rate limiting: 250ms between batches (Airtable allows 5 req/sec)
      await new Promise(resolve => setTimeout(resolve, 250));
    }

    setPhase2Sync(prev => ({
      ...prev,
      loading: false,
      progress: { current: validRecords.length, total: validRecords.length, phase: 'Upload Complete' }
    }));

    addPhase2Log(
      `Upload complete: ${created} created, ${failed} failed`,
      created > 0 ? 'success' : 'error'
    );
  };

  // Phase 3: Events & Relationships
  const runPhase3 = useCallback(() => {
    const reports = [];

    // Build lookups from Airtable exports
    const clioContactToRecordId = new Map();
    const clioMatterToRecordId = new Map();
    const displayNumberToRecordId = new Map();

    if (phase3Data.airtableClients?.rows) {
      phase3Data.airtableClients.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || '';
        const clioContactId = row['clio_contact_id'] || '';
        if (clioContactId && recordId) {
          clioContactToRecordId.set(clioContactId, recordId);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioContactToRecordId.size} client mappings` });
    }

    if (phase3Data.airtableCaseMaster?.rows) {
      phase3Data.airtableCaseMaster.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || '';
        const clioMatterId = row['clio_matter_id'] || '';
        const displayNumber = row['PP ID'] || '';

        if (clioMatterId && recordId) {
          clioMatterToRecordId.set(clioMatterId, recordId);
        }
        if (displayNumber && recordId) {
          // Extract just the number part for matching (e.g., "00006" from "00006-Hernandez")
          const numMatch = displayNumber.match(/^(\d+)/);
          if (numMatch) {
            displayNumberToRecordId.set(numMatch[1], recordId);
          }
          displayNumberToRecordId.set(displayNumber, recordId);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioMatterToRecordId.size} case master mappings` });
    }

    // Process Events
    const eventsOutput = [];
    let eventsLinked = 0;
    let eventsUnlinked = 0;

    if (phase3Data.clioEvents?.rows) {
      phase3Data.clioEvents.rows.forEach((row) => {
        const summary = row['summary'] || '';
        const description = row['description'] || '';
        const startDateTime = row['start.dateTime'] || '';
        const location = row['location'] || '';

        const summaryParsed = parseEventSummary(summary);
        const descParsed = parseEventDescription(description);

        // Skip events without A#
        if (!summaryParsed.aNumber) {
          reports.push({ type: 'warning', message: `Event skipped (no A#): ${summary.slice(0, 50)}...` });
          return;
        }

        // Try to find Case Master View by matter ID from summary
        let caseMasterRecordId = '';
        if (summaryParsed.matterId) {
          // Try full match first
          caseMasterRecordId = displayNumberToRecordId.get(summaryParsed.matterId) || '';

          // Try just the number part
          if (!caseMasterRecordId) {
            const numMatch = summaryParsed.matterId.match(/^(\d+)/);
            if (numMatch) {
              caseMasterRecordId = displayNumberToRecordId.get(numMatch[1]) || '';
            }
          }
        }

        if (caseMasterRecordId) {
          eventsLinked++;
        } else {
          eventsUnlinked++;
          reports.push({ type: 'warning', message: `Event not linked to Case Master: ${summaryParsed.matterId || 'no matter ID'}` });
        }

        const court = location || descParsed.courtAddress || '';

        eventsOutput.push({
          'Case Master': caseMasterRecordId ? [caseMasterRecordId] : [], // Link to Case Master View (must be array)
          'A#': summaryParsed.aNumber,
          'Hearing Date/Time': startDateTime,
          'Event Type': 'Hearing',
          'Event Hearing Type': mapHearingType(summaryParsed.hearingType),
          'Court': court,
          'Judge': descParsed.judge,
          'MCH Attny': [ANDREW_BAHR_RECORD_ID], // Link field (must be array)
          'Bahr Client': 'TRUE',
          '_summary': summary.slice(0, 100),
        });
      });

      reports.push({ type: 'info', message: `Processed ${eventsOutput.length} events (${eventsLinked} linked, ${eventsUnlinked} unlinked)` });
    }

    // Process Relationships
    const relationshipsOutput = [];
    let relsLinked = 0;
    let relsUnlinked = 0;

    if (phase3Data.clioRelationships?.rows) {
      phase3Data.clioRelationships.rows.forEach((row) => {
        const relationshipDesc = row['RelationshipDescription'] || '';
        const contactId = row['ContactId'] || ''; // Object client (the related person)
        const matterId = row['MatterId'] || '';
        const contactName = row['Contact'] || '';

        // Find the subject client (primary client on the matter) - we need to look this up from the matter
        // For now, we'll use the Case Master View link
        const caseMasterRecordId = clioMatterToRecordId.get(matterId) || '';
        const objectClientRecordId = clioContactToRecordId.get(contactId) || '';

        if (caseMasterRecordId && objectClientRecordId) {
          relsLinked++;
        } else {
          relsUnlinked++;
          if (!caseMasterRecordId) {
            reports.push({ type: 'warning', message: `Relationship: Case Master not found for matter ${matterId}` });
          }
          if (!objectClientRecordId) {
            reports.push({ type: 'warning', message: `Relationship: Object client not found (${contactName}, ID: ${contactId})` });
          }
        }

        // Map relationship description to Airtable select options
        const relationshipMap = {
          'spouse': 'Spouse',
          'son': 'Child',
          'daughter': 'Child',
          'parent': 'Parent',
          'mother': 'Parent',
          'father': 'Parent',
          'sibling': 'Sibling',
          'brother': 'Sibling',
          'sister': 'Sibling',
        };
        const relationship = relationshipMap[relationshipDesc.toLowerCase()] || relationshipDesc;

        relationshipsOutput.push({
          'Case Master View': caseMasterRecordId ? [caseMasterRecordId] : [], // Link field (must be array)
          'Object Client': objectClientRecordId ? [objectClientRecordId] : [], // Link field (must be array)
          'Relationship': relationship,
          'Bahr Client': 'TRUE',
          '_contact_name': contactName,
          '_original_relationship': relationshipDesc,
        });
      });

      reports.push({ type: 'info', message: `Processed ${relationshipsOutput.length} relationships (${relsLinked} linked, ${relsUnlinked} unlinked)` });
    }

    setPhase3Result({ events: eventsOutput, relationships: relationshipsOutput });
    setPhase3Report(reports);
  }, [phase3Data]);

  // Phase 4: Case Notes to Xano
  const runPhase4 = useCallback(() => {
    const reports = [];

    // Build clio_contact_id -> client info lookup from Airtable Client Info export
    const clioContactToClient = new Map();

    if (phase4Data.airtableClients?.rows) {
      phase4Data.airtableClients.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || '';
        const clioContactId = row['clio_contact_id'] || '';
        const clientId = row['Client ID'] || row['A#'] || '';
        const firstName = row['First Name'] || '';
        const lastName = row['Family Name'] || '';

        if (clioContactId) {
          clioContactToClient.set(clioContactId, {
            recordId,
            clientId,
            clientName: `${firstName} ${lastName}`.trim(),
          });
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioContactToClient.size} client mappings from Airtable export` });
    }

    // Build clio_matter_id -> case master info lookup from Airtable Case Master export
    const clioMatterToCaseMaster = new Map();
    const ppIdToCaseMaster = new Map();

    if (phase4Data.airtableCaseMaster?.rows) {
      phase4Data.airtableCaseMaster.rows.forEach((row) => {
        const recordId = row['Record ID'] || row['recordId'] || '';
        const clioMatterId = row['clio_matter_id'] || '';
        const ppId = row['PP ID'] || '';
        const description = row['Description'] || '';
        const clientRecordId = row['Client'] || '';

        const caseMasterInfo = {
          recordId,
          ppId,
          description,
          clientRecordId,
        };

        if (clioMatterId) {
          clioMatterToCaseMaster.set(clioMatterId, caseMasterInfo);
        }
        if (ppId) {
          ppIdToCaseMaster.set(ppId, caseMasterInfo);
        }
      });
      reports.push({ type: 'info', message: `Loaded ${clioMatterToCaseMaster.size} case master mappings from Airtable export` });
    }

    // Process Clio Notes and create Xano payloads
    const notesOutput = [];
    let linkedCount = 0;
    let unlinkedCount = 0;
    let missingMatter = 0;
    let missingClient = 0;

    if (phase4Data.clioNotes?.rows) {
      phase4Data.clioNotes.rows.forEach((row, index) => {
        const matterId = row['MatterId'] || row['Matter ID'] || row['UniqueId'] || '';
        const subject = row['Subject'] || '';
        const detail = row['Detail'] || row['Description'] || row['Note'] || '';
        const date = row['Date'] || row['CreatedAt'] || row['Created'] || '';
        const creator = row['Creator'] || row['CreatedBy'] || row['Author'] || '';

        // Find case master info
        const caseMaster = clioMatterToCaseMaster.get(matterId);
        if (!caseMaster) {
          missingMatter++;
          reports.push({ type: 'warning', message: `Note ${index + 1}: Matter ${matterId} not found in Case Master export` });
        }

        // Find client info - from case master or from matter's ClientId field
        let clientInfo = null;
        const clientIdFromNote = row['ClientId'] || row['Client ID'] || '';

        if (caseMaster?.clientRecordId) {
          // Try to find client by their Airtable record ID
          for (const [clioId, info] of clioContactToClient.entries()) {
            if (info.recordId === caseMaster.clientRecordId) {
              clientInfo = info;
              break;
            }
          }
        }

        if (!clientInfo && clientIdFromNote) {
          clientInfo = clioContactToClient.get(clientIdFromNote);
        }

        if (!clientInfo && !caseMaster) {
          missingClient++;
        }

        if (caseMaster || clientInfo) {
          linkedCount++;
        } else {
          unlinkedCount++;
        }

        // Parse date for Xano
        let dateTimestamp = null;
        let dateIso = '';
        if (date) {
          const parsedDate = new Date(date);
          if (!isNaN(parsedDate.getTime())) {
            dateTimestamp = Math.floor(parsedDate.getTime() / 1000);
            dateIso = parsedDate.toISOString();
          }
        }

        // Create Xano payload
        const notePayload = {
          Activity: subject || 'Case Note',
          Type: 'Note',
          Date: dateTimestamp,
          Description: detail,
          Contact: clientInfo?.clientName || '',
          Client_PP_ID: caseMaster?.ppId || '',
          Matter: caseMaster?.description || '',
          RecordId: caseMaster?.recordId || '',
          Created_By: creator,
          Softr_Link_to_clients: '',
          Updated: '',
          Modified: '',
          Due_Date: null,
          Last_Update_By: '',
          unix_timestamp: dateTimestamp ? String(dateTimestamp) : '',
          time_raw: dateIso,
          tags: [],
          pp_note_id: `clio-${matterId}-${index}`,
          matter: caseMaster?.description || '',
          matter_id: matterId,
          source: 'clio-merge',
          client_airtable_id: clientInfo?.recordId || caseMaster?.clientRecordId || '',
          eventId: '',
          // Additional metadata for preview
          _subject: subject,
          _date: date,
          _creator: creator,
          _matterId: matterId,
          _linked: !!(caseMaster || clientInfo),
        };

        notesOutput.push(notePayload);
      });

      reports.push({ type: 'info', message: `Processed ${notesOutput.length} notes (${linkedCount} linked, ${unlinkedCount} unlinked)` });
      if (missingMatter > 0) {
        reports.push({ type: 'warning', message: `${missingMatter} notes have unmatched Matter IDs` });
      }
      if (missingClient > 0) {
        reports.push({ type: 'warning', message: `${missingClient} notes could not be linked to clients` });
      }
    }

    setPhase4Result({ notes: notesOutput, linkedCount, unlinkedCount });
    setPhase4Report(reports);
  }, [phase4Data]);

  // POST notes to Xano in batches
  const postNotesToXano = async () => {
    if (!phase4Result?.notes?.length) {
      setPhase4Report(prev => [...prev, { type: 'error', message: 'No notes to post. Run Phase 4 first.' }]);
      return;
    }

    const notes = phase4Result.notes;
    setPhase4Progress({ current: 0, total: notes.length, status: 'posting' });
    setPhase4Report(prev => [...prev, { type: 'info', message: `Starting to post ${notes.length} notes to Xano...` }]);

    let successCount = 0;
    let errorCount = 0;
    const errors = [];

    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];

      // Remove preview metadata before posting
      const payload = { ...note };
      delete payload._subject;
      delete payload._date;
      delete payload._creator;
      delete payload._matterId;
      delete payload._linked;

      try {
        const response = await fetch(XANO_CASE_NOTES_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`HTTP ${response.status}: ${JSON.stringify(errorData)}`);
        }

        successCount++;
      } catch (err) {
        errorCount++;
        errors.push({ index: i, subject: note._subject || note.Activity, error: err.message });
      }

      setPhase4Progress({ current: i + 1, total: notes.length, status: 'posting' });

      // Rate limiting: 250ms between requests
      if (i < notes.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 250));
      }
    }

    setPhase4Progress({ current: notes.length, total: notes.length, status: 'complete' });
    setPhase4Report(prev => [
      ...prev,
      { type: successCount > 0 ? 'info' : 'error', message: `Posted ${successCount} notes successfully, ${errorCount} failed` },
      ...errors.slice(0, 10).map(e => ({ type: 'error', message: `Note ${e.index + 1} (${e.subject}): ${e.error}` })),
      ...(errors.length > 10 ? [{ type: 'warning', message: `... and ${errors.length - 10} more errors` }] : []),
    ]);
  };

  const downloadCSV = (data, filename, headers) => {
    const csv = generateCSV(headers, data);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div style={{
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      color: '#e4e4e7',
      padding: '2rem',
    }}>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        * { box-sizing: border-box; }
        .card {
          background: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 12px;
          padding: 1.5rem;
          backdrop-filter: blur(10px);
        }
        .upload-zone {
          border: 2px dashed rgba(99, 102, 241, 0.4);
          border-radius: 8px;
          padding: 1.5rem;
          text-align: center;
          cursor: pointer;
          transition: all 0.2s;
        }
        .upload-zone:hover {
          border-color: rgba(99, 102, 241, 0.8);
          background: rgba(99, 102, 241, 0.05);
        }
        .upload-zone.has-file {
          border-color: #22c55e;
          background: rgba(34, 197, 94, 0.1);
        }
        .upload-zone-wrapper {
          position: relative;
        }
        .file-remove-btn {
          position: absolute;
          top: 4px;
          right: 4px;
          width: 20px;
          height: 20px;
          border-radius: 50%;
          background: rgba(239, 68, 68, 0.8);
          color: white;
          border: none;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 12px;
          line-height: 1;
          transition: all 0.2s;
          z-index: 10;
        }
        .file-remove-btn:hover {
          background: #ef4444;
          transform: scale(1.1);
        }
        .btn {
          padding: 0.75rem 1.5rem;
          border-radius: 8px;
          font-weight: 600;
          font-size: 0.875rem;
          cursor: pointer;
          transition: all 0.2s;
          border: none;
          font-family: inherit;
        }
        .btn-primary {
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
          color: white;
        }
        .btn-primary:hover:not(:disabled) {
          transform: translateY(-2px);
          box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
        }
        .btn-primary:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
        .btn-secondary {
          background: rgba(255, 255, 255, 0.1);
          color: #e4e4e7;
          border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover {
          background: rgba(255, 255, 255, 0.15);
        }
        .phase-tab {
          padding: 1rem 1.5rem;
          cursor: pointer;
          border-radius: 8px 8px 0 0;
          transition: all 0.2s;
          color: #a1a1aa;
          background: rgba(255, 255, 255, 0.02);
          border: 1px solid transparent;
          border-bottom: none;
        }
        .phase-tab:hover { color: #e4e4e7; }
        .phase-tab.active {
          color: #6366f1;
          background: rgba(99, 102, 241, 0.1);
          border-color: rgba(99, 102, 241, 0.3);
        }
        .badge {
          display: inline-block;
          padding: 0.25rem 0.5rem;
          border-radius: 4px;
          font-size: 0.75rem;
          font-weight: 600;
        }
        .badge-info { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .badge-warning { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .badge-error { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .badge-success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .table-container { overflow-x: auto; margin-top: 1rem; }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        th { background: rgba(99, 102, 241, 0.1); font-weight: 600; color: #a5b4fc; }
        td { color: #d4d4d8; }
      `}</style>

      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <header style={{ marginBottom: '2rem', textAlign: 'center' }}>
          <h1 style={{
            fontSize: '2rem',
            fontWeight: '700',
            background: 'linear-gradient(135deg, #6366f1 0%, #a855f7 50%, #ec4899 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            marginBottom: '0.5rem',
          }}>
            Clio → Airtable Merger
          </h1>
          <p style={{ color: '#71717a', fontSize: '0.875rem' }}>
            4-Phase import: Clients → Case Master Views → Events & Relationships → Case Notes
          </p>
        </header>

        {/* Phase Tabs */}
        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '0', flexWrap: 'wrap' }}>
          {[
            { num: 0, label: 'Bahr Parser', desc: 'Excel Multi-Tab Flattener' },
            { num: 1, label: 'Phase 1: Clients', desc: 'Bahr + Clio Contacts' },
            { num: 2, label: 'Phase 2: Case Master', desc: 'Matters + Notes' },
            { num: 3, label: 'Phase 3: Events & Relationships', desc: 'Events + Related Contacts' },
            { num: 4, label: 'Phase 4: Case Notes', desc: 'Notes → Xano' },
            { num: 5, label: 'Dev Tools', desc: 'Schema & Record Lookup' },
          ].map(({ num, label, desc }) => (
            <div
              key={num}
              className={`phase-tab ${activePhase === num ? 'active' : ''}`}
              onClick={() => setActivePhase(num)}
            >
              <div style={{ fontWeight: 600 }}>{label}</div>
              <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{desc}</div>
            </div>
          ))}
        </div>

        {/* Phase Content */}
        <div className="card" style={{ borderTopLeftRadius: 0 }}>
          {/* Phase 0: Excel Parser (Both Files) */}
          {activePhase === 0 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Excel Data Parser</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Upload Excel workbooks and/or DocketWise exports to extract and merge client data.
                Clients are matched by A# (primary) or normalized name (fallback) and combined into a single flat-packed record per unique client.
              </p>

              {/* Data Source Uploads */}
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {/* BAHR Workbook Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    BAHR Workbook
                    <span className="badge badge-warning">Excel .xlsx</span>
                  </h4>
                  <div className="upload-zone-wrapper">
                    {bahrExcelFile && (
                      <button className="file-remove-btn" onClick={clearBahrFile} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${bahrExcelFile ? 'has-file' : ''}`}>
                      <input
                        type="file"
                        accept=".xlsx,.xls"
                        onChange={handleBahrExcelUpload}
                        style={{ display: 'none' }}
                      />
                      {bahrExcelFile ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {bahrExcelFile.name}
                          <div style={{ fontSize: '0.75rem', color: '#71717a' }}>
                            {bahrSheets.length} sheets
                          </div>
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop Excel file or click to upload</div>
                      )}
                    </label>
                  </div>
                </div>

                {/* Office CASES Workbook Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Office CASES Workbook
                    <span className="badge badge-info">Excel .xlsx</span>
                  </h4>
                  <div className="upload-zone-wrapper">
                    {officeCasesFile && (
                      <button className="file-remove-btn" onClick={clearOfficeCasesFile} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${officeCasesFile ? 'has-file' : ''}`}>
                      <input
                        type="file"
                        accept=".xlsx,.xls"
                        onChange={handleOfficeCasesUpload}
                        style={{ display: 'none' }}
                      />
                      {officeCasesFile ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {officeCasesFile.name}
                          <div style={{ fontSize: '0.75rem', color: '#71717a' }}>
                            {officeCasesSheets.length} sheets
                          </div>
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop Excel file or click to upload</div>
                      )}
                    </label>
                  </div>
                </div>

                {/* DocketWise Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    DocketWise Export
                    <span className="badge badge-success">CSV/Excel</span>
                  </h4>
                  <div className="upload-zone-wrapper">
                    {docketWiseFile && (
                      <button className="file-remove-btn" onClick={clearDocketWiseFile} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${docketWiseFile ? 'has-file' : ''}`}>
                      <input
                        type="file"
                        accept=".csv,.xlsx,.xls"
                        onChange={handleDocketWiseUpload}
                        style={{ display: 'none' }}
                      />
                      {docketWiseFile ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {docketWiseFile.name}
                          <div style={{ fontSize: '0.75rem', color: '#71717a' }}>
                            {docketWiseSheets.length} sheet{docketWiseSheets.length !== 1 ? 's' : ''}, {docketWiseRecords.length} clients
                          </div>
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV/Excel or click to upload</div>
                      )}
                    </label>
                  </div>
                </div>
              </div>

              {/* Combined Stats */}
              {(bahrExcelFile || officeCasesFile || docketWiseFile) && (
                <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                  <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Combined Results</h4>
                  <div style={{ fontSize: '0.9rem' }}>
                    <strong>{combinedMergedClients.length}</strong> unique clients merged from{' '}
                    <strong>{bahrSheets.length + officeCasesSheets.length + docketWiseSheets.length}</strong> total sheets
                  </div>
                  <div style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.25rem' }}>
                    BAHR: {bahrSheets.length} sheets | Office CASES: {officeCasesSheets.length} sheets | DocketWise: {docketWiseSheets.length} sheet{docketWiseSheets.length !== 1 ? 's' : ''}
                  </div>
                </div>
              )}

              {/* Parse Reports - Tabbed */}
              {(bahrParseReport.length > 0 || officeCasesParseReport.length > 0 || docketWiseParseReport.length > 0) && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Parse Reports</h4>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem' }}>
                    {/* BAHR Report */}
                    {bahrParseReport.length > 0 && (
                      <div>
                        <div style={{ fontSize: '0.75rem', color: '#a5b4fc', marginBottom: '0.25rem' }}>BAHR Workbook</div>
                        <div style={{ maxHeight: '120px', overflowY: 'auto', fontSize: '0.8rem', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '6px' }}>
                          {bahrParseReport.map((item, i) => (
                            <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                              <span className={`badge badge-${item.type}`}>{item.type}</span>
                              <span style={{ fontSize: '0.75rem' }}>{item.message}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {/* Office CASES Report */}
                    {officeCasesParseReport.length > 0 && (
                      <div>
                        <div style={{ fontSize: '0.75rem', color: '#60a5fa', marginBottom: '0.25rem' }}>Office CASES Workbook</div>
                        <div style={{ maxHeight: '120px', overflowY: 'auto', fontSize: '0.8rem', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '6px' }}>
                          {officeCasesParseReport.map((item, i) => (
                            <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                              <span className={`badge badge-${item.type}`}>{item.type}</span>
                              <span style={{ fontSize: '0.75rem' }}>{item.message}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {/* DocketWise Report */}
                    {docketWiseParseReport.length > 0 && (
                      <div>
                        <div style={{ fontSize: '0.75rem', color: '#4ade80', marginBottom: '0.25rem' }}>DocketWise Export</div>
                        <div style={{ maxHeight: '120px', overflowY: 'auto', fontSize: '0.8rem', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '6px' }}>
                          {docketWiseParseReport.map((item, i) => (
                            <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                              <span className={`badge badge-${item.type}`}>{item.type}</span>
                              <span style={{ fontSize: '0.75rem' }}>{item.message}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* Sheets Overview - Combined */}
              {(bahrSheets.length > 0 || officeCasesSheets.length > 0 || docketWiseSheets.length > 0) && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>All Sheets ({bahrSheets.length + officeCasesSheets.length + docketWiseSheets.length})</h4>
                  <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                    {bahrSheets.map((sheet, i) => (
                      <div
                        key={`bahr-${i}`}
                        style={{
                          background: 'rgba(99, 102, 241, 0.1)',
                          border: '1px solid rgba(99, 102, 241, 0.3)',
                          borderRadius: '6px',
                          padding: '0.5rem 0.75rem',
                          fontSize: '0.8rem',
                        }}
                      >
                        <div style={{ fontWeight: 600, color: '#a5b4fc' }}>[BAHR] {sheet.name}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                          {sheet.rowCount} rows • {sheet.headers.length} columns
                        </div>
                      </div>
                    ))}
                    {officeCasesSheets.map((sheet, i) => (
                      <div
                        key={`office-${i}`}
                        style={{
                          background: 'rgba(59, 130, 246, 0.1)',
                          border: '1px solid rgba(59, 130, 246, 0.3)',
                          borderRadius: '6px',
                          padding: '0.5rem 0.75rem',
                          fontSize: '0.8rem',
                        }}
                      >
                        <div style={{ fontWeight: 600, color: '#60a5fa' }}>[Office] {sheet.name}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                          {sheet.rowCount} rows • {sheet.headers.length} columns
                        </div>
                      </div>
                    ))}
                    {docketWiseSheets.map((sheet, i) => (
                      <div
                        key={`docketwise-${i}`}
                        style={{
                          background: 'rgba(34, 197, 94, 0.1)',
                          border: '1px solid rgba(34, 197, 94, 0.3)',
                          borderRadius: '6px',
                          padding: '0.5rem 0.75rem',
                          fontSize: '0.8rem',
                        }}
                      >
                        <div style={{ fontWeight: 600, color: '#4ade80' }}>[DocketWise] {sheet.name}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                          {sheet.rowCount} rows • {sheet.headers.length} columns
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Download Buttons */}
              {combinedMergedClients.length > 0 && (
                <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem' }}>
                  <button className="btn btn-primary" onClick={downloadBahrClientSummary}>
                    Download Client Summary ({combinedMergedClients.length} clients)
                  </button>
                  <button className="btn btn-secondary" onClick={downloadBahrFlattenedCSV}>
                    Download Client Data (JSON)
                  </button>
                </div>
              )}

              {/* Client Search and List */}
              {combinedMergedClients.length > 0 && (
                <div>
                  <div style={{ display: 'flex', gap: '1rem', alignItems: 'center', marginBottom: '1rem' }}>
                    <h4 style={{ margin: 0 }}>Merged Clients ({combinedMergedClients.length})</h4>
                    <input
                      type="text"
                      placeholder="Search by name or A#..."
                      value={bahrSearchTerm}
                      onChange={(e) => setBahrSearchTerm(e.target.value)}
                      style={{
                        flex: 1,
                        maxWidth: '300px',
                        padding: '0.5rem 0.75rem',
                        borderRadius: '6px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        background: 'rgba(0, 0, 0, 0.3)',
                        color: '#e4e4e7',
                        fontSize: '0.875rem',
                      }}
                    />
                  </div>

                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem', maxHeight: '500px' }}>
                    {/* Client List */}
                    <div style={{ overflowY: 'auto', maxHeight: '500px', background: 'rgba(0, 0, 0, 0.2)', borderRadius: '8px', padding: '0.5rem' }}>
                      {combinedMergedClients
                        .filter(client => {
                          if (!bahrSearchTerm) return true;
                          const search = bahrSearchTerm.toUpperCase();
                          return (
                            client.primaryName.toUpperCase().includes(search) ||
                            (client.aNumber && client.aNumber.includes(search)) ||
                            client.names.some(n => n.toUpperCase().includes(search))
                          );
                        })
                        .slice(0, 100)
                        .map((client, i) => (
                          <div
                            key={i}
                            onClick={() => setBahrSelectedClient(client)}
                            style={{
                              padding: '0.5rem 0.75rem',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              marginBottom: '0.25rem',
                              background: bahrSelectedClient === client ? 'rgba(99, 102, 241, 0.3)' : 'transparent',
                              borderLeft: client.aNumber ? '3px solid #22c55e' : '3px solid #f59e0b',
                            }}
                          >
                            <div style={{ fontWeight: 500, fontSize: '0.85rem' }}>{client.primaryName}</div>
                            <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                              {client.aNumber || 'No A#'} • {Object.keys(client.sheetData).length} sheets
                            </div>
                          </div>
                        ))}
                    </div>

                    {/* Client Detail */}
                    <div style={{ overflowY: 'auto', maxHeight: '500px', background: 'rgba(0, 0, 0, 0.2)', borderRadius: '8px', padding: '1rem' }}>
                      {bahrSelectedClient ? (
                        <div>
                          <div style={{ marginBottom: '1rem', paddingBottom: '1rem', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                            <h3 style={{ margin: 0, color: '#a5b4fc' }}>{bahrSelectedClient.primaryName}</h3>
                            <div style={{ fontSize: '0.9rem', color: bahrSelectedClient.aNumber ? '#4ade80' : '#fbbf24', marginTop: '0.25rem' }}>
                              A#: {bahrSelectedClient.aNumber || '(not found)'}
                            </div>
                            {bahrSelectedClient.names.length > 1 && (
                              <div style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.25rem' }}>
                                Also known as: {bahrSelectedClient.names.slice(1).join(', ')}
                              </div>
                            )}
                          </div>

                          {/* Data by Sheet */}
                          {Object.entries(bahrSelectedClient.sheetData).map(([sheetName, records]) => (
                            <div key={sheetName} style={{ marginBottom: '1rem' }}>
                              <h4 style={{ color: '#6366f1', fontSize: '0.9rem', marginBottom: '0.5rem' }}>
                                📄 {sheetName}
                              </h4>
                              {records.map((record, ri) => (
                                <div
                                  key={ri}
                                  style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: '6px',
                                    padding: '0.75rem',
                                    marginBottom: '0.5rem',
                                    fontSize: '0.8rem',
                                  }}
                                >
                                  <div style={{ fontSize: '0.7rem', color: '#71717a', marginBottom: '0.5rem' }}>
                                    Row {record.rowIndex}
                                  </div>
                                  {Object.entries(record.data).map(([key, value]) => (
                                    <div key={key} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                                      <span style={{ color: '#a5b4fc', minWidth: '120px', flexShrink: 0 }}>{key}:</span>
                                      <span style={{ color: '#e4e4e7', wordBreak: 'break-word' }}>{value}</span>
                                    </div>
                                  ))}
                                </div>
                              ))}
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div style={{ color: '#71717a', textAlign: 'center', padding: '2rem' }}>
                          Select a client to view their data across all sheets
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {/* Instructions */}
              {!bahrExcelFile && !officeCasesFile && !docketWiseFile && (
                <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                  <h4 style={{ color: '#a5b4fc', marginBottom: '0.5rem' }}>How it works</h4>
                  <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                    <li>Upload Excel workbooks (.xlsx) or DocketWise CSV exports</li>
                    <li>Parser reads all sheets/rows and extracts client data</li>
                    <li>Clients are matched across ALL sources by A# (priority) or name</li>
                    <li>Data from all files is merged into a single flat-packed record per client</li>
                    <li>View merged data or download combined CSV/JSON</li>
                  </ol>
                  <div style={{ marginTop: '1rem', fontSize: '0.8rem', color: '#71717a' }}>
                    <strong>Recognized columns (case-insensitive):</strong><br/>
                    Client names: {CLIENT_NAME_PATTERNS.slice(0, 6).join(', ')}, full_name...<br/>
                    A# columns: {A_NUMBER_PATTERNS.slice(0, 6).join(', ')}, alien_registration_number...<br/>
                    Matter fields: {MATTER_PATTERNS.slice(0, 4).join(', ')}... (extracts name from "01453-Name" format)<br/>
                    <br/>
                    <strong>Smart features:</strong><br/>
                    • Auto-detects header row (skips "Column 1", "Column 2" generic headers)<br/>
                    • Supports DocketWise exports (full_name, alien_registration_number, date_of_birth)<br/>
                    • Supports Spanish column names (Nombre del Cliente, etc.)<br/>
                    • Merges clients with same A# or name from different files
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 1: Clients */}
          {activePhase === 1 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 1: Client Import</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Uses Phase 0 data with optional Clio Contacts enrichment. Output includes <code>clio_contact_id</code>, <code>uscis_flatpack_data</code>, and <code>Bahr Client</code> fields.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {/* Phase 0 Data Status */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Combined Excel Data (from Phase 0)
                    <span className="badge badge-warning">Required</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>Parsed from both Excel files in Phase 0</p>
                  <div className={`upload-zone ${combinedMergedClients.length > 0 ? 'has-file' : ''}`} style={{ cursor: 'default' }}>
                    {combinedMergedClients.length > 0 ? (
                      <div>
                        <span style={{ color: '#22c55e' }}>✓</span> Phase 0 data loaded
                        <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{combinedMergedClients.length} unique clients</div>
                      </div>
                    ) : (
                      <div style={{ color: '#ef4444' }}>⚠ Parse Excel files in Phase 0 first</div>
                    )}
                  </div>
                </div>

                {/* Clio Contacts Upload */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Clio Contacts Export
                    <span className="badge badge-info">Optional</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>UniqueId, phone, email enrichment</p>
                  <div className="upload-zone-wrapper">
                    {phase1Files.clioContacts && (
                      <button className="file-remove-btn" onClick={clearPhase1File('clioContacts')} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${phase1Files.clioContacts ? 'has-file' : ''}`}>
                      <input type="file" accept=".csv" onChange={handleFileUpload(1, 'clioContacts')} style={{ display: 'none' }} />
                      {phase1Files.clioContacts ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {phase1Files.clioContacts.name}
                          <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{phase1Data.clioContacts?.rows?.length || 0} rows</div>
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV or click to upload</div>
                      )}
                    </label>
                  </div>
                </div>
              </div>

              <button
                className="btn btn-primary"
                onClick={runPhase1}
                disabled={combinedMergedClients.length === 0}
                style={{ marginBottom: '1.5rem' }}
              >
                Generate clients.csv
              </button>

              {phase1Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Validation Report</h4>
                  <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.8rem' }}>
                    {phase1Report.map((item, i) => (
                      <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                        <span className={`badge badge-${item.type}`}>{item.type}</span>
                        <span>{item.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {phase1Result && (
                <div>
                  <button
                    className="btn btn-secondary"
                    onClick={() => downloadCSV(
                      phase1Result.clients,
                      'phase1_clients.csv',
                      ['Client ID', 'A#', 'First Name', 'Middle Name', 'Family Name', 'Phone Number', 'Client Email', 'Address Line 1', 'Address Line 2', 'City', 'State', 'Zip (5)', 'Country', 'Entry Date', 'Place of Entry', 'DOB', 'clio_contact_id', 'Bahr Client', 'uscis_flatpack_data']
                    )}
                  >
                    Download clients.csv ({phase1Result.clients.length} records)
                  </button>

                  <div className="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th>Client ID</th>
                          <th>A#</th>
                          <th>Name</th>
                          <th>clio_contact_id</th>
                        </tr>
                      </thead>
                      <tbody>
                        {phase1Result.clients.slice(0, 5).map((row, i) => (
                          <tr key={i}>
                            <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Client ID']}</td>
                            <td>{row['A#'] || '—'}</td>
                            <td>{row['First Name']} {row['Family Name']}</td>
                            <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['clio_contact_id'] || '—'}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  {/* API Upload Section */}
                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                    <h4 style={{ color: '#a5b4fc', marginBottom: '1rem' }}>API Upload to Airtable</h4>
                    <p style={{ fontSize: '0.8rem', color: '#71717a', marginBottom: '1rem' }}>
                      Upload directly to Client Info table with duplicate checking.
                    </p>

                    {/* API Config */}
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                      <div>
                        <label style={{ fontSize: '0.75rem', color: '#94a3b8', display: 'block', marginBottom: '0.25rem' }}>API Key</label>
                        <input
                          type="password"
                          value={airtableApiKey}
                          onChange={(e) => setAirtableApiKey(e.target.value)}
                          placeholder="pat..."
                          style={{ width: '100%', padding: '0.5rem', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: '#e2e8f0', fontSize: '0.8rem' }}
                        />
                      </div>
                      <div>
                        <label style={{ fontSize: '0.75rem', color: '#94a3b8', display: 'block', marginBottom: '0.25rem' }}>Base ID</label>
                        <input
                          type="text"
                          value={devToolsBaseId}
                          onChange={(e) => setDevToolsBaseId(e.target.value)}
                          placeholder="app..."
                          style={{ width: '100%', padding: '0.5rem', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: '#e2e8f0', fontSize: '0.8rem' }}
                        />
                      </div>
                    </div>

                    {/* Stats Row */}
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '0.5rem', marginBottom: '1rem' }}>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#6366f1' }}>{phase1Result?.clients?.length || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Source</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#94a3b8' }}>{syncState.existingRecords.length}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>In Airtable</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#10b981' }}>{syncState.preview.new.length}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>New</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#f59e0b' }}>{syncState.preview.existing.length}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Duplicates</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#ef4444' }}>{syncState.preview.errors.length}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Errors</div>
                      </div>
                    </div>

                    {/* Field Mapping Section */}
                    <div style={{ marginBottom: '1rem' }}>
                      <button
                        onClick={() => setShowFieldMapping(!showFieldMapping)}
                        style={{
                          background: 'transparent',
                          border: '1px solid #475569',
                          borderRadius: '6px',
                          padding: '0.5rem 1rem',
                          color: '#a5b4fc',
                          cursor: 'pointer',
                          fontSize: '0.8rem',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '0.5rem'
                        }}
                      >
                        <span style={{ transform: showFieldMapping ? 'rotate(90deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▶</span>
                        Field Mapping ({Object.values(fieldMapping).filter(f => f.enabled).length}/{Object.keys(fieldMapping).length} fields enabled)
                      </button>

                      {showFieldMapping && (
                        <div style={{ marginTop: '0.75rem', background: '#1e293b', borderRadius: '6px', padding: '1rem' }}>
                          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                            <span style={{ fontSize: '0.75rem', color: '#94a3b8' }}>Configure which fields to upload to Airtable</span>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                              <button
                                onClick={() => setFieldMapping(prev => Object.fromEntries(Object.entries(prev).map(([k, v]) => [k, { ...v, enabled: true }])))}
                                style={{ fontSize: '0.7rem', padding: '0.25rem 0.5rem', background: '#334155', border: 'none', borderRadius: '4px', color: '#94a3b8', cursor: 'pointer' }}
                              >
                                Enable All
                              </button>
                              <button
                                onClick={() => setFieldMapping(prev => Object.fromEntries(Object.entries(prev).map(([k, v]) => [k, { ...v, enabled: false }])))}
                                style={{ fontSize: '0.7rem', padding: '0.25rem 0.5rem', background: '#334155', border: 'none', borderRadius: '4px', color: '#94a3b8', cursor: 'pointer' }}
                              >
                                Disable All
                              </button>
                            </div>
                          </div>
                          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '0.5rem' }}>
                            {Object.entries(fieldMapping).map(([sourceField, config]) => (
                              <label
                                key={sourceField}
                                style={{
                                  display: 'flex',
                                  alignItems: 'center',
                                  gap: '0.5rem',
                                  padding: '0.5rem',
                                  background: config.enabled ? 'rgba(99, 102, 241, 0.2)' : 'rgba(0,0,0,0.2)',
                                  borderRadius: '4px',
                                  cursor: 'pointer',
                                  border: config.enabled ? '1px solid rgba(99, 102, 241, 0.5)' : '1px solid transparent',
                                  fontSize: '0.75rem'
                                }}
                              >
                                <input
                                  type="checkbox"
                                  checked={config.enabled}
                                  onChange={() => toggleFieldMapping(sourceField)}
                                  style={{ accentColor: '#6366f1' }}
                                />
                                <span style={{ color: config.enabled ? '#e2e8f0' : '#64748b' }}>
                                  {sourceField}
                                </span>
                              </label>
                            ))}
                          </div>
                          <div style={{ marginTop: '0.75rem', fontSize: '0.7rem', color: '#64748b' }}>
                            Note: Bahr Client (checkbox) is always included automatically.
                          </div>
                        </div>
                      )}
                    </div>

                    {/* Action Buttons */}
                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
                      <button
                        className="btn btn-primary"
                        onClick={fetchExistingClients}
                        disabled={syncState.loading || !airtableApiKey || !devToolsBaseId}
                        style={{ fontSize: '0.8rem' }}
                      >
                        {syncState.loading ? 'Loading...' : '1. Fetch Existing'}
                      </button>
                      <button
                        className="btn btn-secondary"
                        onClick={checkDuplicates}
                        disabled={syncState.loading || syncState.existingRecords.length === 0}
                        style={{ fontSize: '0.8rem' }}
                      >
                        2. Check Duplicates
                      </button>
                      <button
                        onClick={() => uploadToAirtable(true)}
                        disabled={syncState.loading || syncState.preview.new.length === 0}
                        style={{ fontSize: '0.8rem', padding: '0.5rem 1rem', background: syncState.preview.new.length === 0 ? '#78716c' : '#f59e0b', color: 'white', border: 'none', borderRadius: '6px', cursor: syncState.preview.new.length === 0 ? 'not-allowed' : 'pointer', opacity: syncState.preview.new.length === 0 ? 0.6 : 1 }}
                      >
                        3. Test Upload (5)
                      </button>
                      <button
                        onClick={() => uploadToAirtable(false)}
                        disabled={syncState.loading || syncState.preview.new.length === 0}
                        style={{ fontSize: '0.8rem', padding: '0.5rem 1rem', background: syncState.preview.new.length === 0 ? '#78716c' : '#10b981', color: 'white', border: 'none', borderRadius: '6px', cursor: syncState.preview.new.length === 0 ? 'not-allowed' : 'pointer', opacity: syncState.preview.new.length === 0 ? 0.6 : 1 }}
                      >
                        4. Upload All ({syncState.preview.new.length})
                      </button>
                    </div>

                    {/* Helper message when Check Duplicates hasn't been run */}
                    {syncState.existingRecords.length > 0 && syncState.preview.new.length === 0 && syncState.preview.existing.length === 0 && syncState.preview.errors.length === 0 && (
                      <div style={{ marginBottom: '1rem', padding: '0.75rem', background: 'rgba(245, 158, 11, 0.1)', borderRadius: '6px', border: '1px solid rgba(245, 158, 11, 0.3)', fontSize: '0.8rem', color: '#fbbf24' }}>
                        Click "2. Check Duplicates" to compare your {phase1Result?.clients?.length || 0} source records against {syncState.existingRecords.length} existing Airtable records before uploading.
                      </div>
                    )}

                    {/* Progress Bar */}
                    {syncState.progress.total > 0 && (
                      <div style={{ marginBottom: '1rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: '#94a3b8', marginBottom: '0.25rem' }}>
                          <span>{syncState.progress.phase}</span>
                          <span>{syncState.progress.current} / {syncState.progress.total}</span>
                        </div>
                        <div style={{ background: '#1e293b', borderRadius: '4px', height: '8px', overflow: 'hidden' }}>
                          <div style={{ height: '100%', background: 'linear-gradient(90deg, #6366f1, #10b981)', width: `${(syncState.progress.current / syncState.progress.total) * 100}%`, transition: 'width 0.3s' }} />
                        </div>
                      </div>
                    )}

                    {/* Logs */}
                    {syncState.logs.length > 0 && (
                      <div style={{ background: '#0f172a', borderRadius: '6px', padding: '0.75rem', maxHeight: '150px', overflowY: 'auto', fontSize: '0.75rem', fontFamily: 'monospace' }}>
                        {syncState.logs.map((log, i) => (
                          <div key={i} style={{ color: log.type === 'error' ? '#ef4444' : log.type === 'success' ? '#10b981' : log.type === 'warning' ? '#f59e0b' : '#94a3b8', marginBottom: '0.25rem' }}>
                            <span style={{ color: '#475569' }}>[{log.time}]</span> {log.message}
                          </div>
                        ))}
                      </div>
                    )}

                    {/* Preview of new records */}
                    {syncState.preview.new.length > 0 && (
                      <div style={{ marginTop: '1rem' }}>
                        <h5 style={{ fontSize: '0.8rem', color: '#10b981', marginBottom: '0.5rem' }}>New Records Preview (first 10)</h5>
                        <div style={{ maxHeight: '200px', overflowY: 'auto', fontSize: '0.7rem' }}>
                          <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                              <tr style={{ background: '#1e293b' }}>
                                <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Name</th>
                                <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>A#</th>
                                <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>clio_contact_id</th>
                              </tr>
                            </thead>
                            <tbody>
                              {syncState.preview.new.slice(0, 10).map((item, i) => (
                                <tr key={i} style={{ borderBottom: '1px solid #1e293b' }}>
                                  <td style={{ padding: '0.5rem' }}>{item.client['First Name']} {item.client['Family Name']}</td>
                                  <td style={{ padding: '0.5rem' }}>{item.client['A#'] || '—'}</td>
                                  <td style={{ padding: '0.5rem', fontFamily: 'monospace' }}>{item.client['clio_contact_id'] || '—'}</td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      </div>
                    )}

                    {/* Duplicates preview */}
                    {syncState.preview.existing.length > 0 && (
                      <div style={{ marginTop: '1rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                          <h5 style={{ fontSize: '0.8rem', color: '#f59e0b', margin: 0 }}>Duplicates Found ({syncState.preview.existing.length}) - Will Skip</h5>
                          <button
                            onClick={exportDuplicatesCSV}
                            style={{
                              padding: '0.25rem 0.5rem',
                              background: '#f59e0b',
                              color: '#000',
                              border: 'none',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              fontSize: '0.7rem',
                              fontWeight: 600
                            }}
                          >
                            Export CSV
                          </button>
                        </div>
                        <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.7rem' }}>
                          <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                              <tr style={{ background: '#1e293b' }}>
                                <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Name</th>
                                <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Matched On</th>
                              </tr>
                            </thead>
                            <tbody>
                              {syncState.preview.existing.slice(0, 10).map((item, i) => (
                                <tr key={i} style={{ borderBottom: '1px solid #1e293b' }}>
                                  <td style={{ padding: '0.5rem' }}>{item.client['First Name']} {item.client['Family Name']}</td>
                                  <td style={{ padding: '0.5rem', color: '#f59e0b' }}>{item.matchedOn}</td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      </div>
                    )}
                  </div>

                  <div style={{ marginTop: '1rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Next Steps (after upload)</h4>
                    <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                      <li>Export Client Info table (include Record ID and clio_contact_id columns)</li>
                      <li>Proceed to Phase 2 with the export</li>
                    </ol>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 2: Case Master Views */}
          {activePhase === 2 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 2: Case Master Views</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Create Case Master Views from Clio Matters with aggregated notes. Links to Clients via Airtable Record ID.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {/* Airtable Client Fetch - Special handling */}
                <div>
                  <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    Airtable Clients
                    <span className="badge badge-warning">Required</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>Fetch directly from Airtable</p>

                  <div style={{
                    border: phase2Data.airtableClients?.rows?.length ? '2px solid #22c55e' : '2px dashed #3f3f46',
                    borderRadius: '8px',
                    padding: '1rem',
                    background: phase2Data.airtableClients?.rows?.length ? 'rgba(34, 197, 94, 0.1)' : 'transparent',
                    minHeight: '80px',
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'center',
                    alignItems: 'center',
                    gap: '0.5rem'
                  }}>
                    {phase2Data.airtableClients?.rows?.length ? (
                      <div style={{ textAlign: 'center' }}>
                        <span style={{ color: '#22c55e', fontSize: '1.25rem' }}>✓</span>
                        <div style={{ color: '#22c55e', fontWeight: 600 }}>{phase2Data.airtableClients.rows.length} clients</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>from Airtable</div>
                        <button
                          onClick={fetchPhase2Clients}
                          disabled={phase2Sync.loading}
                          style={{
                            marginTop: '0.5rem',
                            padding: '0.25rem 0.5rem',
                            background: 'transparent',
                            color: '#94a3b8',
                            border: '1px solid #475569',
                            borderRadius: '4px',
                            cursor: 'pointer',
                            fontSize: '0.7rem'
                          }}
                        >
                          {phase2Sync.loading ? 'Refreshing...' : 'Refresh'}
                        </button>
                      </div>
                    ) : (
                      <button
                        onClick={fetchPhase2Clients}
                        disabled={phase2Sync.loading || !airtableApiKey || !devToolsBaseId}
                        style={{
                          padding: '0.5rem 1rem',
                          background: !airtableApiKey || !devToolsBaseId ? '#374151' : '#6366f1',
                          color: 'white',
                          border: 'none',
                          borderRadius: '6px',
                          cursor: !airtableApiKey || !devToolsBaseId ? 'not-allowed' : 'pointer',
                          fontSize: '0.8rem',
                          opacity: !airtableApiKey || !devToolsBaseId ? 0.6 : 1
                        }}
                      >
                        {phase2Sync.loading ? 'Fetching...' : 'Fetch from Airtable'}
                      </button>
                    )}
                    {!airtableApiKey || !devToolsBaseId ? (
                      <div style={{ fontSize: '0.7rem', color: '#f59e0b', textAlign: 'center' }}>
                        Enter API key in Phase 1 first
                      </div>
                    ) : null}
                  </div>

                  {/* Progress bar */}
                  {phase2Sync.loading && (
                    <div style={{ marginTop: '0.5rem' }}>
                      <div style={{ background: '#1e293b', borderRadius: '4px', height: '4px', overflow: 'hidden' }}>
                        <div style={{
                          height: '100%',
                          background: 'linear-gradient(90deg, #6366f1, #a855f7)',
                          width: '100%',
                          animation: 'pulse 1.5s ease-in-out infinite'
                        }} />
                      </div>
                    </div>
                  )}
                </div>

                {/* Clio Matters and Notes - CSV uploads */}
                {[
                  { key: 'clioMatters', label: 'Clio Matters Export', desc: 'UniqueId, ClientId, DisplayNumber', required: true },
                  { key: 'clioNotes', label: 'Clio Matter Notes', desc: 'MatterId, Subject, Detail, Date', required: false },
                ].map(({ key, label, desc, required }) => (
                  <div key={key}>
                    <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                      {label}
                      {required && <span className="badge badge-warning">Required</span>}
                    </h4>
                    <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>{desc}</p>
                    <div className="upload-zone-wrapper">
                      {phase2Files[key] && (
                        <button className="file-remove-btn" onClick={clearPhase2File(key)} title="Remove file">×</button>
                      )}
                      <label className={`upload-zone ${phase2Files[key] ? 'has-file' : ''}`}>
                        <input type="file" accept=".csv" onChange={handleFileUpload(2, key)} style={{ display: 'none' }} />
                        {phase2Files[key] ? (
                          <div>
                            <span style={{ color: '#22c55e' }}>✓</span> {phase2Files[key].name}
                            <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{phase2Data[key]?.rows?.length || 0} rows</div>
                          </div>
                        ) : (
                          <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                        )}
                      </label>
                    </div>
                  </div>
                ))}
              </div>

              {/* Phase 2 Logs */}
              {phase2Sync.logs.length > 0 && (
                <div style={{ marginBottom: '1rem', background: '#0f172a', borderRadius: '6px', padding: '0.75rem', maxHeight: '100px', overflowY: 'auto', fontSize: '0.75rem', fontFamily: 'monospace' }}>
                  {phase2Sync.logs.map((log, i) => (
                    <div key={i} style={{ color: log.type === 'error' ? '#ef4444' : log.type === 'success' ? '#10b981' : '#94a3b8', marginBottom: '0.25rem' }}>
                      <span style={{ color: '#475569' }}>[{log.time}]</span> {log.message}
                    </div>
                  ))}
                </div>
              )}

              {/* Field Mapping Configuration */}
              <div style={{ marginBottom: '1.5rem' }}>
                <button
                  onClick={() => setShowFieldMapping(!showFieldMapping)}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.5rem',
                    background: 'transparent',
                    border: '1px solid #3f3f46',
                    borderRadius: '6px',
                    padding: '0.5rem 1rem',
                    color: '#a1a1aa',
                    cursor: 'pointer',
                    fontSize: '0.875rem',
                    width: '100%',
                    justifyContent: 'space-between'
                  }}
                >
                  <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    <span style={{ fontSize: '1rem' }}>⚙</span>
                    Field Mapping Configuration
                    {caseMasterSchema.loaded && (
                      <span style={{ fontSize: '0.7rem', color: '#10b981', marginLeft: '0.5rem' }}>
                        ({caseMasterSchema.fields.length} fields loaded)
                      </span>
                    )}
                  </span>
                  <span style={{ transform: showFieldMapping ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                </button>

                {showFieldMapping && (
                  <div style={{ marginTop: '0.5rem', padding: '1rem', background: '#18181b', borderRadius: '8px', border: '1px solid #3f3f46' }}>
                    <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '1rem' }}>
                      Configure how input fields from Clio exports map to output fields in Case Master Views.
                    </p>

                    {/* Schema Fetch Section */}
                    <div style={{ marginBottom: '1rem', padding: '0.75rem', background: '#0f172a', borderRadius: '6px' }}>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                        <span style={{ fontSize: '0.75rem', color: '#94a3b8' }}>
                          Table: <code style={{ color: '#6ee7b7' }}>{CASE_MASTER_VIEW_TABLE_ID}</code>
                        </span>
                        <button
                          onClick={fetchCaseMasterViewSchema}
                          disabled={caseMasterSchema.loading || !airtableApiKey}
                          style={{
                            padding: '0.35rem 0.75rem',
                            background: caseMasterSchema.loading ? '#334155' : '#6366f1',
                            border: 'none',
                            borderRadius: '4px',
                            color: 'white',
                            cursor: caseMasterSchema.loading || !airtableApiKey ? 'not-allowed' : 'pointer',
                            fontSize: '0.75rem',
                            opacity: !airtableApiKey ? 0.5 : 1,
                          }}
                        >
                          {caseMasterSchema.loading ? 'Loading...' : caseMasterSchema.loaded ? 'Refresh Schema' : 'Fetch Schema'}
                        </button>
                      </div>
                      {caseMasterSchema.error && (
                        <div style={{ fontSize: '0.7rem', color: '#ef4444', marginTop: '0.5rem' }}>
                          {caseMasterSchema.error}
                        </div>
                      )}
                      {!airtableApiKey && (
                        <div style={{ fontSize: '0.7rem', color: '#f59e0b', marginTop: '0.5rem' }}>
                          Enter API key above to fetch schema
                        </div>
                      )}
                    </div>

                    {/* Output Field Mappings */}
                    <div style={{ marginBottom: '1.5rem' }}>
                      <h5 style={{ fontSize: '0.8rem', color: '#e4e4e7', marginBottom: '0.75rem' }}>Output Field Mappings</h5>
                      {!caseMasterSchema.loaded ? (
                        <div style={{ padding: '1rem', textAlign: 'center', color: '#71717a', fontSize: '0.8rem' }}>
                          Click "Fetch Schema" to load Airtable fields
                        </div>
                      ) : (
                        <div style={{ display: 'grid', gap: '0.5rem' }}>
                          {Object.entries(phase2FieldMapping.outputFields).map(([fieldId, config]) => (
                            <div key={fieldId} style={{
                              display: 'grid',
                              gridTemplateColumns: '24px 1fr 20px 1fr',
                              gap: '0.5rem',
                              alignItems: 'center',
                              padding: '0.5rem',
                              background: config.enabled ? 'rgba(34, 197, 94, 0.05)' : 'rgba(113, 113, 122, 0.1)',
                              borderRadius: '4px',
                              border: '1px solid ' + (config.enabled ? 'rgba(34, 197, 94, 0.2)' : '#27272a')
                            }}>
                              <input
                                type="checkbox"
                                checked={config.enabled}
                                onChange={(e) => setPhase2FieldMapping(prev => ({
                                  ...prev,
                                  outputFields: {
                                    ...prev.outputFields,
                                    [fieldId]: { ...config, enabled: e.target.checked }
                                  }
                                }))}
                                style={{ width: '16px', height: '16px', cursor: 'pointer' }}
                              />
                              <div>
                                <span style={{ fontSize: '0.7rem', color: '#a1a1aa' }}>Input: </span>
                                <select
                                  value={config.inputField}
                                  onChange={(e) => setPhase2FieldMapping(prev => ({
                                    ...prev,
                                    outputFields: {
                                      ...prev.outputFields,
                                      [fieldId]: { ...config, inputField: e.target.value, enabled: e.target.value ? true : config.enabled }
                                    }
                                  }))}
                                  style={{
                                    padding: '0.25rem 0.5rem',
                                    background: '#1e293b',
                                    border: '1px solid #475569',
                                    borderRadius: '4px',
                                    color: config.inputField ? '#6ee7b7' : '#71717a',
                                    fontSize: '0.7rem',
                                    cursor: 'pointer',
                                    maxWidth: '200px',
                                  }}
                                >
                                  <option value="">-- Select Input --</option>
                                  <optgroup label="Clio Matter Fields">
                                    {AVAILABLE_INPUT_FIELDS.filter(f => !f.id.startsWith('_')).map(field => (
                                      <option key={field.id} value={field.id}>{field.name}</option>
                                    ))}
                                  </optgroup>
                                  <optgroup label="Computed Fields">
                                    {AVAILABLE_INPUT_FIELDS.filter(f => f.id.startsWith('_')).map(field => (
                                      <option key={field.id} value={field.id}>{field.name}</option>
                                    ))}
                                  </optgroup>
                                </select>
                              </div>
                              <span style={{ color: '#6366f1', fontSize: '1rem', textAlign: 'center' }}>→</span>
                              <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                <span style={{
                                  fontSize: '0.75rem',
                                  color: config.enabled ? '#e4e4e7' : '#52525b',
                                  fontFamily: 'monospace'
                                }}>
                                  {config.fieldName}
                                </span>
                                <span style={{ fontSize: '0.6rem', color: '#52525b' }}>
                                  {config.fieldType} • {fieldId}
                                </span>
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>

                    {/* Status Value Mapping */}
                    <div style={{ marginBottom: '1rem' }}>
                      <h5 style={{ fontSize: '0.8rem', color: '#e4e4e7', marginBottom: '0.75rem' }}>Status Value Transformations</h5>
                      <div style={{ display: 'grid', gap: '0.5rem' }}>
                        {Object.entries(phase2FieldMapping.statusMapping).map(([inputValue, outputValue]) => (
                          <div key={inputValue} style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 20px 1fr 32px',
                            gap: '0.5rem',
                            alignItems: 'center'
                          }}>
                            <input
                              type="text"
                              value={inputValue}
                              readOnly
                              style={{
                                padding: '0.35rem 0.5rem',
                                background: '#1f1f23',
                                border: '1px solid #3f3f46',
                                borderRadius: '4px',
                                color: '#a1a1aa',
                                fontSize: '0.75rem'
                              }}
                            />
                            <span style={{ color: '#6366f1', fontSize: '1rem', textAlign: 'center' }}>→</span>
                            <input
                              type="text"
                              value={outputValue}
                              onChange={(e) => setPhase2FieldMapping(prev => ({
                                ...prev,
                                statusMapping: {
                                  ...prev.statusMapping,
                                  [inputValue]: e.target.value
                                }
                              }))}
                              style={{
                                padding: '0.35rem 0.5rem',
                                background: '#27272a',
                                border: '1px solid #3f3f46',
                                borderRadius: '4px',
                                color: '#e4e4e7',
                                fontSize: '0.75rem'
                              }}
                            />
                            <button
                              onClick={() => setPhase2FieldMapping(prev => {
                                const newMapping = { ...prev.statusMapping };
                                delete newMapping[inputValue];
                                return { ...prev, statusMapping: newMapping };
                              })}
                              style={{
                                padding: '0.25rem',
                                background: 'rgba(239, 68, 68, 0.1)',
                                border: '1px solid rgba(239, 68, 68, 0.3)',
                                borderRadius: '4px',
                                color: '#ef4444',
                                cursor: 'pointer',
                                fontSize: '0.75rem'
                              }}
                            >
                              ✕
                            </button>
                          </div>
                        ))}
                        <button
                          onClick={() => {
                            const newKey = `Status${Object.keys(phase2FieldMapping.statusMapping).length + 1}`;
                            setPhase2FieldMapping(prev => ({
                              ...prev,
                              statusMapping: { ...prev.statusMapping, [newKey]: newKey }
                            }));
                          }}
                          style={{
                            padding: '0.35rem 0.75rem',
                            background: 'transparent',
                            border: '1px dashed #3f3f46',
                            borderRadius: '4px',
                            color: '#6366f1',
                            cursor: 'pointer',
                            fontSize: '0.75rem'
                          }}
                        >
                          + Add Status Mapping
                        </button>
                      </div>
                    </div>

                    {/* Options */}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', paddingTop: '0.5rem', borderTop: '1px solid #27272a' }}>
                      <input
                        type="checkbox"
                        id="includeInternalFields"
                        checked={phase2FieldMapping.includeInternalFields}
                        onChange={(e) => setPhase2FieldMapping(prev => ({
                          ...prev,
                          includeInternalFields: e.target.checked
                        }))}
                        style={{ width: '14px', height: '14px', cursor: 'pointer' }}
                      />
                      <label htmlFor="includeInternalFields" style={{ fontSize: '0.75rem', color: '#a1a1aa', cursor: 'pointer' }}>
                        Include internal fields (_client_name, _note_count) in CSV export
                      </label>
                    </div>
                  </div>
                )}
              </div>

              {/* How it works explanation */}
              <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                <h4 style={{ color: '#a5b4fc', marginBottom: '0.75rem', fontSize: '0.875rem' }}>How Case Matters are Created</h4>
                <ol style={{ fontSize: '0.8rem', color: '#94a3b8', paddingLeft: '1.25rem', lineHeight: '1.6' }}>
                  <li><strong style={{ color: '#e2e8f0' }}>Client Linking:</strong> Each Clio matter has a ClientId that maps to clio_contact_id in Airtable. The system finds the matching Airtable Record ID to create the link.</li>
                  <li><strong style={{ color: '#e2e8f0' }}>Note Aggregation:</strong> All notes for a matter are combined chronologically, formatted with timestamps and creators for easy reading.</li>
                  <li><strong style={{ color: '#e2e8f0' }}>Status Mapping:</strong> Clio "Open" status becomes "Active", preserving other statuses as-is.</li>
                  <li><strong style={{ color: '#e2e8f0' }}>Validation:</strong> Matters without matching clients are flagged in the report but still included (without the Client link).</li>
                </ol>
              </div>

              <button
                className="btn btn-primary"
                onClick={runPhase2}
                disabled={!phase2Data.airtableClients?.rows?.length || !phase2Data.clioMatters?.rows?.length || phase2Sync.loading}
                style={{ marginBottom: '1.5rem' }}
              >
                {phase2Sync.loading ? 'Generating...' : 'Generate case_master_views.csv'}
              </button>

              {phase2Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Validation Report</h4>
                  <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.8rem' }}>
                    {phase2Report.map((item, i) => (
                      <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                        <span className={`badge badge-${item.type}`}>{item.type}</span>
                        <span>{item.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {phase2Result && (
                <div>
                  {/* CSV Download Section */}
                  <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.75rem' }}>
                      <h4 style={{ color: '#4ade80', margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                        <span style={{ fontSize: '1.25rem' }}>📥</span> Download CSV
                      </h4>
                      <span style={{ fontSize: '0.75rem', color: '#94a3b8', background: '#1e293b', padding: '0.25rem 0.5rem', borderRadius: '4px' }}>
                        {phase2Result.caseMaster.length} records ready
                      </span>
                    </div>
                    <div style={{ display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                      <button
                        className="btn btn-primary"
                        onClick={() => {
                          // Core merged fields - always available regardless of schema
                          const coreHeaders = [
                            'Display_Number', 'Client_Name', 'Description', 'Status', 'Mapped_Status',
                            'Open_Date', 'Close_Date', 'Notes', 'Note_Count', 'Airtable_Record_ID', 'Matter_ID', 'Client_ID'
                          ];
                          downloadCSV(phase2Result.caseMaster, 'case_master_views.csv', coreHeaders);
                        }}
                        style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                      >
                        <span>⬇</span> Download case_master_views.csv
                      </button>
                      <button
                        className="btn btn-secondary"
                        onClick={() => {
                          // All fields including schema-mapped ones
                          const firstRecord = phase2Result.caseMaster[0] || {};
                          const allHeaders = Object.keys(firstRecord).filter(k => !k.startsWith('_'));
                          downloadCSV(phase2Result.caseMaster, 'case_master_views_full.csv', allHeaders);
                        }}
                        style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                      >
                        <span>⬇</span> Download All Fields
                      </button>
                    </div>
                    <p style={{ fontSize: '0.7rem', color: '#71717a', marginTop: '0.75rem', marginBottom: 0 }}>
                      Merged data: Matter info + Notes + Airtable Record ID for client linking
                    </p>
                  </div>

                  {/* JSON Download Section */}
                  <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.75rem' }}>
                      <h4 style={{ color: '#a5b4fc', margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                        <span style={{ fontSize: '1.25rem' }}>📦</span> Download JSON
                      </h4>
                      <span style={{ fontSize: '0.75rem', color: '#94a3b8', background: '#1e293b', padding: '0.25rem 0.5rem', borderRadius: '4px' }}>
                        Flatpacked format
                      </span>
                    </div>
                    <div style={{ display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                      <button
                        className="btn btn-primary"
                        onClick={downloadPhase2JSON}
                        style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: '#6366f1' }}
                      >
                        <span>⬇</span> Download case_master_views.json
                      </button>
                    </div>
                    <p style={{ fontSize: '0.7rem', color: '#71717a', marginTop: '0.75rem', marginBottom: 0 }}>
                      Full data as JSON: Clio matters as master objects, merged Airtable data, formatted notes, and flatpack field
                    </p>
                  </div>

                  <div className="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th>Matter</th>
                          <th>Client</th>
                          <th>Status</th>
                          <th>Description</th>
                          <th>Airtable Link</th>
                          <th>Notes</th>
                        </tr>
                      </thead>
                      <tbody>
                        {phase2Result.caseMaster.slice(0, 10).map((row, i) => {
                          const recordId = row['Airtable_Record_ID'] || row['_client_record_id'];
                          return (
                            <tr key={i}>
                              <td style={{ fontFamily: 'monospace' }}>{row['Display_Number'] || row['_displayNumber'] || '—'}</td>
                              <td>{(row['Client_Name'] || row['_client_name'])?.slice(0, 18) || '—'}</td>
                              <td style={{ fontSize: '0.75rem' }}>{row['Mapped_Status'] || row['Status'] || '—'}</td>
                              <td style={{ fontSize: '0.75rem', maxWidth: '150px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                {row['Description']?.slice(0, 30) || '—'}
                              </td>
                              <td style={{ fontFamily: 'monospace', fontSize: '0.7rem', color: recordId ? '#4ade80' : '#f59e0b' }}>
                                {recordId ? `✓ ${recordId.slice(0, 10)}...` : '(no match)'}
                              </td>
                              <td>{row['Note_Count'] || row['_note_count']} notes</td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>

                  {/* Client Matching Test Section */}
                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: phase2Result?.matchingStats?.linkedCount > 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)', borderRadius: '8px', border: `1px solid ${phase2Result?.matchingStats?.linkedCount > 0 ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)'}` }}>
                    <h4 style={{ color: phase2Result?.matchingStats?.linkedCount > 0 ? '#4ade80' : '#f87171', marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                      {phase2Result?.matchingStats?.linkedCount > 0 ? '✓' : '✗'} Client Matching Test
                      <span style={{ fontSize: '0.75rem', fontWeight: 'normal', color: '#94a3b8' }}>
                        (Clio {phase2Result?.matchingStats?.detectedClioIdField || 'ClientId'} → Airtable clio_contact_id → Record ID)
                      </span>
                    </h4>

                    {/* Matching Stats */}
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.5rem', marginBottom: '1rem' }}>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#818cf8' }}>{phase2Result?.matchingStats?.airtableClientsLoaded || 0}</div>
                        <div style={{ fontSize: '0.65rem', color: '#71717a' }}>Airtable Clients<br/>(with clio_contact_id)</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#6366f1' }}>{phase2Result?.matchingStats?.totalMatters || 0}</div>
                        <div style={{ fontSize: '0.65rem', color: '#71717a' }}>Clio Matters<br/>(using {phase2Result?.matchingStats?.detectedClioIdField || 'no ID field'})</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#22c55e' }}>{phase2Result?.matchingStats?.linkedCount || 0}</div>
                        <div style={{ fontSize: '0.65rem', color: '#71717a' }}>Matched<br/>(will link)</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#f59e0b' }}>{phase2Result?.matchingStats?.unlinkedCount || 0}</div>
                        <div style={{ fontSize: '0.65rem', color: '#71717a' }}>Unmatched<br/>(no link)</div>
                      </div>
                    </div>

                    {/* Sample ID Comparison */}
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px' }}>
                        <div style={{ fontSize: '0.7rem', color: '#a5b4fc', marginBottom: '0.5rem', fontWeight: 'bold' }}>Sample Airtable clio_contact_id values:</div>
                        <div style={{ fontFamily: 'monospace', fontSize: '0.7rem', color: '#94a3b8' }}>
                          {phase2Result?.matchingStats?.sampleAirtableIds?.length > 0
                            ? phase2Result.matchingStats.sampleAirtableIds.map((id, i) => <div key={i}>"{id}"</div>)
                            : <span style={{ color: '#f87171' }}>No clio_contact_id values found in Airtable export</span>
                          }
                        </div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px' }}>
                        <div style={{ fontSize: '0.7rem', color: '#a5b4fc', marginBottom: '0.5rem', fontWeight: 'bold' }}>Sample Clio Matter {phase2Result?.matchingStats?.detectedClioIdField || 'client ID'} values:</div>
                        <div style={{ fontFamily: 'monospace', fontSize: '0.7rem', color: '#94a3b8' }}>
                          {phase2Result?.matchingStats?.sampleClioClientIds?.length > 0 && phase2Result.matchingStats.sampleClioClientIds.some(id => id)
                            ? phase2Result.matchingStats.sampleClioClientIds.map((id, i) => <div key={i}>"{id || '(empty)'}"</div>)
                            : <span style={{ color: '#f87171' }}>No {phase2Result?.matchingStats?.detectedClioIdField || 'client ID'} values found. Available columns: {phase2Result?.matchingStats?.clioMattersColumns?.join(', ') || 'none'}</span>
                          }
                        </div>
                      </div>
                    </div>

                    {/* Sample Matches */}
                    {phase2Result?.matchingStats?.sampleMatches?.length > 0 && (
                      <div style={{ background: 'rgba(34, 197, 94, 0.1)', padding: '0.75rem', borderRadius: '6px', marginBottom: '0.75rem' }}>
                        <div style={{ fontSize: '0.7rem', color: '#4ade80', marginBottom: '0.5rem', fontWeight: 'bold' }}>✓ Sample Successful Matches:</div>
                        <table style={{ width: '100%', fontSize: '0.7rem', borderCollapse: 'collapse' }}>
                          <thead>
                            <tr style={{ borderBottom: '1px solid #374151' }}>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>Matter</th>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>Client</th>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>Clio ClientId</th>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>→ Airtable Record ID</th>
                            </tr>
                          </thead>
                          <tbody>
                            {phase2Result.matchingStats.sampleMatches.map((match, i) => (
                              <tr key={i} style={{ borderBottom: '1px solid #1e293b' }}>
                                <td style={{ padding: '0.25rem', color: '#e2e8f0' }}>{match.displayNumber}</td>
                                <td style={{ padding: '0.25rem', color: '#94a3b8' }}>{match.clientName?.slice(0, 20)}</td>
                                <td style={{ padding: '0.25rem', fontFamily: 'monospace', color: '#818cf8' }}>{match.clioClientId}</td>
                                <td style={{ padding: '0.25rem', fontFamily: 'monospace', color: '#4ade80' }}>{match.airtableRecordId}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    )}

                    {/* Sample Unmatched */}
                    {phase2Result?.matchingStats?.sampleUnmatched?.length > 0 && (
                      <div style={{ background: 'rgba(251, 191, 36, 0.1)', padding: '0.75rem', borderRadius: '6px' }}>
                        <div style={{ fontSize: '0.7rem', color: '#fbbf24', marginBottom: '0.5rem', fontWeight: 'bold' }}>✗ Sample Unmatched (ClientId not found in Airtable):</div>
                        <table style={{ width: '100%', fontSize: '0.7rem', borderCollapse: 'collapse' }}>
                          <thead>
                            <tr style={{ borderBottom: '1px solid #374151' }}>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>Matter</th>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>Client</th>
                              <th style={{ textAlign: 'left', padding: '0.25rem', color: '#94a3b8' }}>Clio ClientId (not in Airtable)</th>
                            </tr>
                          </thead>
                          <tbody>
                            {phase2Result.matchingStats.sampleUnmatched.map((unmatched, i) => (
                              <tr key={i} style={{ borderBottom: '1px solid #1e293b' }}>
                                <td style={{ padding: '0.25rem', color: '#e2e8f0' }}>{unmatched.displayNumber}</td>
                                <td style={{ padding: '0.25rem', color: '#94a3b8' }}>{unmatched.clientName?.slice(0, 20)}</td>
                                <td style={{ padding: '0.25rem', fontFamily: 'monospace', color: '#f59e0b' }}>{unmatched.clioClientId || '(empty)'}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    )}
                  </div>

                  {/* Direct Upload to Airtable Section */}
                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                    <h4 style={{ color: '#a5b4fc', marginBottom: '1rem' }}>Direct Upload to Airtable</h4>
                    <p style={{ fontSize: '0.8rem', color: '#71717a', marginBottom: '1rem' }}>
                      Upload Case Master Views directly to Airtable. Base ID: <code style={{ background: '#1e293b', padding: '2px 6px', borderRadius: '4px' }}>{AIRTABLE_BASE_ID}</code>
                    </p>

                    {/* Stats Row */}
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '0.5rem', marginBottom: '1rem' }}>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#6366f1' }}>{phase2Result?.matchingStats?.totalMatters || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>Total Records</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#22c55e' }}>{phase2Result?.matchingStats?.linkedCount || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>With Client Link</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#f59e0b' }}>{phase2Result?.matchingStats?.unlinkedCount || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#71717a' }}>Without Link</div>
                      </div>
                    </div>

                    {/* Progress bar during upload */}
                    {phase2Sync.loading && phase2Sync.progress.phase === 'Uploading Case Master Views' && (
                      <div style={{ marginBottom: '1rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: '#94a3b8', marginBottom: '0.25rem' }}>
                          <span>{phase2Sync.progress.phase}</span>
                          <span>{phase2Sync.progress.current} / {phase2Sync.progress.total}</span>
                        </div>
                        <div style={{ background: '#1e293b', borderRadius: '4px', height: '8px', overflow: 'hidden' }}>
                          <div style={{
                            height: '100%',
                            background: 'linear-gradient(90deg, #6366f1, #a855f7)',
                            width: `${(phase2Sync.progress.current / phase2Sync.progress.total) * 100}%`,
                            transition: 'width 0.3s ease'
                          }} />
                        </div>
                      </div>
                    )}

                    {/* Upload Buttons */}
                    <div style={{ display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                      <button
                        onClick={() => uploadCaseMasterViewsToAirtable(true)}
                        disabled={phase2Sync.loading || !airtableApiKey}
                        style={{
                          padding: '0.5rem 1rem',
                          background: phase2Sync.loading || !airtableApiKey ? '#374151' : '#475569',
                          color: 'white',
                          border: 'none',
                          borderRadius: '6px',
                          cursor: phase2Sync.loading || !airtableApiKey ? 'not-allowed' : 'pointer',
                          fontSize: '0.8rem',
                          opacity: phase2Sync.loading || !airtableApiKey ? 0.6 : 1
                        }}
                      >
                        Test Upload (5 records)
                      </button>
                      <button
                        onClick={() => uploadCaseMasterViewsToAirtable(false)}
                        disabled={phase2Sync.loading || !airtableApiKey}
                        style={{
                          padding: '0.5rem 1rem',
                          background: phase2Sync.loading || !airtableApiKey ? '#374151' : '#6366f1',
                          color: 'white',
                          border: 'none',
                          borderRadius: '6px',
                          cursor: phase2Sync.loading || !airtableApiKey ? 'not-allowed' : 'pointer',
                          fontSize: '0.8rem',
                          opacity: phase2Sync.loading || !airtableApiKey ? 0.6 : 1
                        }}
                      >
                        Upload All ({phase2Result?.caseMaster?.length || 0} records)
                      </button>
                    </div>

                    {!airtableApiKey && (
                      <div style={{ marginTop: '0.75rem', fontSize: '0.75rem', color: '#f59e0b' }}>
                        Enter API key in Phase 1 first to enable uploads
                      </div>
                    )}
                  </div>

                  {/* Next Steps (after upload) */}
                  <div style={{ marginTop: '1rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Next Steps (after upload)</h4>
                    <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                      <li>Export Case Master View table from Airtable (include Record ID and clio_matter_id columns)</li>
                      <li>Proceed to Phase 3 with the Client Info and Case Master View exports</li>
                    </ol>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 3: Events & Relationships */}
          {activePhase === 3 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 3: Events & Relationships</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Create Events linked to Case Master Views, and Relationships between clients.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {[
                  { key: 'airtableClients', label: 'Airtable Client Export', desc: 'Record ID + clio_contact_id', required: true },
                  { key: 'airtableCaseMaster', label: 'Airtable Case Master Export', desc: 'Record ID + clio_matter_id + PP ID', required: true },
                  { key: 'clioEvents', label: 'Clio Events Export', desc: 'Google Calendar events', required: false },
                  { key: 'clioRelationships', label: 'Clio Contact Related Matters', desc: 'ContactId, MatterId, RelationshipDescription', required: false },
                ].map(({ key, label, desc, required }) => (
                  <div key={key}>
                    <h4 style={{ fontSize: '0.875rem', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                      {label}
                      {required && <span className="badge badge-warning">Required</span>}
                    </h4>
                    <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>{desc}</p>
                    <div className="upload-zone-wrapper">
                      {phase3Files[key] && (
                        <button className="file-remove-btn" onClick={clearPhase3File(key)} title="Remove file">×</button>
                      )}
                      <label className={`upload-zone ${phase3Files[key] ? 'has-file' : ''}`}>
                        <input type="file" accept=".csv" onChange={handleFileUpload(3, key)} style={{ display: 'none' }} />
                        {phase3Files[key] ? (
                          <div>
                            <span style={{ color: '#22c55e' }}>✓</span> {phase3Files[key].name}
                            <div style={{ fontSize: '0.75rem', color: '#71717a' }}>{phase3Data[key]?.rows?.length || 0} rows</div>
                          </div>
                        ) : (
                          <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                        )}
                      </label>
                    </div>
                  </div>
                ))}
              </div>

              <button
                className="btn btn-primary"
                onClick={runPhase3}
                disabled={!phase3Data.airtableClients?.rows?.length || !phase3Data.airtableCaseMaster?.rows?.length}
                style={{ marginBottom: '1.5rem' }}
              >
                Generate events.csv & relationships.csv
              </button>

              {phase3Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Validation Report</h4>
                  <div style={{ maxHeight: '150px', overflowY: 'auto', fontSize: '0.8rem' }}>
                    {phase3Report.map((item, i) => (
                      <div key={i} style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.25rem' }}>
                        <span className={`badge badge-${item.type}`}>{item.type}</span>
                        <span>{item.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {phase3Result && (
                <div>
                  <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem' }}>
                    <button
                      className="btn btn-secondary"
                      onClick={() => downloadCSV(
                        phase3Result.events,
                        'phase3_events.csv',
                        ['Case Master', 'A#', 'Hearing Date/Time', 'Event Type', 'Event Hearing Type', 'Court', 'Judge', 'MCH Attny', 'Bahr Client', '_summary']
                      )}
                    >
                      Download events.csv ({phase3Result.events.length})
                    </button>

                    <button
                      className="btn btn-secondary"
                      onClick={() => downloadCSV(
                        phase3Result.relationships,
                        'phase3_relationships.csv',
                        ['Case Master View', 'Object Client', 'Relationship', 'Bahr Client', '_contact_name', '_original_relationship']
                      )}
                    >
                      Download relationships.csv ({phase3Result.relationships.length})
                    </button>
                  </div>

                  {phase3Result.events.length > 0 && (
                    <div style={{ marginBottom: '1.5rem' }}>
                      <h4 style={{ marginBottom: '0.5rem' }}>Events Preview</h4>
                      <div className="table-container">
                        <table>
                          <thead>
                            <tr>
                              <th>Case Master (Record ID)</th>
                              <th>A#</th>
                              <th>Date/Time</th>
                              <th>Type</th>
                            </tr>
                          </thead>
                          <tbody>
                            {phase3Result.events.slice(0, 5).map((row, i) => (
                              <tr key={i}>
                                <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Case Master'] ? row['Case Master'].slice(0, 12) + '...' : '—'}</td>
                                <td>{row['A#']}</td>
                                <td>{row['Hearing Date/Time']?.slice(0, 16)}</td>
                                <td>{row['Event Hearing Type']}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}

                  {phase3Result.relationships.length > 0 && (
                    <div>
                      <h4 style={{ marginBottom: '0.5rem' }}>Relationships Preview</h4>
                      <div className="table-container">
                        <table>
                          <thead>
                            <tr>
                              <th>Case Master View</th>
                              <th>Object Client</th>
                              <th>Relationship</th>
                              <th>Contact Name</th>
                            </tr>
                          </thead>
                          <tbody>
                            {phase3Result.relationships.slice(0, 5).map((row, i) => (
                              <tr key={i}>
                                <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Case Master View'] ? row['Case Master View'].slice(0, 12) + '...' : '—'}</td>
                                <td style={{ fontFamily: 'monospace', fontSize: '0.7rem' }}>{row['Object Client'] ? row['Object Client'].slice(0, 12) + '...' : '—'}</td>
                                <td>{row['Relationship']}</td>
                                <td>{row['_contact_name']}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}

                  {/* Airtable Direct Upload Section */}
                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                    <h4 style={{ color: '#a5b4fc', marginBottom: '1rem' }}>Direct Upload to Airtable</h4>
                    <p style={{ fontSize: '0.8rem', color: '#71717a', marginBottom: '1rem' }}>
                      Upload events and relationships directly to Airtable. Base ID: <code style={{ background: '#1e293b', padding: '2px 6px', borderRadius: '4px' }}>{AIRTABLE_BASE_ID}</code>
                    </p>

                    {/* API Key Input */}
                    <div style={{ marginBottom: '1rem' }}>
                      <label style={{ fontSize: '0.75rem', color: '#94a3b8', display: 'block', marginBottom: '0.25rem' }}>Airtable API Key</label>
                      <input
                        type="password"
                        value={airtableApiKey}
                        onChange={(e) => setAirtableApiKey(e.target.value)}
                        placeholder="pat..."
                        style={{ width: '100%', padding: '0.5rem', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: '#e2e8f0', fontSize: '0.8rem' }}
                      />
                    </div>

                    {/* Stats Row */}
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.5rem', marginBottom: '1rem' }}>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#6366f1' }}>{phase3Result?.events?.length || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Events</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#10b981' }}>{phase3Result?.events?.filter(e => e['Case Master']).length || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Linked Events</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#8b5cf6' }}>{phase3Result?.relationships?.length || 0}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Relationships</div>
                      </div>
                      <div style={{ background: '#1e293b', padding: '0.75rem', borderRadius: '6px', textAlign: 'center' }}>
                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#f59e0b' }}>{phase3SyncState.judges.length + phase3SyncState.users.length}</div>
                        <div style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Lookups Loaded</div>
                      </div>
                    </div>

                    {/* Action Buttons */}
                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
                      <button
                        className="btn btn-primary"
                        onClick={initPhase3Lookups}
                        disabled={phase3SyncState.loading || !airtableApiKey}
                        style={{ fontSize: '0.8rem' }}
                      >
                        {phase3SyncState.loading ? 'Loading...' : '1. Load Lookups'}
                      </button>
                      <button
                        onClick={() => uploadEventsToAirtable(true)}
                        disabled={phase3SyncState.loading || !phase3Result?.events?.length || phase3SyncState.judges.length === 0}
                        style={{ fontSize: '0.8rem', padding: '0.5rem 1rem', background: !phase3Result?.events?.length ? '#78716c' : '#f59e0b', color: 'white', border: 'none', borderRadius: '6px', cursor: !phase3Result?.events?.length ? 'not-allowed' : 'pointer', opacity: !phase3Result?.events?.length ? 0.6 : 1 }}
                      >
                        2. Test Events (5)
                      </button>
                      <button
                        onClick={() => uploadEventsToAirtable(false)}
                        disabled={phase3SyncState.loading || !phase3Result?.events?.length || phase3SyncState.judges.length === 0}
                        style={{ fontSize: '0.8rem', padding: '0.5rem 1rem', background: !phase3Result?.events?.length ? '#78716c' : '#10b981', color: 'white', border: 'none', borderRadius: '6px', cursor: !phase3Result?.events?.length ? 'not-allowed' : 'pointer', opacity: !phase3Result?.events?.length ? 0.6 : 1 }}
                      >
                        3. Upload All Events ({phase3Result?.events?.filter(e => e['Case Master']).length || 0})
                      </button>
                      <button
                        onClick={() => uploadRelationshipsToAirtable(true)}
                        disabled={phase3SyncState.loading || !phase3Result?.relationships?.length}
                        style={{ fontSize: '0.8rem', padding: '0.5rem 1rem', background: !phase3Result?.relationships?.length ? '#78716c' : '#8b5cf6', color: 'white', border: 'none', borderRadius: '6px', cursor: !phase3Result?.relationships?.length ? 'not-allowed' : 'pointer', opacity: !phase3Result?.relationships?.length ? 0.6 : 1 }}
                      >
                        4. Test Relationships (5)
                      </button>
                      <button
                        onClick={() => uploadRelationshipsToAirtable(false)}
                        disabled={phase3SyncState.loading || !phase3Result?.relationships?.length}
                        style={{ fontSize: '0.8rem', padding: '0.5rem 1rem', background: !phase3Result?.relationships?.length ? '#78716c' : '#ec4899', color: 'white', border: 'none', borderRadius: '6px', cursor: !phase3Result?.relationships?.length ? 'not-allowed' : 'pointer', opacity: !phase3Result?.relationships?.length ? 0.6 : 1 }}
                      >
                        5. Upload All Relationships ({phase3Result?.relationships?.filter(r => r['Case Master View'] && r['Object Client']).length || 0})
                      </button>
                    </div>

                    {/* Progress Bar */}
                    {phase3SyncState.progress.total > 0 && (
                      <div style={{ marginBottom: '1rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: '#94a3b8', marginBottom: '0.25rem' }}>
                          <span>{phase3SyncState.progress.phase}</span>
                          <span>{phase3SyncState.progress.current} / {phase3SyncState.progress.total}</span>
                        </div>
                        <div style={{ background: '#1e293b', borderRadius: '4px', height: '8px', overflow: 'hidden' }}>
                          <div style={{ height: '100%', background: 'linear-gradient(90deg, #6366f1, #10b981)', width: `${(phase3SyncState.progress.current / phase3SyncState.progress.total) * 100}%`, transition: 'width 0.3s' }} />
                        </div>
                      </div>
                    )}

                    {/* Logs */}
                    {phase3SyncState.logs.length > 0 && (
                      <div style={{ background: '#0f172a', borderRadius: '6px', padding: '0.75rem', maxHeight: '200px', overflowY: 'auto', fontSize: '0.75rem', fontFamily: 'monospace' }}>
                        {phase3SyncState.logs.map((log, i) => (
                          <div key={i} style={{ color: log.type === 'error' ? '#ef4444' : log.type === 'success' ? '#10b981' : log.type === 'warning' ? '#f59e0b' : '#94a3b8', marginBottom: '0.25rem' }}>
                            <span style={{ color: '#475569' }}>[{log.time}]</span> {log.message}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Phase 4: Case Notes to Xano */}
          {activePhase === 4 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Phase 4: Case Notes to Xano</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Create individual case notes in Xano, linked to clients and Case Master Views.
              </p>

              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem', marginBottom: '1.5rem' }}>
                {/* Airtable Client Info Export */}
                <div>
                  <h4 style={{ marginBottom: '0.5rem', fontSize: '0.875rem' }}>
                    Airtable Client Export <span className="badge badge-warning">Required</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>Record ID + clio_contact_id</p>
                  <div className="upload-zone-wrapper">
                    {phase4Files.airtableClients && (
                      <button className="file-remove-btn" onClick={clearPhase4File('airtableClients')} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${phase4Files.airtableClients ? 'has-file' : ''}`}>
                      <input type="file" accept=".csv" onChange={handleFileUpload(4, 'airtableClients')} style={{ display: 'none' }} />
                      {phase4Files.airtableClients ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {phase4Files.airtableClients.name}
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                      )}
                    </label>
                  </div>
                </div>

                {/* Airtable Case Master Export */}
                <div>
                  <h4 style={{ marginBottom: '0.5rem', fontSize: '0.875rem' }}>
                    Airtable Case Master Export <span className="badge badge-warning">Required</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>Record ID + clio_matter_id + PP ID</p>
                  <div className="upload-zone-wrapper">
                    {phase4Files.airtableCaseMaster && (
                      <button className="file-remove-btn" onClick={clearPhase4File('airtableCaseMaster')} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${phase4Files.airtableCaseMaster ? 'has-file' : ''}`}>
                      <input type="file" accept=".csv" onChange={handleFileUpload(4, 'airtableCaseMaster')} style={{ display: 'none' }} />
                      {phase4Files.airtableCaseMaster ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {phase4Files.airtableCaseMaster.name}
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                      )}
                    </label>
                  </div>
                </div>

                {/* Clio Notes Export */}
                <div>
                  <h4 style={{ marginBottom: '0.5rem', fontSize: '0.875rem' }}>
                    Clio Notes Export <span className="badge badge-warning">Required</span>
                  </h4>
                  <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '0.5rem' }}>MatterId, Subject, Detail, Date, Creator</p>
                  <div className="upload-zone-wrapper">
                    {phase4Files.clioNotes && (
                      <button className="file-remove-btn" onClick={clearPhase4File('clioNotes')} title="Remove file">×</button>
                    )}
                    <label className={`upload-zone ${phase4Files.clioNotes ? 'has-file' : ''}`}>
                      <input type="file" accept=".csv" onChange={handleFileUpload(4, 'clioNotes')} style={{ display: 'none' }} />
                      {phase4Files.clioNotes ? (
                        <div>
                          <span style={{ color: '#22c55e' }}>✓</span> {phase4Files.clioNotes.name}
                        </div>
                      ) : (
                        <div style={{ color: '#71717a' }}>Drop CSV or click</div>
                      )}
                    </label>
                  </div>
                </div>
              </div>

              {/* Process Button */}
              <button
                className="btn btn-primary"
                onClick={runPhase4}
                disabled={!phase4Data.airtableClients || !phase4Data.airtableCaseMaster || !phase4Data.clioNotes}
                style={{ marginBottom: '1.5rem' }}
              >
                Process Notes & Preview
              </button>

              {/* Report */}
              {phase4Report.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>Processing Log</h4>
                  <div style={{ background: 'rgba(0, 0, 0, 0.3)', padding: '1rem', borderRadius: '8px', maxHeight: '200px', overflowY: 'auto' }}>
                    {phase4Report.map((r, i) => (
                      <div key={i} style={{
                        padding: '0.25rem 0',
                        fontSize: '0.75rem',
                        color: r.type === 'error' ? '#f87171' : r.type === 'warning' ? '#fbbf24' : '#4ade80',
                      }}>
                        [{r.type.toUpperCase()}] {r.message}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Results */}
              {phase4Result && (
                <div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                    <h4>
                      Notes Preview ({phase4Result.notes?.length || 0} notes)
                      <span style={{ fontSize: '0.75rem', color: '#71717a', marginLeft: '0.5rem' }}>
                        {phase4Result.linkedCount} linked, {phase4Result.unlinkedCount} unlinked
                      </span>
                    </h4>
                    <button
                      className="btn btn-primary"
                      onClick={postNotesToXano}
                      disabled={phase4Progress.status === 'posting' || !phase4Result.notes?.length}
                      style={{ background: 'linear-gradient(135deg, #ec4899 0%, #f472b6 100%)' }}
                    >
                      {phase4Progress.status === 'posting'
                        ? `Posting... ${phase4Progress.current}/${phase4Progress.total}`
                        : 'POST All Notes to Xano'}
                    </button>
                  </div>

                  {/* Progress Bar */}
                  {phase4Progress.status === 'posting' && (
                    <div style={{ marginBottom: '1rem' }}>
                      <div style={{ background: 'rgba(0, 0, 0, 0.3)', borderRadius: '4px', height: '8px', overflow: 'hidden' }}>
                        <div style={{
                          width: `${(phase4Progress.current / phase4Progress.total) * 100}%`,
                          height: '100%',
                          background: 'linear-gradient(90deg, #ec4899, #f472b6)',
                          transition: 'width 0.2s ease',
                        }} />
                      </div>
                      <p style={{ fontSize: '0.75rem', color: '#a1a1aa', marginTop: '0.25rem' }}>
                        {phase4Progress.current} of {phase4Progress.total} notes
                      </p>
                    </div>
                  )}

                  {/* Notes Table */}
                  <div style={{ maxHeight: '400px', overflowY: 'auto', background: 'rgba(0, 0, 0, 0.2)', borderRadius: '8px' }}>
                    <table style={{ width: '100%', fontSize: '0.75rem', borderCollapse: 'collapse' }}>
                      <thead style={{ position: 'sticky', top: 0, background: 'rgba(39, 39, 42, 0.95)' }}>
                        <tr>
                          <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>#</th>
                          <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>Subject</th>
                          <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>PP ID</th>
                          <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>Client</th>
                          <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>Date</th>
                          <th style={{ padding: '0.5rem', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>Creator</th>
                          <th style={{ padding: '0.5rem', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>Linked</th>
                        </tr>
                      </thead>
                      <tbody>
                        {phase4Result.notes?.slice(0, 100).map((note, i) => (
                          <tr key={i} style={{ borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
                            <td style={{ padding: '0.5rem', color: '#71717a' }}>{i + 1}</td>
                            <td style={{ padding: '0.5rem', maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                              {note._subject || note.Activity}
                            </td>
                            <td style={{ padding: '0.5rem', fontFamily: 'monospace', color: '#a5b4fc' }}>{note.Client_PP_ID}</td>
                            <td style={{ padding: '0.5rem' }}>{note.Contact}</td>
                            <td style={{ padding: '0.5rem', color: '#71717a' }}>{note._date}</td>
                            <td style={{ padding: '0.5rem', color: '#71717a' }}>{note._creator}</td>
                            <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                              {note._linked
                                ? <span style={{ color: '#4ade80' }}>✓</span>
                                : <span style={{ color: '#f87171' }}>✗</span>
                              }
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                    {phase4Result.notes?.length > 100 && (
                      <p style={{ padding: '0.5rem', color: '#71717a', fontSize: '0.75rem', textAlign: 'center' }}>
                        Showing first 100 of {phase4Result.notes.length} notes
                      </p>
                    )}
                  </div>

                  {/* Next Steps */}
                  <div style={{ marginTop: '1.5rem', padding: '1rem', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                    <h4 style={{ color: '#4ade80', marginBottom: '0.5rem' }}>Next Steps</h4>
                    <ol style={{ fontSize: '0.875rem', color: '#a1a1aa', paddingLeft: '1.25rem' }}>
                      <li>Review the notes preview above</li>
                      <li>Click "POST All Notes to Xano" to create notes in Xano</li>
                      <li>Check the processing log for any errors</li>
                    </ol>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Dev Tools */}
          {activePhase === 5 && (
            <div>
              <h2 style={{ marginBottom: '1rem', fontSize: '1.25rem' }}>Developer Tools</h2>
              <p style={{ color: '#71717a', marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                Fetch Airtable schema for relevant fields, look up specific records, and test Xano case notes API.
              </p>

              {/* API Key Input */}
              <div style={{ marginBottom: '1.5rem', padding: '1rem', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', border: '1px solid rgba(99, 102, 241, 0.3)' }}>
                <h4 style={{ marginBottom: '0.75rem', color: '#a5b4fc' }}>Airtable API Configuration</h4>
                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                  <input
                    type="password"
                    value={airtableApiKey}
                    onChange={(e) => setAirtableApiKey(e.target.value)}
                    placeholder="Enter your Airtable Personal Access Token (pat...)"
                    style={{
                      flex: 1,
                      padding: '0.5rem 0.75rem',
                      borderRadius: '6px',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      background: 'rgba(0, 0, 0, 0.3)',
                      color: '#e4e4e7',
                      fontFamily: 'monospace',
                      fontSize: '0.875rem',
                    }}
                  />
                  <button
                    className="btn btn-primary"
                    onClick={fetchAirtableBases}
                    disabled={devToolsLoading || !airtableApiKey}
                  >
                    {devToolsLoading ? 'Loading...' : 'Load Bases'}
                  </button>
                </div>
                <p style={{ fontSize: '0.75rem', color: '#71717a', marginTop: '0.5rem' }}>
                  Get your API key from <a href="https://airtable.com/create/tokens" target="_blank" style={{ color: '#6366f1' }}>airtable.com/create/tokens</a>
                </p>
              </div>

              {/* Error Display */}
              {devToolsError && (
                <div style={{ marginBottom: '1rem', padding: '0.75rem', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px', border: '1px solid rgba(239, 68, 68, 0.3)', color: '#f87171', fontSize: '0.875rem' }}>
                  {devToolsError}
                </div>
              )}

              {/* Schema Viewer */}
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', marginBottom: '1.5rem' }}>
                {/* Base Selection */}
                <div>
                  <h4 style={{ marginBottom: '0.75rem' }}>Schema Viewer</h4>

                  {devToolsBases.length > 0 && (
                    <div style={{ marginBottom: '1rem' }}>
                      <label style={{ display: 'block', fontSize: '0.75rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Select Base</label>
                      <select
                        value={devToolsBaseId}
                        onChange={(e) => {
                          setDevToolsBaseId(e.target.value);
                          setDevToolsTables([]);
                          setDevToolsSchema(null);
                          setDevToolsRecord(null);
                          setDevToolsTableName('');
                          if (e.target.value) fetchAirtableSchema(e.target.value);
                        }}
                        style={{
                          width: '100%',
                          padding: '0.5rem',
                          borderRadius: '6px',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          background: 'rgba(0, 0, 0, 0.3)',
                          color: '#e4e4e7',
                          fontSize: '0.875rem',
                        }}
                      >
                        <option value="">-- Select a base --</option>
                        {devToolsBases.map(base => (
                          <option key={base.id} value={base.id}>{base.name}</option>
                        ))}
                      </select>
                    </div>
                  )}

                  {devToolsTables.length > 0 && (
                    <div style={{ fontSize: '0.8rem', color: '#a1a1aa' }}>
                      Found <strong style={{ color: '#6366f1' }}>{devToolsTables.length}</strong> tables in this base
                    </div>
                  )}
                </div>

                {/* Record Lookup */}
                <div>
                  <h4 style={{ marginBottom: '0.75rem' }}>Record Lookup</h4>
                  {devToolsTables.length > 0 && (
                    <div style={{ marginBottom: '0.75rem' }}>
                      <label style={{ display: 'block', fontSize: '0.75rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Select Table</label>
                      <select
                        value={devToolsTableName}
                        onChange={(e) => {
                          setDevToolsTableName(e.target.value);
                          setDevToolsRecord(null);
                        }}
                        style={{
                          width: '100%',
                          padding: '0.5rem',
                          borderRadius: '6px',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          background: 'rgba(0, 0, 0, 0.3)',
                          color: '#e4e4e7',
                          fontSize: '0.875rem',
                        }}
                      >
                        <option value="">-- Select a table --</option>
                        {devToolsTables.map(table => (
                          <option key={table.id} value={table.name}>{table.name}</option>
                        ))}
                      </select>
                    </div>
                  )}
                  <div style={{ marginBottom: '0.75rem' }}>
                    <label style={{ display: 'block', fontSize: '0.75rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Record ID</label>
                    <input
                      type="text"
                      value={devToolsRecordId}
                      onChange={(e) => setDevToolsRecordId(e.target.value)}
                      placeholder="rec..."
                      style={{
                        width: '100%',
                        padding: '0.5rem',
                        borderRadius: '6px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        background: 'rgba(0, 0, 0, 0.3)',
                        color: '#e4e4e7',
                        fontFamily: 'monospace',
                        fontSize: '0.875rem',
                      }}
                    />
                  </div>
                  <div style={{ display: 'flex', gap: '0.5rem' }}>
                    <button
                      className="btn btn-primary"
                      onClick={fetchAirtableRecord}
                      disabled={devToolsLoading || !devToolsBaseId || !devToolsTableName || !devToolsRecordId}
                    >
                      Fetch Record
                    </button>
                    {devToolsTableName && (
                      <button
                        className="btn btn-secondary"
                        onClick={() => fetchAirtableRecords(10)}
                        disabled={devToolsLoading}
                      >
                        Preview 10 Records
                      </button>
                    )}
                  </div>
                </div>
              </div>

              {/* All Tables Schema Display */}
              {devToolsTables.length > 0 && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                    <h4 style={{ margin: 0 }}>Base Schema</h4>
                    <button
                      className="btn btn-secondary"
                      style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem' }}
                      onClick={() => {
                        const schema = devToolsTables.map(t => ({
                          table: t.name,
                          fields: t.fields.map(f => ({ name: f.name, type: f.type }))
                        }));
                        const json = JSON.stringify(schema, null, 2);
                        navigator.clipboard.writeText(json);
                        alert('Full schema JSON copied to clipboard!');
                      }}
                    >
                      Copy All Tables JSON
                    </button>
                  </div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                    {devToolsTables.map(table => (
                      <details
                        key={table.id}
                        style={{
                          background: 'rgba(0, 0, 0, 0.3)',
                          borderRadius: '8px',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          overflow: 'hidden'
                        }}
                      >
                        <summary style={{
                          padding: '0.75rem 1rem',
                          cursor: 'pointer',
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          background: 'rgba(99, 102, 241, 0.1)',
                          borderBottom: '1px solid rgba(255, 255, 255, 0.05)'
                        }}>
                          <span style={{ fontWeight: 500, color: '#a5b4fc' }}>{table.name}</span>
                          <span style={{ fontSize: '0.75rem', color: '#71717a' }}>{table.fields?.length || 0} fields</span>
                        </summary>
                        <div style={{ padding: '0.75rem 1rem', maxHeight: '300px', overflowY: 'auto' }}>
                          <table style={{ width: '100%', fontSize: '0.8rem' }}>
                            <thead>
                              <tr style={{ borderBottom: '1px solid rgba(255, 255, 255, 0.1)' }}>
                                <th style={{ textAlign: 'left', padding: '0.25rem 0.5rem', color: '#a1a1aa' }}>Field Name</th>
                                <th style={{ textAlign: 'left', padding: '0.25rem 0.5rem', color: '#a1a1aa' }}>Type</th>
                                <th style={{ textAlign: 'left', padding: '0.25rem 0.5rem', color: '#a1a1aa' }}>Options / Links</th>
                              </tr>
                            </thead>
                            <tbody>
                              {table.fields?.map(field => (
                                <tr key={field.id} style={{ borderBottom: '1px solid rgba(255, 255, 255, 0.05)' }}>
                                  <td style={{ padding: '0.375rem 0.5rem', fontFamily: 'monospace', color: '#e4e4e7' }}>{field.name}</td>
                                  <td style={{ padding: '0.375rem 0.5rem' }}>
                                    <span style={{
                                      display: 'inline-block',
                                      padding: '0.125rem 0.5rem',
                                      borderRadius: '4px',
                                      fontSize: '0.7rem',
                                      background: field.type === 'multipleRecordLinks' ? 'rgba(168, 85, 247, 0.2)' :
                                                  field.type === 'singleSelect' || field.type === 'multipleSelects' ? 'rgba(34, 197, 94, 0.2)' :
                                                  field.type === 'formula' || field.type === 'rollup' || field.type === 'lookup' ? 'rgba(251, 191, 36, 0.2)' :
                                                  'rgba(99, 102, 241, 0.2)',
                                      color: field.type === 'multipleRecordLinks' ? '#c084fc' :
                                             field.type === 'singleSelect' || field.type === 'multipleSelects' ? '#4ade80' :
                                             field.type === 'formula' || field.type === 'rollup' || field.type === 'lookup' ? '#fbbf24' :
                                             '#818cf8'
                                    }}>
                                      {field.type}
                                    </span>
                                  </td>
                                  <td style={{ padding: '0.375rem 0.5rem', fontSize: '0.7rem', color: '#71717a' }}>
                                    {field.options?.choices?.map(c => c.name).join(', ') ||
                                     (field.options?.linkedTableId ?
                                       `→ ${devToolsTables.find(t => t.id === field.options.linkedTableId)?.name || field.options.linkedTableId}` : '') ||
                                     (field.options?.isReversed ? '(reverse link)' : '') ||
                                     ''}
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      </details>
                    ))}
                  </div>
                </div>
              )}

              {/* Record Display */}
              {devToolsRecord && (
                <div style={{ marginBottom: '1.5rem' }}>
                  <h4 style={{ marginBottom: '0.5rem' }}>
                    {devToolsRecord.records ? `Records (${devToolsRecord.records.length})` : `Record: ${devToolsRecord.id}`}
                  </h4>
                  <div style={{ maxHeight: '400px', overflowY: 'auto', background: 'rgba(0, 0, 0, 0.3)', borderRadius: '8px', padding: '1rem' }}>
                    <pre style={{ fontSize: '0.75rem', color: '#a1a1aa', whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                      {JSON.stringify(devToolsRecord, null, 2)}
                    </pre>
                  </div>
                </div>
              )}

              {/* Xano Case Notes */}
              <div style={{ marginTop: '2rem', padding: '1rem', background: 'rgba(236, 72, 153, 0.1)', borderRadius: '8px', border: '1px solid rgba(236, 72, 153, 0.3)' }}>
                <h4 style={{ marginBottom: '0.75rem', color: '#f472b6' }}>Xano Case Notes API</h4>
                <p style={{ fontSize: '0.75rem', color: '#71717a', marginBottom: '1rem' }}>
                  POST to: <code style={{ color: '#a1a1aa' }}>{XANO_CASE_NOTES_ENDPOINT}</code>
                </p>

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '0.75rem', marginBottom: '1rem' }}>
                  {['Activity', 'Type', 'Contact', 'Client_PP_ID', 'Matter', 'Created_By'].map(field => (
                    <div key={field}>
                      <label style={{ display: 'block', fontSize: '0.7rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>{field}</label>
                      <input
                        type="text"
                        value={caseNoteData[field]}
                        onChange={(e) => setCaseNoteData(prev => ({ ...prev, [field]: e.target.value }))}
                        style={{
                          width: '100%',
                          padding: '0.375rem 0.5rem',
                          borderRadius: '4px',
                          border: '1px solid rgba(255, 255, 255, 0.15)',
                          background: 'rgba(0, 0, 0, 0.2)',
                          color: '#e4e4e7',
                          fontSize: '0.8rem',
                        }}
                      />
                    </div>
                  ))}
                </div>

                <div style={{ marginBottom: '1rem' }}>
                  <label style={{ display: 'block', fontSize: '0.7rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Date</label>
                  <input
                    type="datetime-local"
                    value={caseNoteData.Date}
                    onChange={(e) => setCaseNoteData(prev => ({ ...prev, Date: e.target.value }))}
                    style={{
                      padding: '0.375rem 0.5rem',
                      borderRadius: '4px',
                      border: '1px solid rgba(255, 255, 255, 0.15)',
                      background: 'rgba(0, 0, 0, 0.2)',
                      color: '#e4e4e7',
                      fontSize: '0.8rem',
                    }}
                  />
                </div>

                <div style={{ marginBottom: '1rem' }}>
                  <label style={{ display: 'block', fontSize: '0.7rem', color: '#a1a1aa', marginBottom: '0.25rem' }}>Description</label>
                  <textarea
                    value={caseNoteData.Description}
                    onChange={(e) => setCaseNoteData(prev => ({ ...prev, Description: e.target.value }))}
                    rows={3}
                    style={{
                      width: '100%',
                      padding: '0.375rem 0.5rem',
                      borderRadius: '4px',
                      border: '1px solid rgba(255, 255, 255, 0.15)',
                      background: 'rgba(0, 0, 0, 0.2)',
                      color: '#e4e4e7',
                      fontSize: '0.8rem',
                      resize: 'vertical',
                    }}
                  />
                </div>

                <button
                  className="btn btn-primary"
                  onClick={postCaseNote}
                  disabled={devToolsLoading}
                  style={{ background: 'linear-gradient(135deg, #ec4899 0%, #f472b6 100%)' }}
                >
                  {devToolsLoading ? 'Posting...' : 'POST Case Note'}
                </button>

                {caseNoteResult && (
                  <div style={{ marginTop: '1rem', padding: '0.75rem', borderRadius: '6px', background: caseNoteResult.success ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)', border: `1px solid ${caseNoteResult.success ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)'}` }}>
                    <pre style={{ fontSize: '0.75rem', color: caseNoteResult.success ? '#4ade80' : '#f87171', whiteSpace: 'pre-wrap' }}>
                      {caseNoteResult.success ? JSON.stringify(caseNoteResult.data, null, 2) : caseNoteResult.error}
                    </pre>
                  </div>
                )}

                {/* Schema Reference */}
                <details style={{ marginTop: '1rem' }}>
                  <summary style={{ cursor: 'pointer', fontSize: '0.8rem', color: '#a1a1aa' }}>View Full Schema</summary>
                  <pre style={{ marginTop: '0.5rem', fontSize: '0.7rem', color: '#71717a', background: 'rgba(0,0,0,0.2)', padding: '0.5rem', borderRadius: '4px', overflowX: 'auto' }}>
                    {JSON.stringify(XANO_CASE_NOTES_SCHEMA, null, 2)}
                  </pre>
                </details>
              </div>

              {/* Expected Fields Reference */}
              <div style={{ marginTop: '1.5rem' }}>
                <h4 style={{ marginBottom: '0.75rem' }}>Expected Airtable Fields by Table</h4>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem' }}>
                  {Object.entries(AIRTABLE_TABLES).map(([tableName, fields]) => (
                    <div key={tableName} style={{ background: 'rgba(0, 0, 0, 0.2)', padding: '0.75rem', borderRadius: '6px' }}>
                      <h5 style={{ fontSize: '0.8rem', color: '#a5b4fc', marginBottom: '0.5rem' }}>{tableName}</h5>
                      <div style={{ fontSize: '0.7rem', color: '#71717a' }}>
                        {fields.map((f, i) => (
                          <span key={f}>
                            <code style={{ color: '#a1a1aa' }}>{f}</code>
                            {i < fields.length - 1 ? ', ' : ''}
                          </span>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Instructions */}
        <div className="card" style={{ marginTop: '1.5rem' }}>
          <h3 style={{ marginBottom: '1rem' }}>Import Order</h3>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', fontSize: '0.875rem' }}>
            <div>
              <div style={{ color: '#6366f1', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 1</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Upload Bahr + Clio Contacts</li>
                <li>Download clients.csv</li>
                <li>Import to Airtable</li>
                <li>Export with Record IDs</li>
              </ol>
            </div>
            <div>
              <div style={{ color: '#a855f7', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 2</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Fetch Clients from Airtable</li>
                <li>Upload Clio Matters/Notes</li>
                <li>Download case_master_views.csv</li>
                <li>Import to Airtable</li>
              </ol>
            </div>
            <div>
              <div style={{ color: '#ec4899', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 3</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Upload both Airtable exports</li>
                <li>Upload Clio Events/Relationships</li>
                <li>Generate events & relationships</li>
                <li>Upload directly to Airtable (or download CSV)</li>
              </ol>
            </div>
            <div>
              <div style={{ color: '#f472b6', fontWeight: 600, marginBottom: '0.5rem' }}>Phase 4</div>
              <ol style={{ paddingLeft: '1.25rem', color: '#a1a1aa' }}>
                <li>Upload both Airtable exports</li>
                <li>Upload Clio Notes CSV</li>
                <li>Preview notes & mappings</li>
                <li>POST notes to Xano</li>
              </ol>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<ClioAirtableMerger />);
  </script>
</body>
</html>
