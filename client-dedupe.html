<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Client Deduplication Tool</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #e2e8f0;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    h1 { color: #a5b4fc; margin-bottom: 10px; }
    .subtitle { color: #94a3b8; margin-bottom: 20px; }

    .card {
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid #334155;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .card h2 { color: #a5b4fc; margin-bottom: 15px; font-size: 1.2em; }
    .card h3 { color: #94a3b8; margin-bottom: 10px; font-size: 1em; }

    .input-group { margin-bottom: 15px; }
    .input-group label { display: block; margin-bottom: 5px; color: #94a3b8; }
    input[type="text"], input[type="password"], select, textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #1e293b;
      color: #e2e8f0;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s;
    }
    button.primary { background: #6366f1; color: white; }
    button.primary:hover { background: #4f46e5; }
    button.success { background: #10b981; color: white; }
    button.success:hover { background: #059669; }
    button.warning { background: #f59e0b; color: white; }
    button.warning:hover { background: #d97706; }
    button.danger { background: #ef4444; color: white; }
    button.danger:hover { background: #dc2626; }
    button:disabled { background: #475569; cursor: not-allowed; opacity: 0.6; }

    .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
      margin: 15px 0;
    }
    .stat-card {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    .stat-card .number { font-size: 1.8em; font-weight: bold; color: #10b981; }
    .stat-card .label { color: #94a3b8; font-size: 0.85em; }
    .stat-card.warning .number { color: #f59e0b; }
    .stat-card.danger .number { color: #ef4444; }
    .stat-card.info .number { color: #6366f1; }

    .table-container { overflow-x: auto; margin: 15px 0; max-height: 500px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #334155; }
    th { background: #1e293b; position: sticky; top: 0; color: #a5b4fc; z-index: 10; }
    tr:hover { background: rgba(99, 102, 241, 0.1); }

    .group-header {
      background: #334155 !important;
      font-weight: bold;
    }
    .group-header td {
      color: #a5b4fc;
      border-bottom: 2px solid #6366f1;
    }

    .keep-row { background: rgba(16, 185, 129, 0.15); }
    .delete-row { background: rgba(239, 68, 68, 0.15); }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: 500;
    }
    .badge.keep { background: #10b981; color: white; }
    .badge.delete { background: #ef4444; color: white; }
    .badge.box { background: #6366f1; color: white; }

    .log-container {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.85em;
    }
    .log-entry { padding: 4px 0; border-bottom: 1px solid #1e293b; }
    .log-entry.info { color: #6366f1; }
    .log-entry.success { color: #10b981; }
    .log-entry.warning { color: #f59e0b; }
    .log-entry.error { color: #ef4444; }

    .progress-bar {
      background: #1e293b;
      border-radius: 4px;
      height: 8px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-bar .fill {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #10b981);
      transition: width 0.3s;
    }

    .tabs { display: flex; gap: 5px; margin-bottom: 15px; }
    .tab {
      padding: 10px 20px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      color: #94a3b8;
    }
    .tab.active { background: #334155; color: #a5b4fc; border-bottom-color: #334155; }

    .box-info {
      background: #1e293b;
      border: 1px solid #475569;
      border-radius: 6px;
      padding: 15px;
      margin-top: 15px;
    }
    .box-info h4 { color: #f59e0b; margin-bottom: 10px; }
    .box-info pre {
      background: #0f172a;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 0.85em;
      color: #94a3b8;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #94a3b8;
    }
    .checkbox-label input {
      width: 18px;
      height: 18px;
    }

    .filter-controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 15px;
      align-items: center;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback, useEffect, useRef } = React;

// ============================================
// CONFIGURATION
// ============================================

const AIRTABLE_BASE_ID = 'app1tsUyKa7F3sy0D';
const CLIENT_INFO_TABLE = 'Client Info';

// Fields to fetch from Airtable for deduplication
const FIELDS_TO_FETCH = [
  'Client Name',
  'Full_Name_Normal_Pretty',
  'First Name',
  'Middle Name',
  'Family Name',
  'A#',
  'DOB',
  'Phone Number',
  'Client Email',
  'Address',
  'Address Line 1',
  'City',
  'State',
  'Zip (5)',
  'Country',
  'Entry Date',
  'PPID',
  'Box_Folder_ID',
  'box_shared_link',
  'Box Legacy ID',
  'clio_contact_id',
  'Client ID',
  'Created At',
  'Airtable_Last_Modified',
  'Bahr Client',
  'Case Master View',
  'Events',
  'Relationships',
  'Client Notes',
  'Matters',
];

// ============================================
// AIRTABLE CLIENT
// ============================================

class AirtableClient {
  constructor(apiKey, baseId) {
    this.apiKey = apiKey;
    this.baseId = baseId;
    this.baseUrl = `https://api.airtable.com/v0/${baseId}`;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const response = await fetch(url, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `API error: ${response.status}`);
    }

    return response.json();
  }

  async getAllRecords(tableName, fields = [], filterFormula = '', logCallback = null) {
    const allRecords = [];
    let offset = null;
    let pageNum = 0;

    do {
      const params = new URLSearchParams();
      if (fields.length > 0) {
        fields.forEach(f => params.append('fields[]', f));
      }
      if (filterFormula) {
        params.append('filterByFormula', filterFormula);
      }
      if (offset) {
        params.append('offset', offset);
      }
      params.append('pageSize', '100');

      const result = await this.request(`/${encodeURIComponent(tableName)}?${params}`);
      allRecords.push(...result.records);
      offset = result.offset;
      pageNum++;

      if (logCallback) {
        logCallback(`Fetched page ${pageNum}: ${result.records.length} records (total: ${allRecords.length})`, 'info');
      }

      // Rate limiting
      if (offset) {
        await new Promise(r => setTimeout(r, 200));
      }
    } while (offset);

    return allRecords;
  }

  async deleteRecords(tableName, recordIds, logCallback = null) {
    const results = [];

    // Process in batches of 10
    for (let i = 0; i < recordIds.length; i += 10) {
      const batch = recordIds.slice(i, i + 10);
      const params = batch.map(id => `records[]=${id}`).join('&');

      try {
        const result = await this.request(`/${encodeURIComponent(tableName)}?${params}`, {
          method: 'DELETE',
        });
        results.push(...result.records);

        if (logCallback) {
          logCallback(`Deleted batch ${Math.floor(i/10) + 1}: ${result.records.length} records`, 'success');
        }
      } catch (err) {
        if (logCallback) {
          logCallback(`Batch ${Math.floor(i/10) + 1} failed: ${err.message}`, 'error');
        }
      }

      // Rate limiting
      await new Promise(r => setTimeout(r, 250));
    }

    return results;
  }
}

// ============================================
// NAME NORMALIZATION
// ============================================

// Normalize a name for comparison (remove punctuation, extra spaces, lowercase)
const normalizeName = (name) => {
  if (!name) return '';

  return name
    .toLowerCase()
    .trim()
    // Remove common suffixes/prefixes
    .replace(/\s*,\s*/g, ' ')
    .replace(/\s+/g, ' ')
    // Remove punctuation
    .replace(/[.,\-'"()]/g, '')
    // Remove extra whitespace
    .replace(/\s+/g, ' ')
    .trim();
};

// Build a composite name from first/middle/family name fields
const buildCompositeName = (record) => {
  const fields = record.fields || {};
  const parts = [
    fields['First Name'],
    fields['Middle Name'],
    fields['Family Name'],
  ].filter(Boolean);

  if (parts.length > 0) {
    return parts.join(' ');
  }

  // Fallback to other name fields
  return fields['Full_Name_Normal_Pretty'] ||
         fields['Client Name'] ||
         '';
};

// Get the best name for display
const getDisplayName = (record) => {
  const fields = record.fields || {};
  return fields['Full_Name_Normal_Pretty'] ||
         fields['Client Name'] ||
         buildCompositeName(record) ||
         `Record ${record.id}`;
};

// ============================================
// RECORD SCORING
// ============================================

// Score a record based on completeness (higher = more data = better)
const scoreRecord = (record) => {
  const fields = record.fields || {};
  let score = 0;

  // Core identity fields (high value)
  if (fields['A#'] && fields['A#'].trim()) score += 50;
  if (fields['DOB']) score += 30;
  if (fields['clio_contact_id']) score += 25;

  // Box folder info (high value - indicates linked documents)
  if (fields['Box_Folder_ID']) score += 40;
  if (fields['box_shared_link']) score += 10;
  if (fields['Box Legacy ID']) score += 10;

  // Contact info
  if (fields['Phone Number'] && fields['Phone Number'].trim()) score += 15;
  if (fields['Client Email'] && fields['Client Email'].trim() && !fields['Client Email'].includes('null@blank')) score += 15;

  // Address fields
  if (fields['Address Line 1'] || fields['Address']) score += 10;
  if (fields['City']) score += 5;
  if (fields['State']) score += 5;
  if (fields['Zip (5)']) score += 5;
  if (fields['Country']) score += 5;

  // Linked records (very high value - indicates real data)
  const caseViews = fields['Case Master View'] || [];
  score += caseViews.length * 100;

  const events = fields['Events'] || [];
  score += events.length * 50;

  const relationships = fields['Relationships'] || [];
  score += relationships.length * 30;

  const notes = fields['Client Notes'] || [];
  score += notes.length * 20;

  const matters = fields['Matters'] || [];
  score += matters.length * 80;

  // Entry date (older records may be more established)
  if (fields['Entry Date']) score += 10;

  // PPID indicates Practice Panther link
  if (fields['PPID']) score += 20;

  // Name completeness
  if (fields['First Name']) score += 5;
  if (fields['Middle Name']) score += 3;
  if (fields['Family Name']) score += 5;

  return score;
};

// ============================================
// MAIN APP
// ============================================

function App() {
  const [apiKey, setApiKey] = useState(() => localStorage.getItem('airtable_api_key') || '');
  const [baseId, setBaseId] = useState(AIRTABLE_BASE_ID);
  const [loading, setLoading] = useState(false);
  const [logs, setLogs] = useState([]);
  const [progress, setProgress] = useState({ current: 0, total: 0, phase: '' });

  const [allRecords, setAllRecords] = useState([]);
  const [duplicateGroups, setDuplicateGroups] = useState([]);
  const [recordsToDelete, setRecordsToDelete] = useState([]);
  const [recordsToKeep, setRecordsToKeep] = useState([]);
  const [boxFoldersToDelete, setBoxFoldersToDelete] = useState([]);

  const [activeTab, setActiveTab] = useState('duplicates');
  const [showOnlyWithBox, setShowOnlyWithBox] = useState(false);
  const [showOnlyBahr, setShowOnlyBahr] = useState(false);

  const logRef = useRef(null);

  // Save API key to localStorage
  useEffect(() => {
    if (apiKey) {
      localStorage.setItem('airtable_api_key', apiKey);
    }
  }, [apiKey]);

  // Auto-scroll logs
  useEffect(() => {
    if (logRef.current) {
      logRef.current.scrollTop = logRef.current.scrollHeight;
    }
  }, [logs]);

  const addLog = useCallback((message, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    setLogs(prev => [...prev, { message, type, timestamp }]);
  }, []);

  const clearLogs = useCallback(() => {
    setLogs([]);
  }, []);

  // Fetch all client records
  const fetchAllClients = async () => {
    if (!apiKey) {
      addLog('Please enter your Airtable API key', 'error');
      return;
    }

    setLoading(true);
    clearLogs();
    addLog('Starting to fetch all Client Info records...', 'info');
    setProgress({ current: 0, total: 0, phase: 'Fetching records' });

    try {
      const client = new AirtableClient(apiKey, baseId);
      const records = await client.getAllRecords(CLIENT_INFO_TABLE, FIELDS_TO_FETCH, '', addLog);

      setAllRecords(records);
      addLog(`Successfully fetched ${records.length} total client records`, 'success');

      // Automatically find duplicates
      findDuplicates(records);
    } catch (err) {
      addLog(`Error fetching records: ${err.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Find duplicate records
  const findDuplicates = (records) => {
    addLog('Analyzing records for duplicates...', 'info');

    // Group records by normalized name
    const nameGroups = new Map();

    records.forEach(record => {
      const name = getDisplayName(record);
      const normalizedName = normalizeName(name);

      if (!normalizedName) {
        addLog(`Skipping record ${record.id} - no name found`, 'warning');
        return;
      }

      if (!nameGroups.has(normalizedName)) {
        nameGroups.set(normalizedName, []);
      }
      nameGroups.get(normalizedName).push(record);
    });

    // Find groups with more than one record (duplicates)
    const dupeGroups = [];
    const toDelete = [];
    const toKeep = [];
    const boxToDelete = [];

    nameGroups.forEach((group, normalizedName) => {
      if (group.length > 1) {
        // Score each record
        const scoredRecords = group.map(record => ({
          record,
          score: scoreRecord(record),
          name: getDisplayName(record),
        }));

        // Sort by score descending (highest score = best record to keep)
        scoredRecords.sort((a, b) => b.score - a.score);

        const keepRecord = scoredRecords[0];
        const deleteRecords = scoredRecords.slice(1);

        dupeGroups.push({
          normalizedName,
          displayName: keepRecord.name,
          keepRecord,
          deleteRecords,
          totalRecords: group.length,
        });

        toKeep.push(keepRecord);

        deleteRecords.forEach(dr => {
          toDelete.push(dr);

          // Check for Box folder info on records to delete
          const fields = dr.record.fields || {};
          if (fields['Box_Folder_ID'] || fields['box_shared_link'] || fields['Box Legacy ID']) {
            boxToDelete.push({
              recordId: dr.record.id,
              clientName: dr.name,
              boxFolderId: fields['Box_Folder_ID'] || '',
              boxSharedLink: fields['box_shared_link'] || '',
              boxLegacyId: fields['Box Legacy ID'] || '',
              score: dr.score,
            });
          }
        });
      }
    });

    // Sort duplicate groups by number of duplicates (most duplicates first)
    dupeGroups.sort((a, b) => b.totalRecords - a.totalRecords);

    setDuplicateGroups(dupeGroups);
    setRecordsToDelete(toDelete);
    setRecordsToKeep(toKeep);
    setBoxFoldersToDelete(boxToDelete);

    addLog(`Found ${dupeGroups.length} duplicate groups`, dupeGroups.length > 0 ? 'warning' : 'success');
    addLog(`  - ${toKeep.length} records to keep`, 'info');
    addLog(`  - ${toDelete.length} records to delete`, toDelete.length > 0 ? 'warning' : 'info');
    addLog(`  - ${boxToDelete.length} Box folders that need cleanup`, boxToDelete.length > 0 ? 'warning' : 'info');
  };

  // Export duplicates to CSV
  const exportDuplicatesToCSV = () => {
    if (recordsToDelete.length === 0) {
      addLog('No duplicates to export', 'warning');
      return;
    }

    const rows = recordsToDelete.map(dr => {
      const fields = dr.record.fields || {};
      return {
        'Action': 'DELETE',
        'Record ID': dr.record.id,
        'Client Name': dr.name,
        'Score': dr.score,
        'A#': fields['A#'] || '',
        'DOB': fields['DOB'] || '',
        'Phone': fields['Phone Number'] || '',
        'Email': fields['Client Email'] || '',
        'Box_Folder_ID': fields['Box_Folder_ID'] || '',
        'box_shared_link': fields['box_shared_link'] || '',
        'Box Legacy ID': fields['Box Legacy ID'] || '',
        'PPID': fields['PPID'] || '',
        'clio_contact_id': fields['clio_contact_id'] || '',
        'Case Master Views': (fields['Case Master View'] || []).length,
        'Events': (fields['Events'] || []).length,
        'Relationships': (fields['Relationships'] || []).length,
        'Is Bahr Client': fields['Bahr Client'] ? 'Yes' : 'No',
      };
    });

    const worksheet = XLSX.utils.json_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Duplicates to Delete');

    const timestamp = new Date().toISOString().split('T')[0];
    XLSX.writeFile(workbook, `client_duplicates_to_delete_${timestamp}.xlsx`);

    addLog(`Exported ${rows.length} duplicate records to Excel`, 'success');
  };

  // Export Box folders to delete
  const exportBoxFoldersToCSV = () => {
    if (boxFoldersToDelete.length === 0) {
      addLog('No Box folders to export', 'warning');
      return;
    }

    const rows = boxFoldersToDelete.map(box => ({
      'Record ID': box.recordId,
      'Client Name': box.clientName,
      'Box_Folder_ID': box.boxFolderId,
      'box_shared_link': box.boxSharedLink,
      'Box Legacy ID': box.boxLegacyId,
      'Record Score': box.score,
    }));

    const worksheet = XLSX.utils.json_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Box Folders to Delete');

    const timestamp = new Date().toISOString().split('T')[0];
    XLSX.writeFile(workbook, `box_folders_to_delete_${timestamp}.xlsx`);

    addLog(`Exported ${rows.length} Box folder records to Excel`, 'success');
  };

  // Export full analysis
  const exportFullAnalysis = () => {
    if (duplicateGroups.length === 0) {
      addLog('No duplicates to export', 'warning');
      return;
    }

    const rows = [];

    duplicateGroups.forEach(group => {
      // Add keep record
      const keepFields = group.keepRecord.record.fields || {};
      rows.push({
        'Group': group.displayName,
        'Action': 'KEEP',
        'Record ID': group.keepRecord.record.id,
        'Client Name': group.keepRecord.name,
        'Score': group.keepRecord.score,
        'A#': keepFields['A#'] || '',
        'DOB': keepFields['DOB'] || '',
        'Phone': keepFields['Phone Number'] || '',
        'Email': keepFields['Client Email'] || '',
        'Box_Folder_ID': keepFields['Box_Folder_ID'] || '',
        'box_shared_link': keepFields['box_shared_link'] || '',
        'Case Master Views': (keepFields['Case Master View'] || []).length,
        'Events': (keepFields['Events'] || []).length,
        'PPID': keepFields['PPID'] || '',
        'Is Bahr Client': keepFields['Bahr Client'] ? 'Yes' : 'No',
      });

      // Add delete records
      group.deleteRecords.forEach(dr => {
        const fields = dr.record.fields || {};
        rows.push({
          'Group': group.displayName,
          'Action': 'DELETE',
          'Record ID': dr.record.id,
          'Client Name': dr.name,
          'Score': dr.score,
          'A#': fields['A#'] || '',
          'DOB': fields['DOB'] || '',
          'Phone': fields['Phone Number'] || '',
          'Email': fields['Client Email'] || '',
          'Box_Folder_ID': fields['Box_Folder_ID'] || '',
          'box_shared_link': fields['box_shared_link'] || '',
          'Case Master Views': (fields['Case Master View'] || []).length,
          'Events': (fields['Events'] || []).length,
          'PPID': fields['PPID'] || '',
          'Is Bahr Client': fields['Bahr Client'] ? 'Yes' : 'No',
        });
      });
    });

    const worksheet = XLSX.utils.json_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Full Analysis');

    const timestamp = new Date().toISOString().split('T')[0];
    XLSX.writeFile(workbook, `client_dedupe_full_analysis_${timestamp}.xlsx`);

    addLog(`Exported full analysis with ${rows.length} records to Excel`, 'success');
  };

  // Export just record IDs to delete
  const exportRecordIdsToDelete = () => {
    if (recordsToDelete.length === 0) {
      addLog('No records to delete', 'warning');
      return;
    }

    const ids = recordsToDelete.map(dr => dr.record.id);
    const json = JSON.stringify(ids, null, 2);

    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `record_ids_to_delete_${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);

    addLog(`Exported ${ids.length} record IDs to JSON`, 'success');
  };

  // Actually delete records from Airtable
  const deleteRecordsFromAirtable = async () => {
    if (recordsToDelete.length === 0) {
      addLog('No records to delete', 'warning');
      return;
    }

    if (!window.confirm(`Are you sure you want to delete ${recordsToDelete.length} records from Airtable? This cannot be undone!`)) {
      return;
    }

    if (!window.confirm(`FINAL WARNING: This will permanently delete ${recordsToDelete.length} records. Type 'yes' in the next prompt to confirm.`)) {
      return;
    }

    const confirmation = window.prompt('Type "DELETE" to confirm deletion:');
    if (confirmation !== 'DELETE') {
      addLog('Deletion cancelled - confirmation not received', 'warning');
      return;
    }

    setLoading(true);
    addLog(`Starting deletion of ${recordsToDelete.length} records...`, 'warning');

    try {
      const client = new AirtableClient(apiKey, baseId);
      const idsToDelete = recordsToDelete.map(dr => dr.record.id);

      const results = await client.deleteRecords(CLIENT_INFO_TABLE, idsToDelete, addLog);

      addLog(`Successfully deleted ${results.length} records`, 'success');

      // Refresh the data
      await fetchAllClients();
    } catch (err) {
      addLog(`Error during deletion: ${err.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Filter duplicate groups based on current filters
  const filteredGroups = duplicateGroups.filter(group => {
    if (showOnlyWithBox) {
      const hasBox = group.deleteRecords.some(dr => {
        const fields = dr.record.fields || {};
        return fields['Box_Folder_ID'] || fields['box_shared_link'] || fields['Box Legacy ID'];
      });
      if (!hasBox) return false;
    }

    if (showOnlyBahr) {
      const hasBahr = group.deleteRecords.some(dr => {
        const fields = dr.record.fields || {};
        return fields['Bahr Client'];
      });
      if (!hasBahr) return false;
    }

    return true;
  });

  return (
    <div className="container">
      <h1>Client Deduplication Tool</h1>
      <p className="subtitle">Find and remove duplicate client records from Airtable, with Box folder tracking</p>

      {/* API Configuration */}
      <div className="card">
        <h2>Airtable Configuration</h2>
        <div className="input-group">
          <label>API Key (Personal Access Token)</label>
          <input
            type="password"
            value={apiKey}
            onChange={e => setApiKey(e.target.value)}
            placeholder="pat..."
          />
        </div>
        <div className="input-group">
          <label>Base ID</label>
          <input
            type="text"
            value={baseId}
            onChange={e => setBaseId(e.target.value)}
            placeholder="app..."
          />
        </div>
        <div className="btn-group">
          <button className="primary" onClick={fetchAllClients} disabled={loading || !apiKey}>
            {loading ? 'Loading...' : 'Fetch All Clients & Find Duplicates'}
          </button>
        </div>
      </div>

      {/* Progress */}
      {loading && (
        <div className="card">
          <div className="progress-bar">
            <div
              className="fill"
              style={{ width: progress.total ? `${(progress.current / progress.total) * 100}%` : '50%' }}
            />
          </div>
          <p style={{ textAlign: 'center', color: '#94a3b8' }}>{progress.phase}</p>
        </div>
      )}

      {/* Statistics */}
      {allRecords.length > 0 && (
        <div className="stats-grid">
          <div className="stat-card info">
            <div className="number">{allRecords.length}</div>
            <div className="label">Total Records</div>
          </div>
          <div className="stat-card warning">
            <div className="number">{duplicateGroups.length}</div>
            <div className="label">Duplicate Groups</div>
          </div>
          <div className="stat-card success">
            <div className="number">{recordsToKeep.length}</div>
            <div className="label">Records to Keep</div>
          </div>
          <div className="stat-card danger">
            <div className="number">{recordsToDelete.length}</div>
            <div className="label">Records to Delete</div>
          </div>
          <div className="stat-card warning">
            <div className="number">{boxFoldersToDelete.length}</div>
            <div className="label">Box Folders to Clean</div>
          </div>
        </div>
      )}

      {/* Tabs */}
      {duplicateGroups.length > 0 && (
        <div className="tabs">
          <div
            className={`tab ${activeTab === 'duplicates' ? 'active' : ''}`}
            onClick={() => setActiveTab('duplicates')}
          >
            Duplicate Groups ({filteredGroups.length})
          </div>
          <div
            className={`tab ${activeTab === 'box' ? 'active' : ''}`}
            onClick={() => setActiveTab('box')}
          >
            Box Folders ({boxFoldersToDelete.length})
          </div>
          <div
            className={`tab ${activeTab === 'export' ? 'active' : ''}`}
            onClick={() => setActiveTab('export')}
          >
            Export & Actions
          </div>
        </div>
      )}

      {/* Duplicates Table */}
      {activeTab === 'duplicates' && duplicateGroups.length > 0 && (
        <div className="card">
          <h2>Duplicate Groups</h2>

          <div className="filter-controls">
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={showOnlyWithBox}
                onChange={e => setShowOnlyWithBox(e.target.checked)}
              />
              Show only groups with Box folders
            </label>
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={showOnlyBahr}
                onChange={e => setShowOnlyBahr(e.target.checked)}
              />
              Show only Bahr clients
            </label>
          </div>

          <div className="table-container">
            <table>
              <thead>
                <tr>
                  <th>Action</th>
                  <th>Client Name</th>
                  <th>Score</th>
                  <th>Record ID</th>
                  <th>A#</th>
                  <th>DOB</th>
                  <th>Box Folder ID</th>
                  <th>Cases</th>
                  <th>Events</th>
                  <th>Bahr</th>
                </tr>
              </thead>
              <tbody>
                {filteredGroups.map((group, groupIdx) => (
                  <React.Fragment key={group.normalizedName}>
                    {/* Group header */}
                    <tr className="group-header">
                      <td colSpan="10">
                        {group.displayName} ({group.totalRecords} duplicates)
                      </td>
                    </tr>
                    {/* Keep record */}
                    <tr className="keep-row">
                      <td><span className="badge keep">KEEP</span></td>
                      <td>{group.keepRecord.name}</td>
                      <td><strong>{group.keepRecord.score}</strong></td>
                      <td><code>{group.keepRecord.record.id}</code></td>
                      <td>{group.keepRecord.record.fields['A#'] || '-'}</td>
                      <td>{group.keepRecord.record.fields['DOB'] || '-'}</td>
                      <td>
                        {group.keepRecord.record.fields['Box_Folder_ID'] ? (
                          <span className="badge box">{group.keepRecord.record.fields['Box_Folder_ID']}</span>
                        ) : '-'}
                      </td>
                      <td>{(group.keepRecord.record.fields['Case Master View'] || []).length}</td>
                      <td>{(group.keepRecord.record.fields['Events'] || []).length}</td>
                      <td>{group.keepRecord.record.fields['Bahr Client'] ? 'Yes' : 'No'}</td>
                    </tr>
                    {/* Delete records */}
                    {group.deleteRecords.map(dr => (
                      <tr key={dr.record.id} className="delete-row">
                        <td><span className="badge delete">DELETE</span></td>
                        <td>{dr.name}</td>
                        <td>{dr.score}</td>
                        <td><code>{dr.record.id}</code></td>
                        <td>{dr.record.fields['A#'] || '-'}</td>
                        <td>{dr.record.fields['DOB'] || '-'}</td>
                        <td>
                          {dr.record.fields['Box_Folder_ID'] ? (
                            <span className="badge box">{dr.record.fields['Box_Folder_ID']}</span>
                          ) : '-'}
                        </td>
                        <td>{(dr.record.fields['Case Master View'] || []).length}</td>
                        <td>{(dr.record.fields['Events'] || []).length}</td>
                        <td>{dr.record.fields['Bahr Client'] ? 'Yes' : 'No'}</td>
                      </tr>
                    ))}
                  </React.Fragment>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* Box Folders Tab */}
      {activeTab === 'box' && boxFoldersToDelete.length > 0 && (
        <div className="card">
          <h2>Box Folders to Delete</h2>
          <p style={{ color: '#f59e0b', marginBottom: '15px' }}>
            These Box folders are associated with duplicate records that will be deleted.
            You should manually delete or archive these folders in Box.
          </p>

          <div className="table-container">
            <table>
              <thead>
                <tr>
                  <th>Client Name</th>
                  <th>Record ID</th>
                  <th>Box Folder ID</th>
                  <th>Box Shared Link</th>
                  <th>Box Legacy ID</th>
                </tr>
              </thead>
              <tbody>
                {boxFoldersToDelete.map(box => (
                  <tr key={box.recordId}>
                    <td>{box.clientName}</td>
                    <td><code>{box.recordId}</code></td>
                    <td>{box.boxFolderId || '-'}</td>
                    <td>
                      {box.boxSharedLink ? (
                        <a href={box.boxSharedLink} target="_blank" rel="noopener noreferrer" style={{ color: '#6366f1' }}>
                          View Folder
                        </a>
                      ) : '-'}
                    </td>
                    <td>{box.boxLegacyId || '-'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <div className="box-info">
            <h4>Box Folder IDs to Delete (copy for Box admin)</h4>
            <pre>{boxFoldersToDelete.filter(b => b.boxFolderId).map(b => b.boxFolderId).join('\n') || 'No folder IDs found'}</pre>
          </div>
        </div>
      )}

      {/* Export & Actions Tab */}
      {activeTab === 'export' && duplicateGroups.length > 0 && (
        <div className="card">
          <h2>Export & Actions</h2>

          <div style={{ marginBottom: '20px' }}>
            <h3>Export Options</h3>
            <div className="btn-group">
              <button className="primary" onClick={exportFullAnalysis}>
                Export Full Analysis (Excel)
              </button>
              <button className="warning" onClick={exportDuplicatesToCSV}>
                Export Duplicates to Delete (Excel)
              </button>
              <button className="warning" onClick={exportBoxFoldersToCSV}>
                Export Box Folders (Excel)
              </button>
              <button className="primary" onClick={exportRecordIdsToDelete}>
                Export Record IDs (JSON)
              </button>
            </div>
          </div>

          <div style={{ borderTop: '1px solid #475569', paddingTop: '20px' }}>
            <h3 style={{ color: '#ef4444' }}>Danger Zone</h3>
            <p style={{ color: '#94a3b8', marginBottom: '15px' }}>
              These actions cannot be undone. Make sure to export and review before proceeding.
            </p>
            <button
              className="danger"
              onClick={deleteRecordsFromAirtable}
              disabled={loading || recordsToDelete.length === 0}
            >
              Delete {recordsToDelete.length} Duplicate Records from Airtable
            </button>
          </div>
        </div>
      )}

      {/* No duplicates message */}
      {allRecords.length > 0 && duplicateGroups.length === 0 && (
        <div className="card">
          <h2 style={{ color: '#10b981' }}>No Duplicates Found</h2>
          <p>All {allRecords.length} client records have unique names.</p>
        </div>
      )}

      {/* Activity Log */}
      <div className="card">
        <h2>Activity Log</h2>
        <div className="log-container" ref={logRef}>
          {logs.length === 0 ? (
            <div className="log-entry info">Ready - click "Fetch All Clients" to start</div>
          ) : (
            logs.map((log, idx) => (
              <div key={idx} className={`log-entry ${log.type}`}>
                [{log.timestamp}] {log.message}
              </div>
            ))
          )}
        </div>
        {logs.length > 0 && (
          <button
            className="warning"
            onClick={clearLogs}
            style={{ marginTop: '10px' }}
          >
            Clear Log
          </button>
        )}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
